"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSegmentWithoutAlias = exports.getPathBaseMetadataElement = void 0;
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const __1 = require("..");
/**
 * Gets outermost Metadata element which represents an entity type or complex type or has a structured type.
 *
 * @param metadata - metadataService instance
 * @param targetPath - segments separated by '/'; absolute (starts with /) or relative path
 * @param aliasInfo - object containing `alias - namespace` and `namespace - alias` maps of the file.
 * @returns metadata element or null
 */
function getPathBaseMetadataElement(metadata, targetPath, aliasInfo // if not provided: all aliases should be replaced already in targetPath
) {
    const originalSegments = (targetPath.startsWith('/') ? targetPath.slice(1) : targetPath).split('/');
    const segments = originalSegments.map((originalSegment) => {
        return aliasInfo ? getSegmentWithoutAlias(aliasInfo, originalSegment) : originalSegment;
    });
    const currentSegments = [];
    let pathBaseMetadataElement = null;
    let mostSpecificMetadataElement = null;
    for (let i = 0; i < segments.length && !pathBaseMetadataElement; i++) {
        currentSegments.push(segments[i]);
        const currentPath = currentSegments.join('/');
        const currentMetadataElement = metadata.getMetadataElement(currentPath);
        if (currentMetadataElement) {
            mostSpecificMetadataElement = currentMetadataElement;
            if (isEntityOrComplexOrStructuredType(currentMetadataElement) ||
                isPathPointingToActionKindElement(metadata, currentPath) // actions/function/actionImport/functionImport serve as path base for themselves and their parameters
            ) {
                pathBaseMetadataElement = currentMetadataElement;
            }
        }
    }
    return pathBaseMetadataElement ?? mostSpecificMetadataElement;
}
exports.getPathBaseMetadataElement = getPathBaseMetadataElement;
/**
 * Checks whether the given metadata element represents entity type or complex structured type.
 *
 * @param currentMetadataElement
 * @returns boolean result
 */
function isEntityOrComplexOrStructuredType(currentMetadataElement) {
    return (!!currentMetadataElement.isEntityType ||
        !!currentMetadataElement.isComplexType ||
        !!currentMetadataElement.structuredType);
}
/**
 * Determines whether the given path is pointing to element of action/function type.
 *
 * @param metadata metadata
 * @param path path
 * @returns boolean result
 */
function isPathPointingToActionKindElement(metadata, path) {
    const edmxTypes = metadata.getEdmTargetKinds(path);
    const actionKinds = [odata_annotation_core_types_1.ACTION_KIND, odata_annotation_core_types_1.FUNCTION_KIND, odata_annotation_core_types_1.ACTION_IMPORT_KIND, odata_annotation_core_types_1.FUNCTION_IMPORT_KIND];
    return edmxTypes.findIndex((edmxType) => actionKinds.includes(edmxType)) >= 0;
}
/**
 * Get segment without alias.
 *
 * @param aliasInfo  - object containing `alias - namespace` and `namespace - alias` maps of the file.
 * @param segment -  value separated by '/'
 * @returns segment text
 */
function getSegmentWithoutAlias(aliasInfo, segment) {
    let segmentWithoutAlias = '';
    const indexAt = segment.indexOf('@');
    if (indexAt >= 0) {
        const term = (0, __1.resolveName)(segment.substring(indexAt + 1), aliasInfo.aliasMap).qName;
        segmentWithoutAlias = segment.substring(0, indexAt) + '@' + term;
    }
    else if (segment.indexOf('.') > -1) {
        segmentWithoutAlias = (0, __1.resolveName)(segment, aliasInfo.aliasMap).qName;
    }
    else {
        segmentWithoutAlias = segment;
    }
    return segmentWithoutAlias;
}
exports.getSegmentWithoutAlias = getSegmentWithoutAlias;
//# sourceMappingURL=metadata.js.map