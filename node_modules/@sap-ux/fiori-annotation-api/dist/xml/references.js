"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectUsedNamespaces = void 0;
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
/**
 * Collects namespaces that are used in the subtree of the document.
 *
 * @param element - Subtree root element.
 * @param namespacesOrAliases - Set to which add used namespaces or aliases.
 */
function collectUsedNamespaces(element, namespacesOrAliases) {
    switch (element.type) {
        case odata_annotation_core_types_1.ANNOTATION_FILE_TYPE: {
            for (const target of element.targets) {
                collectUsedNamespaces(target, namespacesOrAliases);
            }
            break;
        }
        case odata_annotation_core_types_1.TARGET_TYPE: {
            if (element.name) {
                processPath(element.name, namespacesOrAliases);
            }
            for (const term of element.terms) {
                collectUsedNamespaces(term, namespacesOrAliases);
            }
            break;
        }
        case odata_annotation_core_types_1.ELEMENT_TYPE: {
            processElement(element, namespacesOrAliases);
            break;
        }
        default:
            break;
    }
}
exports.collectUsedNamespaces = collectUsedNamespaces;
const PATH_LIKE_VALUES = ["Path" /* Edm.Path */, "PropertyPath" /* Edm.PropertyPath */, "NavigationPropertyPath" /* Edm.NavigationPropertyPath */, "AnnotationPath" /* Edm.AnnotationPath */];
function processElement(element, namespacesOrAliases) {
    if (element.name === "Annotation" /* Edm.Annotation */) {
        const term = element.attributes["Term" /* Edm.Term */];
        if (term?.value) {
            processPath(term.value, namespacesOrAliases);
        }
    }
    if (element.name === "Record" /* Edm.Record */) {
        const type = element.attributes["Type" /* Edm.Type */];
        if (type?.value) {
            processPath(type.value, namespacesOrAliases);
        }
    }
    if (element.name === "PropertyValue" /* Edm.PropertyValue */ || element.name === "Annotation" /* Edm.Annotation */) {
        const type = element.attributes["EnumMember" /* Edm.EnumMember */];
        if (type?.value) {
            processPath(type.value, namespacesOrAliases);
        }
    }
    processPathLikeElement(element, namespacesOrAliases);
}
function processPathLikeElement(element, namespacesOrAliases) {
    if (PATH_LIKE_VALUES.includes(element.name)) {
        const textNode = element.content.find((node) => node.type === odata_annotation_core_types_1.TEXT_TYPE);
        if (textNode) {
            processPath(textNode.text, namespacesOrAliases);
        }
    }
    else {
        for (const attributeName of PATH_LIKE_VALUES) {
            const attribute = element.attributes[attributeName];
            if (attribute?.value) {
                processPath(attribute.value, namespacesOrAliases);
            }
        }
        for (const child of element.content) {
            collectUsedNamespaces(child, namespacesOrAliases);
        }
    }
}
function processPath(rawPath, namespacesOrAliases) {
    const path = (0, odata_annotation_core_1.parsePath)(rawPath);
    for (const segment of path.segments) {
        if (segment.namespaceOrAlias) {
            namespacesOrAliases.add(segment.namespaceOrAlias);
        }
    }
}
//# sourceMappingURL=references.js.map