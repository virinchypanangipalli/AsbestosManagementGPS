"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XMLWriter = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const cds_annotation_parser_1 = require("@sap-ux/cds-annotation-parser");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const xml_odata_annotation_converter_1 = require("@sap-ux/xml-odata-annotation-converter");
const ast_1 = require("@xml-tools/ast");
const utils_1 = require("../utils");
const changes_1 = require("./changes");
const pointer_1 = require("./pointer");
const printOptions = { ...odata_annotation_core_types_1.printOptions, useSnippetSyntax: false };
/**
 * Translates changes objects to XML text edits.
 */
class XMLWriter {
    document;
    comments;
    textDocument;
    changes = [];
    elementContentCache = new Map();
    /**
     *
     * @param document - XMLDocument AST node.
     * @param comments - Array of all the comments in the document.
     * @param textDocument - TextDocument instance.
     */
    constructor(document, comments, textDocument) {
        this.document = document;
        this.comments = comments;
        this.textDocument = textDocument;
    }
    /**
     *  Adds a new change to the change stack.
     *
     * @param change - Change to be added to the stack.
     */
    addChange(change) {
        this.changes.push(change);
    }
    /**
     * Transforms changes in the stack to text edits.
     *
     * @returns TextEdits.
     */
    getTextEdits() {
        const edits = [];
        const changes = preprocessChanges(this.changes, this.document);
        const batches = getBatches(changes);
        for (const pointer of Object.keys(batches)) {
            edits.push(...this.getTextEditsForPointer(pointer, batches[pointer]));
        }
        edits.sort(utils_1.compareByRange);
        return edits;
    }
    getContent(element) {
        let content = this.elementContentCache.get(element);
        if (!content) {
            content = getElementContent(element, this.comments);
            this.elementContentCache.set(element, content);
        }
        return content;
    }
    getTextEditsForPointer(pointer, byType) {
        const edits = [];
        const element = (0, pointer_1.getNodeFromPointer)(this.document, pointer);
        const childIndentLevel = getIndentFromElement(element);
        const inserts = (byType.get('insert-element') ?? []);
        const insertEdits = convertInsertElementToTextEdits(this.comments, element, inserts, childIndentLevel);
        edits.push(...insertEdits);
        const elementNameUpdates = (byType.get('update-element-name') ?? []);
        edits.push(...convertUpdateElementNameToTextEdits(elementNameUpdates, element));
        switch (element?.type) {
            case 'XMLElement': {
                const elementChanges = {
                    replacements: (byType.get('replace-element') ?? []),
                    contentReplacements: (byType.get(changes_1.REPLACE_ELEMENT_CONTENT) ?? []),
                    elementDeletions: (byType.get('delete-element') ?? []),
                    attributeInserts: (byType.get('insert-attribute') ?? []),
                    moveInCollection: (byType.get('move-collection-value') ?? [])
                };
                edits.push(...this.handleXmlElementChanges(elementChanges, element, pointer, childIndentLevel));
                break;
            }
            case 'XMLAttribute': {
                const attributeChanges = {
                    attributeDeletions: (byType.get('delete-attribute') ?? []),
                    attributeNameUpdates: (byType.get('update-attribute-name') ?? []),
                    attributeValueUpdates: (byType.get('update-attribute-value') ?? [])
                };
                edits.push(...handleXmlAttributeChanges(attributeChanges, element));
                break;
            }
            default:
                break;
        }
        return edits;
    }
    handleXmlElementChanges(elementChanges, element, pointer, childIndentLevel) {
        const edits = [];
        const { replacements, contentReplacements, elementDeletions, attributeInserts, moveInCollection } = elementChanges;
        if (elementDeletions.length > 0) {
            const parent = element.parent;
            const content = parent.type === 'XMLElement' ? this.getContent(parent) : [];
            edits.push(...handleXmlElementDeletions(parent, pointer, content, element));
        }
        else if (replacements.length > 0) {
            edits.push(...handleXmlElementReplacements(element, replacements, childIndentLevel));
        }
        else if (contentReplacements.length > 0) {
            edits.push(...handleXmlElementContentReplacements(element, contentReplacements, childIndentLevel));
        }
        else if (moveInCollection.length > 0) {
            for (const moveChange of moveInCollection) {
                const insertPosition = findInsertPositionForMove(moveChange.index, element, this.comments);
                if (!insertPosition) {
                    continue;
                }
                const { textEdits, text } = this.prepareXmlElementMoveChange(moveChange);
                edits.push(...textEdits);
                edits.push(...handleXmlElementMoveChange(element, childIndentLevel, text, insertPosition));
            }
        }
        else {
            edits.push(...handleXmlElementAttributeInserts(element, attributeInserts));
        }
        return edits;
    }
    prepareXmlElementMoveChange(moveChange) {
        const textEdits = [];
        const ranges = createElementRanges(this.document, moveChange.fromPointers);
        const text = [];
        for (const { parent, start, end } of ranges) {
            const content = this.getContent(parent);
            const range = getRangeForMove(content, parent, start, end);
            if (!range) {
                continue;
            }
            text.push(this.textDocument.getText(range));
            textEdits.push(odata_annotation_core_types_1.TextEdit.del(range));
        }
        return { textEdits, text };
    }
}
exports.XMLWriter = XMLWriter;
function handleXmlAttributeChanges(attributeChanges, element) {
    const edits = [];
    const { attributeDeletions, attributeNameUpdates, attributeValueUpdates } = attributeChanges;
    if (attributeDeletions.length > 0) {
        const attributeRange = (0, xml_odata_annotation_converter_1.transformRange)(element.position);
        if (attributeRange) {
            // There must be a space character before attribute and we should remove it with attribute.
            attributeRange.start.character--;
            edits.push(odata_annotation_core_types_1.TextEdit.del(attributeRange));
        }
    }
    else {
        // if attribute is deleted, then we can ignore updates
        const nameRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.key);
        if (nameRange && attributeNameUpdates.length > 0) {
            const newName = attributeNameUpdates[attributeNameUpdates.length - 1].newName;
            edits.push(odata_annotation_core_types_1.TextEdit.replace(nameRange, newName));
        }
        const valueRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.value);
        if (valueRange && attributeValueUpdates.length > 0) {
            const newValue = attributeValueUpdates[attributeValueUpdates.length - 1].newValue;
            // shift from start quote
            valueRange.start.character++;
            // shift from end quote
            valueRange.end.character--;
            edits.push(odata_annotation_core_types_1.TextEdit.replace(valueRange, newValue));
        }
    }
    return edits;
}
function handleXmlElementAttributeInserts(element, attributeInserts) {
    const openTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
    if (!openTagRange) {
        return [];
    }
    const edits = [];
    const byIndex = new Map();
    for (const change of attributeInserts) {
        let insertsAtIndex = byIndex.get(change.index);
        if (!insertsAtIndex) {
            insertsAtIndex = [];
            byIndex.set(change.index, insertsAtIndex);
        }
        insertsAtIndex.push(change);
    }
    for (const [key, inserts] of byIndex.entries()) {
        const attributes = [];
        const position = getAttributeInsertPosition(element, openTagRange, key);
        if (!position) {
            // TODO: report error
            continue;
        }
        for (const attributeInsert of inserts) {
            // insert before open tag
            attributes.push(`${attributeInsert.name}="${(0, xml_odata_annotation_converter_1.escapeAttribute)(attributeInsert.value)}"`);
        }
        if (attributes.length > 0) {
            const text = ` ${attributes.join(' ')}`;
            edits.push(odata_annotation_core_types_1.TextEdit.insert(position, text));
        }
    }
    return edits;
}
function getTextFragmentOffset(text) {
    const lines = text.split('\n');
    const linesWithTextIndices = lines.map((line, idx) => (line.length > 0 ? idx : -1));
    const indentTextIndex = linesWithTextIndices.find((idx) => idx > -1);
    if (indentTextIndex === undefined) {
        return 0;
    }
    const indentLineText = lines[indentTextIndex];
    return indentLineText.length - indentLineText.trimStart().length;
}
function adjustFragmentIndentation(text, requiredIndent) {
    const requiredOffset = requiredIndent * 4;
    const actual = getTextFragmentOffset(text);
    if (actual == requiredOffset) {
        return text;
    }
    const lines = text.split('\n');
    lines.forEach((line, idx) => {
        if (line.length) {
            if (actual < requiredOffset) {
                line = ' '.repeat(requiredOffset - actual) + line;
            }
            else if (line.startsWith(' '.repeat(actual - requiredOffset))) {
                line = line.substring(' '.repeat(actual - requiredOffset).length);
            }
            else {
                line = line.trim();
            }
            lines[idx] = line;
        }
    });
    return lines.join('\n');
}
function handleXmlElementMoveChange(element, childIndentLevel, text, insertPosition) {
    const edits = [];
    const openTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
    const textWithNewIndentation = adjustFragmentIndentation(text.join(''), childIndentLevel);
    if (element.syntax.isSelfClosing && openTagRange) {
        const indent = '    '.repeat(childIndentLevel - 1);
        edits.push(odata_annotation_core_types_1.TextEdit.replace(odata_annotation_core_types_1.Range.create(openTagRange.end.line, openTagRange.end.character - 2, openTagRange.end.line, openTagRange.end.character), `>${textWithNewIndentation}\n${indent}</${element.name}>`));
    }
    else {
        edits.push(odata_annotation_core_types_1.TextEdit.insert(insertPosition, textWithNewIndentation));
    }
    return edits;
}
function handleXmlElementContentReplacements(element, contentReplacements, childIndentLevel) {
    const edits = [];
    const openTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
    const closeTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.closeBody);
    const lastChange = contentReplacements.slice(-1)[0];
    const namespaceMap = getNamespaceMap(element);
    const text = replaceElementContentToText(lastChange, childIndentLevel - 1, namespaceMap);
    if (element.syntax.isSelfClosing && openTagRange) {
        edits.push(odata_annotation_core_types_1.TextEdit.replace(odata_annotation_core_types_1.Range.create(openTagRange.end.line, openTagRange.end.character - 2, openTagRange.end.line, openTagRange.end.character), `>${text}</${element.name}>`));
    }
    else if (openTagRange && closeTagRange) {
        edits.push(odata_annotation_core_types_1.TextEdit.replace(odata_annotation_core_types_1.Range.create(openTagRange.end, closeTagRange.start), text));
    }
    return edits;
}
function handleXmlElementReplacements(element, replacements, childIndentLevel) {
    const edits = [];
    const openTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
    const closeTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.closeBody);
    const lastChange = replacements.slice(-1)[0];
    const namespaceMap = getNamespaceMap(element);
    const text = replaceElementToText(lastChange, childIndentLevel - 1, namespaceMap);
    if (element.syntax.isSelfClosing && openTagRange) {
        edits.push(odata_annotation_core_types_1.TextEdit.replace(openTagRange, text));
    }
    else if (openTagRange && closeTagRange) {
        edits.push(odata_annotation_core_types_1.TextEdit.replace(odata_annotation_core_types_1.Range.create(openTagRange.start, closeTagRange.end), text));
    }
    return edits;
}
function handleXmlElementDeletions(parent, pointer, content, element) {
    const edits = [];
    const openTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
    if (parent.type === 'XMLElement') {
        const index = parseInt(pointer.split('/').slice(-1)[0], 10);
        const { previousContentIndex, startContentIndex } = findContentIndices(index, index, content);
        const anchor = getStartAnchor(content, parent, previousContentIndex, startContentIndex);
        if (anchor) {
            const previousElement = content[previousContentIndex];
            const nextElement = content.find((item, i) => item.type === 'element' && i > startContentIndex);
            const parentCloseTagRange = (0, xml_odata_annotation_converter_1.transformRange)(parent.syntax.closeBody);
            if (!nextElement && !previousElement && parentCloseTagRange) {
                updatePosition(anchor.end, parentCloseTagRange.start);
            }
            edits.push(odata_annotation_core_types_1.TextEdit.del(anchor));
        }
    }
    else if (element.syntax.isSelfClosing && openTagRange) {
        // empty root element
        edits.push(odata_annotation_core_types_1.TextEdit.del(openTagRange));
    }
    else {
        // root element with content
        const closeTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.closeBody);
        if (openTagRange && closeTagRange) {
            edits.push(odata_annotation_core_types_1.TextEdit.del(odata_annotation_core_types_1.Range.create(openTagRange.start, closeTagRange.end)));
        }
    }
    return edits;
}
function convertUpdateElementNameToTextEdits(elementNameUpdates, element) {
    const edits = [];
    if (elementNameUpdates.length > 0 && element?.type === 'XMLElement') {
        const newName = elementNameUpdates[elementNameUpdates.length - 1].newName;
        const openTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
        const closeTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.closeBody);
        if (openTagRange) {
            const nameLength = element.name?.length ?? 0;
            openTagRange.start.character++; // <
            openTagRange.end.character = openTagRange.start.character + nameLength;
            edits.push(odata_annotation_core_types_1.TextEdit.replace(openTagRange, newName));
            if (closeTagRange) {
                closeTagRange.start.character += 2; // </
                closeTagRange.end.character--; // >
                edits.push(odata_annotation_core_types_1.TextEdit.replace(closeTagRange, newName));
            }
        }
    }
    return edits;
}
function getBatches(changes) {
    const batches = {};
    for (const change of changes) {
        let byTypeMap = batches[change.pointer];
        if (!byTypeMap) {
            byTypeMap = new Map();
            batches[change.pointer] = byTypeMap;
        }
        let batch = byTypeMap.get(change.type);
        if (!batch) {
            batch = [];
            byTypeMap.set(change.type, batch);
        }
        batch.push(change);
    }
    return batches;
}
function getAttributeInsertPosition(element, openTagRange, index) {
    if (index === undefined) {
        // /> or >
        const characterOffset = element.syntax.isSelfClosing === true ? 2 : 1;
        return odata_annotation_core_types_1.Position.create(openTagRange.end.line, openTagRange.end.character - characterOffset);
    }
    const attribute = element.attributes[index];
    if (!attribute) {
        return undefined;
    }
    const range = (0, xml_odata_annotation_converter_1.transformRange)(attribute.position);
    if (!range) {
        return undefined;
    }
    // There must be a space character before attribute and the insert position should be before it
    return odata_annotation_core_types_1.Position.create(range.start.line, range.start.character - 1);
}
function convertInsertElementToTextEdits(comments, element, changes, childIndentLevel) {
    if (!(element === undefined || element.type === 'XMLElement')) {
        return [];
    }
    if (changes.length === 0) {
        return [];
    }
    if (!element) {
        const change = changes.slice(-1)[0];
        const namespaceMap = getNamespaceMapForNewRootNode(change.element);
        const newElements = insertElementToText([change], childIndentLevel, namespaceMap);
        return [odata_annotation_core_types_1.TextEdit.insert(odata_annotation_core_types_1.Position.create(0, 0), newElements)];
    }
    else {
        const namespaceMap = getNamespaceMap(element);
        const openTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
        if (element.syntax.isSelfClosing && openTagRange) {
            const newElements = insertElementToText(changes, childIndentLevel, namespaceMap);
            const fragments = ['>', '\n', newElements];
            fragments.push('\n');
            const indentLevel = childIndentLevel > 0 ? childIndentLevel - 1 : 0;
            const indent = '    '.repeat(indentLevel);
            fragments.push(`${indent}</${element.name}>`);
            return [
                odata_annotation_core_types_1.TextEdit.replace(odata_annotation_core_types_1.Range.create(openTagRange.end.line, openTagRange.end.character - 2, openTagRange.end.line, openTagRange.end.character), fragments.join(''))
            ];
        }
        else {
            return insertIntoElementWithContent(comments, element, changes, childIndentLevel, namespaceMap);
        }
    }
}
function insertIntoElementWithContent(comments, element, changes, childIndentLevel, namespaceMap) {
    const edits = [];
    const [indices, changesByIndex] = indexInserts(changes);
    for (const index of indices) {
        const changeSet = changesByIndex.get(index);
        if (!changeSet) {
            continue;
        }
        const anchor = findInsertPosition(comments, element, index ?? -1);
        if (anchor.type === 'none') {
            continue;
        }
        const fragments = [];
        if (element.syntax.openBody?.endLine === element.syntax.closeBody?.startLine && !anchor.requiresNewLine) {
            fragments.push('\n');
        }
        const newElements = insertElementToText(changeSet, childIndentLevel, namespaceMap) + '\n';
        if (anchor.requiresNewLine) {
            fragments.push('\n');
        }
        fragments.push(newElements);
        if (!anchor.requiresNewLine) {
            edits.push(odata_annotation_core_types_1.TextEdit.insert(anchor.position, fragments.join('')));
            continue;
        }
        const childIndent = (0, odata_annotation_core_1.indent)(printOptions.tabWidth, printOptions.useTabs, childIndentLevel);
        fragments.push(childIndent);
        if (anchor.redundantWhitespace) {
            edits.push(odata_annotation_core_types_1.TextEdit.del(anchor.redundantWhitespace));
        }
        edits.push(odata_annotation_core_types_1.TextEdit.insert(anchor.position, fragments.join('')));
    }
    return edits;
}
function indexInserts(changes) {
    const changesByIndex = new Map();
    const indices = [];
    for (const change of changes) {
        let changeSet = changesByIndex.get(change.index);
        if (!changeSet) {
            changeSet = [];
            indices.push(change.index);
            changesByIndex.set(change.index, changeSet);
        }
        changeSet.push(change);
    }
    return [indices, changesByIndex];
}
function insertElementToText(inserts, childIndentLevel, namespaceMap) {
    return inserts
        .map((change) => (0, xml_odata_annotation_converter_1.printCsdlNodeToXmlString)((0, odata_annotation_core_types_1.createElementNode)(change.element), printOptions, {
        namespaces: namespaceMap,
        cursorIndentLevel: childIndentLevel
    }))
        .join('\n');
}
function replaceElementToText(change, childIndentLevel, namespaceMap) {
    return (0, xml_odata_annotation_converter_1.printCsdlNodeToXmlString)((0, odata_annotation_core_types_1.createElementNode)(change.newElement), printOptions, {
        namespaces: namespaceMap,
        cursorIndentLevel: childIndentLevel
    }).trim();
}
function replaceElementContentToText(change, childIndentLevel, namespaceMap) {
    return (0, xml_odata_annotation_converter_1.printCsdlNodeToXmlString)(change.newValue, printOptions, {
        namespaces: namespaceMap,
        cursorIndentLevel: childIndentLevel
    }).trim();
}
function findInsertPosition(comments, element, index = -1) {
    const child = index !== -1 ? element.subElements[index] : undefined;
    if (child) {
        const childRange = sourcePositionToRange(child.position);
        // keep associated comments with element together
        const comment = findComment(comments, childRange);
        const startAnchorRange = findStartAnchorRange(element, index);
        if (!startAnchorRange) {
            return { type: 'none' };
        }
        const anchorPosition = comment ? comment.range.start : childRange.start;
        const requiresNewLine = anchorPosition.line === startAnchorRange.end.line;
        // If we are not on the same line as the starting anchor,
        // then it means there should be only whitespace until the start of the line
        // and we can insert the snippet there
        const position = requiresNewLine ? anchorPosition : odata_annotation_core_types_1.Position.create(anchorPosition.line, 0);
        const redundantWhitespace = requiresNewLine ? odata_annotation_core_types_1.Range.create(startAnchorRange.end, anchorPosition) : undefined;
        return { type: 'child', position, requiresNewLine, redundantWhitespace };
    }
    const closeTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.closeBody);
    const startAnchorRange = findStartAnchorRange(element, element.subElements.length);
    if (closeTagRange && startAnchorRange) {
        const anchorPosition = closeTagRange.start;
        const requiresNewLine = anchorPosition.line === startAnchorRange.end.line;
        const position = requiresNewLine ? anchorPosition : odata_annotation_core_types_1.Position.create(anchorPosition.line, 0);
        return { type: 'parent', position, requiresNewLine: false };
    }
    return { type: 'none' };
}
/**
 * Finds a closest boundary structure before the given element and returns its range.
 * It could be either another sibling element or an opening tag of a parent.
 *
 * @param parent - Parent element.
 * @param index - Current element index.
 * @returns Anchor range.
 */
function findStartAnchorRange(parent, index) {
    const previousElement = parent.subElements[index - 1];
    if (index === 0) {
        return (0, xml_odata_annotation_converter_1.transformRange)(parent.syntax.openBody);
    }
    if (previousElement) {
        return sourcePositionToRange(previousElement.position);
    }
    return undefined;
}
/**
 * Find comment that is associated with the range.
 * We consider comments right before an element to be associated.
 *
 * @param comments - Documents comments.
 * @param range - Range to which the comment should be associated to.
 * @returns Comment if it exists.
 */
function findComment(comments, range) {
    const previousLine = range.start.line - 1;
    for (const comment of comments) {
        if (comment.range.end.line === previousLine || comment.range.start.line === range.end.line) {
            return comment;
        }
    }
    return undefined;
}
function sourcePositionToRange(position) {
    return odata_annotation_core_types_1.Range.create(position.startLine - 1, position.startColumn - 1, position.endLine - 1, position.endColumn);
}
function getIndentFromElement(element) {
    if (element?.type === 'XMLElement') {
        const openTagRange = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
        if (openTagRange) {
            return (0, odata_annotation_core_1.getIndentLevel)(openTagRange.start.character, printOptions.tabWidth) + 1;
        }
    }
    return 0;
}
function createElementRanges(document, pointers) {
    const ranges = [];
    const groups = pointers.reduce((acc, pointer) => {
        const segments = pointer.split('/');
        // remove /subElements/<index> suffix
        const containerPath = segments.slice(0, -2).join('/');
        const index = parseInt(segments.slice(-1)[0], 10);
        const list = acc.get(containerPath);
        if (list) {
            list.push(index);
        }
        else {
            acc.set(containerPath, [index]);
        }
        return acc;
    }, new Map());
    for (const [containerPath, indices] of groups) {
        const parent = (0, pointer_1.getNodeFromPointer)(document, containerPath);
        if (parent?.type === 'XMLElement') {
            indices.sort((index1, index2) => index1 - index2);
            for (let i = 1, start = indices[0], end = indices[0]; i <= indices.length; i++) {
                const current = indices[i];
                if (current === undefined) {
                    // end of collection
                    ranges.push({ parent, start, end });
                }
                else if (end + 1 === current) {
                    // indices are in sequence -> merge
                    end = current;
                }
                else {
                    // there is a gap between indices -> create a range
                    ranges.push({ parent, start, end });
                    start = end = current;
                }
            }
        }
    }
    return ranges;
}
function getElementContent(element, comments) {
    const range = (0, xml_odata_annotation_converter_1.transformRange)(element.position);
    if (!range) {
        return [];
    }
    const commentsInContent = comments.filter((comment) => isCommentInContent(range, comment, element));
    const source = [...element.subElements, ...commentsInContent].sort(compareRange);
    const content = [];
    for (let i = 0; i < source.length; i++) {
        const item = source[i];
        if (item.type !== 'XMLElement') {
            content.push(item);
            continue;
        }
        const range = (0, xml_odata_annotation_converter_1.transformRange)(item.position);
        if (!range) {
            continue;
        }
        const element = {
            type: 'element',
            element: item,
            elementRange: range,
            range: (0, cds_annotation_parser_1.copyRange)(range)
        };
        const previousItem = content[content.length - 1];
        const previousLine = element.range.start.line - 1;
        if (previousItem?.type === 'comment' &&
            (previousItem.range.end.line === previousLine || previousItem.range.end.line === element.range.start.line)) {
            // typescript can't infer that content.pop() === previousItem
            element.leadingComment = content.pop();
            updatePosition(element.range.start, previousItem.range.start);
        }
        const nextItem = source[i + 1];
        if (nextItem?.type === 'comment' && nextItem.range.start.line === range.end.line) {
            element.trailingComment = nextItem;
            updatePosition(element.range.end, nextItem.range.end);
            i++;
        }
        content.push(element);
    }
    return content;
}
function isCommentInContent(range, comment, element) {
    return ((0, odata_annotation_core_1.rangeContained)(range, comment.range) &&
        !element.subElements.some((item) => {
            const subElementRange = (0, xml_odata_annotation_converter_1.transformRange)(item.position);
            if (!subElementRange) {
                return false;
            }
            return (0, odata_annotation_core_1.rangeContained)(subElementRange, comment.range);
        }));
}
function compareRange(a, b) {
    const aRange = a.range ?? (0, xml_odata_annotation_converter_1.transformRange)(a.syntax?.closeBody ?? a.syntax?.openBody);
    const bRange = b.range ?? (0, xml_odata_annotation_converter_1.transformRange)(b.syntax?.closeBody ?? b.syntax?.openBody);
    if (!aRange) {
        return 1;
    }
    if (!bRange) {
        return -1;
    }
    if ((0, odata_annotation_core_1.isBefore)(aRange.start, bRange.start)) {
        return -1;
    }
    else if ((0, odata_annotation_core_1.isBefore)(bRange.start, aRange.start)) {
        return 1;
    }
    return 0;
}
function findContentIndices(start, end, content) {
    let previousContentIndex = -1;
    let startContentIndex = -1;
    let endContentIndex = -1;
    for (let index = 0, contentIndex = 0; index < content.length; index++) {
        const element = content[index];
        if (element.type === 'element') {
            if (start - 1 === contentIndex) {
                previousContentIndex = index;
            }
            if (start === contentIndex) {
                startContentIndex = index;
            }
            if (end === contentIndex) {
                endContentIndex = index;
                break;
            }
            contentIndex++;
        }
    }
    return {
        previousContentIndex,
        startContentIndex,
        endContentIndex
    };
}
function getRangeForMove(content, parent, start, end) {
    const { previousContentIndex, startContentIndex, endContentIndex } = findContentIndices(start, end, content);
    const endElement = content[endContentIndex];
    let startPosition = getStartAnchor(content, parent, previousContentIndex, startContentIndex)?.start;
    let endPosition = endElement?.range?.end;
    if (startPosition) {
        startPosition = (0, cds_annotation_parser_1.copyPosition)(startPosition);
    }
    if (endPosition) {
        endPosition = (0, cds_annotation_parser_1.copyPosition)(endPosition);
    }
    if (!startPosition || !endElement) {
        return undefined;
    }
    return odata_annotation_core_types_1.Range.create(startPosition, endPosition);
}
function getStartAnchor(content, parent, previous, index) {
    const previousElement = content[previous];
    let startPosition = index === 0 ? (0, xml_odata_annotation_converter_1.transformRange)(parent.syntax.openBody)?.end : previousElement?.range?.end;
    const item = content[index];
    if (startPosition) {
        startPosition = (0, cds_annotation_parser_1.copyPosition)(startPosition);
    }
    if (!startPosition || !item) {
        return undefined;
    }
    const previousItem = content[index - 1];
    if (previousItem?.type === 'comment') {
        // multiple comments between previous item and starting item -> ignore them
        updatePosition(startPosition, previousItem.range.end);
    }
    return odata_annotation_core_types_1.Range.create(startPosition, (0, cds_annotation_parser_1.copyPosition)(item.range.end));
}
function updatePosition(a, b) {
    a.line = b.line;
    a.character = b.character;
}
function adjustRangeByComments(comments, range) {
    if (!range) {
        return;
    }
    // find inline comment after planned insert position
    const inlineComments = comments.filter((comment) => comment.range.start.line === range.end.line && comment.range.start.character > range.end.character);
    // search the right most inline comment, its end position should be the insertion position
    if (inlineComments.length) {
        let pos = range.end;
        for (const comment of inlineComments) {
            if (comment.range.start.character > pos.character) {
                pos = comment.range.end;
            }
        }
        range.end = pos;
    }
}
function findInsertPositionForMove(index, element, comments) {
    if (index === 0) {
        const range = (0, xml_odata_annotation_converter_1.transformRange)(element.syntax.openBody);
        return range?.end;
    }
    else if (index === undefined || index >= element.subElements.length) {
        const child = element.subElements[element.subElements.length - 1];
        if (!child) {
            return undefined;
        }
        // self closed elements only have "openBody"
        const range = (0, xml_odata_annotation_converter_1.transformRange)(child.syntax.closeBody ?? child.syntax.openBody);
        adjustRangeByComments(comments, range);
        return range?.end;
    }
    else if (index > 0) {
        const child = element.subElements[index - 1];
        // end of the previous element
        // self closed elements only have "openBody"
        const range = (0, xml_odata_annotation_converter_1.transformRange)(child.syntax.closeBody ?? child.syntax.openBody);
        adjustRangeByComments(comments, range);
        return range?.end;
    }
    return undefined;
}
function getNamespaceMap(parent) {
    const map = {};
    for (const alias of Object.keys(parent.namespaces)) {
        if (alias === ast_1.DEFAULT_NS) {
            continue;
        }
        const namespace = parent.namespaces[alias];
        if (namespace === xml_odata_annotation_converter_1.EDMX_V4_NAMESPACE) {
            map[odata_annotation_core_types_1.EDMX_NAMESPACE_ALIAS] = alias;
        }
        else if (namespace === xml_odata_annotation_converter_1.EDM_V4_NAMESPACE) {
            map[odata_annotation_core_types_1.EDM_NAMESPACE_ALIAS] = alias;
        }
    }
    return map;
}
function getNamespaceMapForNewRootNode(element) {
    const map = {};
    for (const attributeName of Object.keys(element.attributes)) {
        if (!attributeName.startsWith('xmlns')) {
            continue;
        }
        const { name, value: namespace } = element.attributes[attributeName];
        const [, alias] = name.split(':');
        if (alias === undefined) {
            continue;
        }
        if (namespace === xml_odata_annotation_converter_1.EDMX_V4_NAMESPACE) {
            map[odata_annotation_core_types_1.EDMX_NAMESPACE_ALIAS] = alias;
        }
        else if (namespace === xml_odata_annotation_converter_1.EDM_V4_NAMESPACE) {
            map[odata_annotation_core_types_1.EDM_NAMESPACE_ALIAS] = alias;
        }
    }
    return map;
}
function preprocessChanges(changes, document) {
    let result = removeDuplicates(changes);
    result = removeOverlappingDeletes(result);
    result = combineInsertsWithDeletions(result, document);
    return result;
}
function combineInsertsWithDeletions(changes, document) {
    const result = [];
    const deletions = new Set();
    const replacements = new Map();
    // Inserts are usually merged together, so we need to replace the last insert of the batch for the same index
    for (let i = changes.length - 1; i >= 0; i--) {
        const change = changes[i];
        if (change.type !== 'insert-element') {
            continue;
        }
        // merge inserts and deletions
        const element = (0, pointer_1.getNodeFromPointer)(document, change.pointer);
        if (element?.type !== 'XMLElement') {
            continue;
        }
        const index = change.index ?? element.subElements.length - 1;
        const pointer = `${change.pointer}/subElements/${index}`;
        const deletionChangeIndex = changes.findIndex((c) => c.pointer === pointer && c.type === 'delete-element');
        if (deletionChangeIndex !== -1 && !replacements.has(deletionChangeIndex)) {
            replacements.set(deletionChangeIndex, {
                type: 'replace-element',
                pointer,
                newElement: change.element
            });
            deletions.add(i);
        }
    }
    for (let i = 0; i < changes.length; i++) {
        const change = changes[i];
        const replacement = replacements.get(i);
        if (replacement) {
            result.push(replacement);
        }
        else if (!deletions.has(i)) {
            result.push(change);
        }
    }
    return result;
}
function removeDuplicates(changes) {
    const existingDeletions = [];
    const result = [];
    for (const change of changes) {
        if (change.type === 'delete-element') {
            if (existingDeletions.indexOf(change.pointer) === -1) {
                existingDeletions.push(change.pointer);
                result.push(change);
            }
        }
        else {
            result.push(change);
        }
    }
    return result;
}
function removeOverlappingDeletes(changes) {
    const result = [];
    const deletions = new Set();
    for (const change of changes) {
        if (change.type === 'delete-element') {
            const pointerLength = change.pointer.split('/').length;
            for (let j = 0; j < changes.length; j++) {
                const otherChange = changes[j];
                const otherPointerLength = otherChange.pointer.split('/').length;
                if ((otherChange.type === 'delete-element' || otherChange.type === 'delete-attribute') &&
                    otherChange.pointer.startsWith(change.pointer) &&
                    otherChange.pointer !== change.pointer &&
                    // startsWith can match siblings because indices are converted to string and compared as strings
                    // we need to avoid .../subElements/1 matching to .../subElements/10
                    otherPointerLength !== pointerLength) {
                    deletions.add(j);
                }
            }
        }
    }
    for (let i = 0; i < changes.length; i++) {
        const change = changes[i];
        if (!deletions.has(i)) {
            result.push(change);
        }
    }
    return result;
}
//# sourceMappingURL=writer.js.map