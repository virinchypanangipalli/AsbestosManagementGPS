"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XMLAnnotationServiceAdapter = void 0;
const ast_1 = require("@xml-tools/ast");
const parser_1 = require("@xml-tools/parser");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const xml_odata_annotation_converter_1 = require("@sap-ux/xml-odata-annotation-converter");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const odata_entity_model_1 = require("@sap-ux/odata-entity-model");
const types_1 = require("../types");
const error_1 = require("../error");
const writer_1 = require("./writer");
const changes_1 = require("./changes");
const references_1 = require("./references");
const comments_1 = require("./comments");
const pointer_1 = require("./pointer");
/**
 *
 */
class XMLAnnotationServiceAdapter {
    service;
    vocabularyService;
    project;
    appName;
    metadataService = new odata_entity_model_1.MetadataService();
    splitAnnotationSupport = false;
    fileCache;
    documents = new Map();
    metadata = [];
    setFileCache(fileCache) {
        this.fileCache = fileCache;
    }
    _compiledService;
    /**
     *
     * @returns Compiled XML service.
     */
    get compiledService() {
        if (!this._compiledService) {
            this._compiledService = this._getCompiledService();
        }
        return this._compiledService;
    }
    set compiledService(v) {
        this._compiledService = v;
    }
    /**
     *
     * @param service - Service structure.
     * @param vocabularyService - Vocabulary API.
     * @param project - Project structure.
     * @param appName - Name of the application.
     */
    constructor(service, vocabularyService, project, appName) {
        this.service = service;
        this.vocabularyService = vocabularyService;
        this.project = project;
        this.appName = appName;
        this.fileCache = new Map();
    }
    /**
     * Refreshes internal data structures from the provided project files.
     *
     * @param fileCache - File uri mapped to file content.
     */
    sync(fileCache) {
        this.documents.clear();
        this._compiledService = undefined;
        this.setFileCache(fileCache);
        const { ast: metadataDocument, comments: metadataComments } = parseFile(fileCache, this.service.metadataFile);
        this.documents.set(this.service.metadataFile.uri, {
            uri: this.service.metadataFile.uri,
            comments: metadataComments,
            ast: metadataDocument,
            annotationFile: (0, xml_odata_annotation_converter_1.convertDocument)(this.service.metadataFile.uri, metadataDocument),
            usedNamespaces: new Set()
        });
        for (const file of this.service.annotationFiles) {
            const { ast, comments } = parseFile(fileCache, file, false);
            const annotationFile = (0, xml_odata_annotation_converter_1.convertDocument)(file.uri, ast);
            const usedNamespaces = new Set();
            (0, references_1.collectUsedNamespaces)(annotationFile, usedNamespaces);
            this.documents.set(file.uri, {
                uri: file.uri,
                comments,
                ast,
                annotationFile,
                usedNamespaces
            });
        }
        this.metadata = (0, xml_odata_annotation_converter_1.convertMetadataDocument)(this.service.metadataFile.uri, metadataDocument);
        this.metadataService = new odata_entity_model_1.MetadataService({
            ODataVersion: this.service.odataVersion,
            isCds: false
        });
        this.metadataService.import(this.metadata, this.service.metadataFile.uri);
    }
    /**
     * Returns all relevant service files.
     *
     * @returns All relevant service files.
     */
    getAllFiles() {
        return [this.service.metadataFile, ...this.service.annotationFiles];
    }
    /**
     * Creates empty annotation file content for the given service.
     *
     * @param serviceName - Name of the service.
     * @param uri - URI for the new annotation file.
     * @returns New annotation file content.
     */
    getInitialFileContent(serviceName, uri) {
        const appName = this.appName || Object.keys(this.project.apps)[0];
        const metadataURI = `${this.project.apps[appName].services[serviceName].uri}$metadata`;
        const metadataNamespace = [...this.metadataService.getNamespaces()][0];
        const aliasInfo = getAliasInfo({
            references: [
                {
                    name: metadataNamespace,
                    uri: metadataURI,
                    type: 'reference',
                    alias: 'Metadata'
                }
            ],
            targets: [],
            type: 'annotation-file',
            uri,
            namespace: {
                name: this.getUniqueNamespace(metadataNamespace),
                type: 'namespace'
            }
        }, this.metadataService);
        const vocabularies = this.vocabularyService.getVocabularies();
        return (0, xml_odata_annotation_converter_1.getNewAnnotationFile)(aliasInfo, metadataURI, vocabularies).fileContent;
    }
    /**
     * Converts changes to workspace edits.
     *
     * @param changes - Internal changes.
     * @returns Workspace edits.
     */
    async getWorkspaceEdit(changes) {
        const workspaceChanges = {};
        const writers = new Map();
        const targetChildReferencesByUri = {};
        for (const change of changes) {
            let writer = writers.get(change.uri);
            const document = this.documents.get(change.uri);
            const targetChildReferences = (targetChildReferencesByUri[change.uri] ??= new Map());
            if (!document) {
                continue;
            }
            if (!writer) {
                const textDocument = vscode_languageserver_textdocument_1.TextDocument.create(change.uri, 'cds', 0, this.fileCache?.get(change.uri) ?? '');
                writer = new writer_1.XMLWriter(document.ast, document.comments, textDocument);
                writers.set(change.uri, writer);
            }
            this.processChange(document, writer, targetChildReferences, change);
        }
        for (const [uri, writer] of writers.entries()) {
            const targetChildReferences = (targetChildReferencesByUri[uri] ??= new Map());
            for (const [targetPointer, childPointers] of targetChildReferences.entries()) {
                if (childPointers.size === 0) {
                    writer.addChange({
                        type: 'delete-element',
                        pointer: targetPointer
                    });
                }
            }
            let edits = writer.getTextEdits();
            const newEdits = this.postprocessEdits(uri, writer, edits);
            if (newEdits.length) {
                edits = newEdits;
            }
            workspaceChanges[uri] = edits;
        }
        return Promise.resolve({ changes: workspaceChanges });
    }
    /**
     * No checking is done for XML files.
     *
     * @param fileCache - Updated file content.
     * @returns Nothing.
     */
    validateChanges(fileCache) {
        return this.sync(fileCache);
    }
    /**
     * Converts annotation object to a string.
     *
     * @param target - Content of an 'Annotations' element.
     * @returns XML representation of the annotations.
     */
    serializeTarget(target) {
        return (0, xml_odata_annotation_converter_1.serializeTarget)(target);
    }
    getUniqueNamespace(metadataNamespace) {
        const namespaces = new Set();
        this.documents.forEach((document) => {
            const namespace = document.annotationFile.namespace;
            if (namespace) {
                namespaces.add(namespace.name);
            }
        });
        let newNamespace = `${metadataNamespace}.annotations`;
        let index = 0;
        while ([...namespaces].includes(newNamespace)) {
            ++index;
            newNamespace = `${newNamespace}${index}`;
            if (![...namespaces].includes(newNamespace)) {
                break;
            }
        }
        return newNamespace;
    }
    _getCompiledService() {
        const files = [this.service.metadataFile, ...this.service.annotationFiles];
        const annotationFiles = [];
        for (const file of files) {
            const document = this.documents.get(file.uri);
            if (document) {
                annotationFiles.push(document.annotationFile);
            }
            else {
                throw new error_1.ApiError(`Could not compile service. Missing document ${file.uri}`, error_1.ApiErrorCode.General);
            }
        }
        return Object.freeze({
            odataVersion: this.service.odataVersion,
            annotationFiles,
            metadata: this.metadata
        });
    }
    processChange(document, writer, targetChildReferences, change) {
        switch (change.type) {
            case types_1.INSERT_TARGET: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.target}`);
                const element = (0, odata_annotation_core_types_1.createElementNode)({
                    name: 'Annotations',
                    attributes: {
                        Target: (0, odata_annotation_core_types_1.createAttributeNode)('Target', change.target.name)
                    },
                    content: change.target.terms
                });
                writer.addChange({
                    type: types_1.INSERT_ELEMENT,
                    pointer: pointer,
                    element
                });
                break;
            }
            case types_1.INSERT_ELEMENT: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.pointer} ${change.element.name}`);
                const fullPointer = pointer + convertPointer(document.annotationFile, change.pointer);
                const element = (0, pointer_1.getNodeFromPointer)(document.ast, fullPointer);
                if (element?.type === 'XMLElement' && element.name === "Annotations" /* Edm.Annotations */) {
                    this.markElementInsertion(targetChildReferences, fullPointer, element);
                }
                writer.addChange({
                    type: types_1.INSERT_ELEMENT,
                    pointer: pointer + convertPointer(document.annotationFile, change.pointer),
                    element: change.element,
                    index: change.index
                });
                break;
            }
            case types_1.DELETE_ELEMENT: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.pointer} `);
                const fullPointer = pointer + convertPointer(document.annotationFile, change.pointer);
                const element = (0, pointer_1.getNodeFromPointer)(document.ast, fullPointer);
                if (element?.type === 'XMLElement' &&
                    element.name === "Annotation" /* Edm.Annotation */ &&
                    element.parent?.type === 'XMLElement' &&
                    element.parent.name === "Annotations" /* Edm.Annotations */) {
                    this.markElementDeletion(targetChildReferences, fullPointer, element.parent);
                }
                writer.addChange({
                    type: 'delete-element',
                    pointer: fullPointer
                });
                break;
            }
            case types_1.DELETE_ATTRIBUTE: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.pointer} `);
                writer.addChange({
                    type: 'delete-attribute',
                    pointer: pointer + convertPointer(document.annotationFile, change.pointer)
                });
                break;
            }
            case types_1.UPDATE_ATTRIBUTE_VALUE: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.pointer} `);
                writer.addChange({
                    type: types_1.UPDATE_ATTRIBUTE_VALUE,
                    pointer: pointer + convertPointer(document.annotationFile, change.pointer),
                    newValue: change.newValue
                });
                break;
            }
            case types_1.REPLACE_ATTRIBUTE: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.pointer} `);
                writer.addChange({
                    type: 'update-attribute-name',
                    pointer: pointer + convertPointer(document.annotationFile, change.pointer),
                    newName: change.newAttributeName
                });
                writer.addChange({
                    type: types_1.UPDATE_ATTRIBUTE_VALUE,
                    pointer: pointer + convertPointer(document.annotationFile, change.pointer),
                    newValue: change.newAttributeValue
                });
                break;
            }
            case types_1.REPLACE_ELEMENT: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.pointer} `);
                writer.addChange({
                    type: 'replace-element',
                    pointer: pointer + convertPointer(document.annotationFile, change.pointer),
                    newElement: change.newElement
                });
                break;
            }
            case changes_1.REPLACE_ELEMENT_CONTENT: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.pointer} `);
                writer.addChange({
                    type: changes_1.REPLACE_ELEMENT_CONTENT,
                    pointer: pointer + convertPointer(document.annotationFile, change.pointer),
                    newValue: change.newValue
                });
                break;
            }
            case types_1.INSERT_ATTRIBUTE: {
                const pointer = getSchemaPointer(document.ast);
                throwIf(!pointer, `Could not process change ${change.type} ${change.uri} ${change.pointer} ${change.name}`);
                writer.addChange({
                    type: 'insert-attribute',
                    pointer: pointer + convertPointer(document.annotationFile, change.pointer),
                    name: change.name,
                    value: change.value
                });
                break;
            }
            case types_1.MOVE_ELEMENT: {
                const schemaPointer = getSchemaPointer(document.ast);
                if (schemaPointer) {
                    const pointer = schemaPointer + convertPointer(document.annotationFile, change.pointer);
                    writer.addChange({
                        type: 'move-collection-value',
                        pointer,
                        index: change.index,
                        fromPointers: change.fromPointers.map((fromPointer) => schemaPointer + convertPointer(document.annotationFile, fromPointer))
                    });
                }
                break;
            }
            case types_1.REPLACE_TEXT:
                {
                    const schemaPointer = getSchemaPointer(document.ast);
                    if (schemaPointer) {
                        const pointer = schemaPointer + convertPointer(document.annotationFile, change.pointer);
                        writer.addChange({
                            type: changes_1.REPLACE_ELEMENT_CONTENT,
                            // ends with textContents/<index>/text we need to get the parent element
                            pointer: pointer.split('/').slice(0, -3).join('/'),
                            newValue: [change.text]
                        });
                    }
                }
                break;
            default:
                break;
        }
    }
    getTargetChildReferences(targetChildReferences, parentPointer, element) {
        const result = targetChildReferences.get(parentPointer);
        if (result) {
            return result;
        }
        const pointerSet = new Set();
        for (let index = 0; index < element.subElements.length; index++) {
            const child = element.subElements[index];
            if (child.type === 'XMLElement') {
                pointerSet.add(`${parentPointer}/subElements/${index}`);
            }
        }
        targetChildReferences.set(parentPointer, pointerSet);
        return pointerSet;
    }
    markElementDeletion(targetChildReferences, fullPointer, element) {
        const parentPointer = fullPointer.split('/').slice(0, -2).join('/');
        const annotationReferences = this.getTargetChildReferences(targetChildReferences, parentPointer, element);
        annotationReferences.delete(fullPointer);
    }
    markElementInsertion(targetChildReferences, fullPointer, element) {
        const annotationReferences = this.getTargetChildReferences(targetChildReferences, fullPointer, element);
        annotationReferences.add(`${fullPointer}/subElements/-1`);
    }
    postprocessEdits(uri, writer, edits) {
        const file = this.fileCache.get(uri);
        const document = this.documents.get(uri);
        if (!file || !document) {
            return [];
        }
        const newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(vscode_languageserver_textdocument_1.TextDocument.create(uri, '', 0, file), edits);
        const { cst, tokenVector } = (0, parser_1.parse)(newText);
        const ast = (0, ast_1.buildAst)(cst, tokenVector);
        const referencesChanged = this.updateReferences(uri, writer, ast);
        if (referencesChanged) {
            return writer.getTextEdits();
        }
        return [];
    }
    updateReferences(uri, writer, ast) {
        const document = this.documents.get(uri);
        if (!document) {
            return false;
        }
        const annotationFile = (0, xml_odata_annotation_converter_1.convertDocument)(uri, ast);
        const usedNames = new Set();
        (0, references_1.collectUsedNamespaces)(annotationFile, usedNames);
        const allNamespaces = (0, odata_annotation_core_1.getAllNamespacesAndReferences)(annotationFile.namespace, annotationFile.references);
        const aliasInfo = (0, odata_annotation_core_1.getAliasInformation)(allNamespaces, this.metadataService.getNamespaces());
        const pointer = getEdmxPointer(document.ast);
        throwIf(!pointer, `No root EDMX element found in ${uri}`);
        const deletions = this.removeReferences(writer, document, aliasInfo, usedNames, pointer);
        const inserts = this.addReferences(writer, document, aliasInfo, usedNames, pointer);
        return deletions || inserts;
    }
    removeReferences(writer, document, aliasInfo, usedNames, pointer) {
        const toRemove = new Set();
        for (const name of Object.keys(aliasInfo.aliasMapVocabulary)) {
            const namespace = aliasInfo.aliasMapVocabulary[name];
            const alias = aliasInfo.reverseAliasMap[namespace];
            if (!usedNames.has(namespace) && alias !== undefined && !usedNames.has(alias)) {
                toRemove.add(namespace);
            }
        }
        for (const namespace of toRemove) {
            for (let index = 0; index < document.ast.rootElement.subElements.length; index++) {
                const reference = document.ast.rootElement.subElements[index];
                const match = reference.subElements.find((child) => child.name === "Include" /* Edm.Include */ &&
                    child.attributes.find((attribute) => attribute.key === "Namespace" /* Edm.Namespace */)?.value === namespace);
                if (match) {
                    writer.addChange({
                        type: types_1.DELETE_ELEMENT,
                        pointer: `${pointer}/subElements/${index}`
                    });
                }
            }
        }
        return toRemove.size > 0;
    }
    addReferences(writer, document, aliasInfo, usedNames, pointer) {
        const toAdd = new Set();
        for (const name of usedNames) {
            if (!aliasInfo.aliasMapVocabulary[name]) {
                const namespace = this.vocabularyService.getVocabularyNamespace(name);
                if (namespace) {
                    toAdd.add(namespace);
                }
            }
        }
        for (const namespace of toAdd) {
            const vocabularyInfo = this.vocabularyService.getVocabulary(namespace);
            if (!vocabularyInfo) {
                continue;
            }
            const alias = vocabularyInfo.defaultAlias;
            const referenceUri = vocabularyInfo.defaultUri;
            const reference = (0, odata_annotation_core_types_1.createReference)(namespace, alias, referenceUri);
            writer.addChange({
                type: types_1.INSERT_ELEMENT,
                pointer: pointer,
                element: createReferenceElement(reference),
                // insert at the start
                index: document.ast.rootElement.subElements.length > 0 ? 0 : undefined
            });
        }
        return toAdd.size > 0;
    }
}
exports.XMLAnnotationServiceAdapter = XMLAnnotationServiceAdapter;
function throwIf(condition, message) {
    if (condition) {
        throw new error_1.ApiError(message, error_1.ApiErrorCode.General);
    }
}
function createReferenceElement(reference) {
    const include = (0, odata_annotation_core_types_1.createElementNode)({
        name: "Include" /* Edmx.Include */,
        namespaceAlias: 'Edmx',
        attributes: {
            ["Namespace" /* Edmx.Namespace */]: (0, odata_annotation_core_types_1.createAttributeNode)("Namespace" /* Edmx.Namespace */, reference.name)
        }
    });
    if (reference.alias) {
        include.attributes["Alias" /* Edmx.Alias */] = (0, odata_annotation_core_types_1.createAttributeNode)("Alias" /* Edmx.Alias */, reference.alias);
    }
    return (0, odata_annotation_core_types_1.createElementNode)({
        name: "Reference" /* Edmx.Reference */,
        namespaceAlias: 'Edmx',
        content: [include],
        attributes: {
            ["Uri" /* Edmx.Uri */]: (0, odata_annotation_core_types_1.createAttributeNode)("Uri" /* Edmx.Uri */, reference.uri ?? '')
        }
    });
}
function getEdmxPointer(document) {
    if (!document.rootElement) {
        return undefined;
    }
    return `/rootElement`;
}
function getSchemaPointer(document) {
    if (!document.rootElement) {
        return undefined;
    }
    const dataServicesIndex = document.rootElement.subElements.findIndex((element) => element.name === "DataServices" /* Edmx.DataServices */);
    if (dataServicesIndex === -1) {
        return undefined;
    }
    const schemaIndex = document.rootElement.subElements[dataServicesIndex].subElements.findIndex((element) => element.name === "Schema" /* Edm.Schema */);
    if (schemaIndex === -1) {
        return undefined;
    }
    return `/rootElement/subElements/${dataServicesIndex}/subElements/${schemaIndex}`;
}
function parseFile(fileCache, file, ignoreComments = true) {
    const content = fileCache.get(file.uri);
    if (typeof content !== 'string') {
        throw new Error(`File ${file.uri} not found in cache!`);
    }
    const { cst, tokenVector } = (0, parser_1.parse)(content);
    const comments = ignoreComments ? [] : (0, comments_1.collectComments)(tokenVector);
    const ast = (0, ast_1.buildAst)(cst, tokenVector);
    return { ast, comments };
}
function convertPointer(annotationFile, pointer) {
    let currentNode = annotationFile;
    return pointer
        .split('/')
        .map((segment, i, self) => {
        if (segment === 'content' || segment === 'targets' || segment === 'terms') {
            if (self[i + 2] === 'text') {
                currentNode = currentNode.textContents;
                return 'textContents';
            }
            if (currentNode) {
                currentNode = currentNode[segment];
            }
            return 'subElements';
        }
        if (i !== 0 && currentNode) {
            const result = convertPointerSegment(segment, currentNode);
            currentNode = result.nextNode;
            return result.mappedSegment;
        }
        return segment;
    })
        .join('/');
}
function convertPointerSegment(segment, currentNode) {
    let elementIndex = -1;
    const index = Number.parseInt(segment, 10);
    const nextNode = currentNode[segment];
    if (Number.isSafeInteger(index) && Array.isArray(currentNode)) {
        // we need to adjust index to exclude text nodes
        for (let i = 0; i <= index && i < currentNode.length; i++) {
            const child = currentNode[i];
            if (child.type === odata_annotation_core_types_1.ELEMENT_TYPE) {
                elementIndex++;
            }
        }
    }
    else if (!Array.isArray(nextNode) && nextNode?.type === odata_annotation_core_types_1.ATTRIBUTE_TYPE) {
        // convert attribute segment to index based one
        // we assume that keys in the object are added in the order they are in file,
        // which in general should be true
        elementIndex = Object.keys(currentNode).findIndex((key) => key === segment);
    }
    const mappedSegment = elementIndex !== -1 ? elementIndex.toString() : segment;
    return { mappedSegment, nextNode };
}
function getAliasInfo(annotationFileInternal, metadataService) {
    const namespaces = (0, odata_annotation_core_1.getAllNamespacesAndReferences)(annotationFileInternal.namespace, annotationFileInternal.references);
    return (0, odata_annotation_core_1.getAliasInformation)(namespaces, metadataService.getNamespaces());
}
//# sourceMappingURL=adapter.js.map