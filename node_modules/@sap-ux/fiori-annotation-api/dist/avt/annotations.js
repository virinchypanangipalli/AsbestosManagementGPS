"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertAnnotationFile = void 0;
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const utils_1 = require("./utils");
/**
 * Converts internal representation annotation files to AVT format.
 *
 * @param file - Internal representation root.
 * @param serviceName - Service Name.
 * @param options - Conversion options.
 * @returns AVT annotations.
 */
function convertAnnotationFile(file, serviceName, options) {
    if (!file.references) {
        return [];
    }
    const annotations = [];
    const namespaceMap = getNamespaceMap(file.references);
    const namespace = file.uri.startsWith(odata_annotation_core_types_1.GHOST_FILENAME_PREFIX) || !file.namespace ? serviceName : file.namespace?.name ?? '';
    const alias = file.namespace?.alias ?? '';
    Object.freeze(namespaceMap);
    for (let targetIndex = 0; targetIndex < file.targets.length; targetIndex++) {
        const target = file.targets[targetIndex];
        const cache = new Map();
        const terms = [];
        const origins = [];
        const targetNamespaceMap = { ...namespaceMap, [namespace]: namespace };
        if (alias) {
            targetNamespaceMap[alias] = namespace;
        }
        const targetName = (0, utils_1.resolvePath)(targetNamespaceMap, namespace, target.name);
        for (let termIndex = 0; termIndex < target.terms.length; termIndex++) {
            const term = target.terms[termIndex];
            const annotation = convertAnnotation(targetNamespaceMap, target.name, term, options);
            const qualifier = annotation.qualifier ? '#' + annotation.qualifier : '';
            const id = `${targetName}@${annotation.term}${qualifier}`;
            const existingAnnotation = cache.get(id);
            if (options?.mergeSplitAnnotations && existingAnnotation) {
                mergeAnnotation(options.mergeMap, `${id}/0/0`, `${id}/${targetIndex}/${termIndex}`, existingAnnotation, annotation);
            }
            else {
                cache.set(id, annotation);
                terms.push(annotation);
            }
            origins.push(term.range);
        }
        const annotationList = {
            target: targetName,
            annotations: terms
        };
        if (options?.addOrigins) {
            annotationList.origins = origins;
        }
        annotations.push(annotationList);
    }
    return annotations;
}
exports.convertAnnotationFile = convertAnnotationFile;
// split values in generic format will have duplicated structures e.g
// annotations -> multiple elements with matching Target/Term/Qualifier combination, but partial values
// records -> multiple PropertyValue elements with the same name, but partial values
// all of these values are flattened
function mergeAnnotation(mergeMap, targetPath, sourcePath, target, source) {
    mergeAnnotationAnnotations(mergeMap, targetPath, sourcePath, target, source);
    if (target.record && source.record) {
        mergeRecord(mergeMap, targetPath, sourcePath, target.record, source.record, true);
    }
    else if (target.value && source.value) {
        target.value = source.value;
    }
    else if (target.collection && source.collection) {
        target.collection = source.collection;
    }
}
function mergeRecord(mergeMap, targetPath, sourcePath, target, source, directTermValue) {
    mergeRecordAnnotations(mergeMap, targetPath, sourcePath, target, source, directTermValue);
    const offset = target.propertyValues.length;
    const propertyName = directTermValue ? 'record' : 'Record';
    const mergedPaths = {};
    for (let i = 0; i < source.propertyValues.length; i++) {
        const property = source.propertyValues[i];
        const mergedPath = mergedPaths[property.name];
        if (mergedPath) {
            continue;
        }
        const existingIndex = target.propertyValues.findIndex((p) => p.name === property.name);
        if (existingIndex !== -1) {
            const mergedKey = `${targetPath}/${propertyName}/propertyValues/${existingIndex}`;
            mergedPaths[property.name] = mergedKey;
        }
        else if (property.value.type === 'Record') {
            const mergedKey = `${targetPath}/${propertyName}/propertyValues/${i + offset}`;
            mergedPaths[property.name] = mergedKey;
        }
    }
    mergeProperties(mergeMap, targetPath, sourcePath, target, source, mergedPaths, propertyName, offset);
    if (directTermValue) {
        return;
    }
}
function mergeProperties(mergeMap, targetPath, sourcePath, target, source, mergedPaths, propertyName, offset) {
    for (let i = 0; i < source.propertyValues.length; i++) {
        const property = source.propertyValues[i];
        const existingIndex = target.propertyValues.findIndex((p) => p.name === property.name);
        const mergedKey = mergedPaths[property.name] ?? `${targetPath}/${propertyName}/propertyValues/${i + offset}`;
        const key = `${sourcePath}/${propertyName}/propertyValues/${i}`;
        if (existingIndex !== -1) {
            const existing = target.propertyValues[existingIndex];
            if (existing.value.type === 'Record' && property.value.type === 'Record') {
                mergeRecord(mergeMap, `${mergedKey}/value`, `${key}/value`, existing.value.Record, property.value.Record, false);
            }
            else {
                existing.value = property.value;
            }
        }
        else {
            mergeMap[mergedKey] = key;
            target.propertyValues.push(property);
            if (target.propertyValuesOrigins && source.propertyValuesOrigins) {
                target.propertyValuesOrigins.push(source.propertyValuesOrigins[i]);
            }
        }
    }
}
function mergeAnnotationAnnotations(mergeMap, targetPath, sourcePath, target, source) {
    if (source.annotations) {
        if (!target.annotations) {
            target.annotations = [];
            for (let i = 0; i < source.annotations.length; i++) {
                const annotation = source.annotations[i];
                const mergedKey = `${targetPath}/annotations/${i}`;
                const key = `${sourcePath}/annotations/${i}`;
                mergeMap[mergedKey] = key;
                target.annotations.push(annotation);
            }
            return;
        }
        const offset = target.annotations.length;
        for (let i = 0; i < source.annotations.length; i++) {
            const annotation = source.annotations[i];
            const existing = target.annotations.find((a) => a.term === annotation.term && a.qualifier === annotation.qualifier);
            const mergedKey = `${targetPath}/annotations/${i + offset}`;
            const key = `${sourcePath}/annotations/${i}`;
            if (existing) {
                mergeAnnotation(mergeMap, mergedKey, key, existing, annotation);
            }
            else {
                mergeMap[mergedKey] = key;
                target.annotations.push(annotation);
            }
        }
    }
}
function mergeRecordAnnotations(mergeMap, targetPath, sourcePath, target, source, directTermValue) {
    if (source.annotations) {
        const propertyName = directTermValue ? 'record' : 'Record';
        if (!target.annotations) {
            target.annotations = [];
            for (let i = 0; i < source.annotations.length; i++) {
                const annotation = source.annotations[i];
                const mergedKey = `${targetPath}/${propertyName}/annotations/${i}`;
                const key = `${sourcePath}/${propertyName}/annotations/${i}`;
                mergeMap[mergedKey] = key;
                target.annotations.push(annotation);
            }
            return;
        }
        const offset = target.annotations.length;
        for (let i = 0; i < source.annotations.length; i++) {
            const annotation = source.annotations[i];
            const existing = target.annotations.find((a) => a.term === annotation.term && a.qualifier === annotation.qualifier);
            const mergedKey = `${targetPath}/${propertyName}/annotations/${i + offset}`;
            const key = `${sourcePath}/${propertyName}/annotations/${i}`;
            if (existing) {
                mergeAnnotation(mergeMap, mergedKey, key, existing, annotation);
            }
            else {
                mergeMap[mergedKey] = key;
                target.annotations.push(annotation);
            }
        }
    }
}
function getNamespaceMap(references) {
    const namespaceMap = {};
    for (const reference of references) {
        namespaceMap[reference.name] = reference.name;
        if (reference.alias) {
            namespaceMap[reference.alias] = reference.name;
        }
    }
    namespaceMap['Edm'] = 'Edm';
    return namespaceMap;
}
function convertAnnotation(namespaceMap, currentNamespace, annotationElement, options) {
    const termAttributeValue = (0, odata_annotation_core_1.getElementAttributeValue)(annotationElement, 'Term');
    const term = (0, odata_annotation_core_1.parseIdentifier)(termAttributeValue);
    let fqTerm = (0, odata_annotation_core_1.toFullyQualifiedName)(namespaceMap, '', term);
    const qualifier = (0, odata_annotation_core_1.getElementAttributeValue)(annotationElement, 'Qualifier');
    if (fqTerm?.startsWith('com.sap.vocabularies.CDS.v1.')) {
        const result = options?.vocabularyService?.cdsVocabulary.reverseNameMap.get(term.namespaceOrAlias + '.' + term.name);
        if (result) {
            fqTerm = result;
        }
    }
    const value = convertExpression(namespaceMap, currentNamespace, annotationElement, options);
    const annotation = {
        term: fqTerm ?? termAttributeValue,
        value
    };
    if (options?.addOrigins) {
        annotation.origin = annotationElement.range;
    }
    if (qualifier) {
        annotation.qualifier = qualifier;
    }
    if (annotation.value?.type === 'Record') {
        annotation.record = annotation.value.Record;
        delete annotation.value;
    }
    else if (annotation.value?.type === 'Collection') {
        annotation.collection = annotation.value.Collection;
        if (options?.addOrigins) {
            annotation.collectionOrigins = annotation.value.collectionOrigins;
        }
        delete annotation.value;
    }
    else if (annotation.value?.type === 'Unknown' && Object.keys(annotation.value).length === 1) {
        delete annotation.value; // did not appear in parseEdmx output
    }
    const embeddedAnnotations = convertEmbeddedAnnotations(namespaceMap, currentNamespace, annotationElement, options);
    if (embeddedAnnotations.length) {
        annotation.annotations = embeddedAnnotations;
    }
    return annotation;
}
function convertEmbeddedAnnotations(namespaceMap, currentNamespace, element, options) {
    return (element.content ?? [])
        .filter((child) => child.type === odata_annotation_core_types_1.ELEMENT_TYPE && child.name === "Annotation" /* Edm.Annotation */)
        .map((embeddedAnnotation) => convertAnnotation(namespaceMap, currentNamespace, embeddedAnnotation, options));
}
const EXPRESSION_TYPES = new Set([
    "String" /* Edm.String */,
    "Bool" /* Edm.Bool */,
    "Decimal" /* Edm.Decimal */,
    "Date" /* Edm.Date */,
    "Float" /* Edm.Float */,
    "Int" /* Edm.Int */,
    "Path" /* Edm.Path */,
    "PropertyPath" /* Edm.PropertyPath */,
    "AnnotationPath" /* Edm.AnnotationPath */,
    "NavigationPropertyPath" /* Edm.NavigationPropertyPath */,
    "EnumMember" /* Edm.EnumMember */,
    "Collection" /* Edm.Collection */,
    "Record" /* Edm.Record */,
    "Apply" /* Edm.Apply */,
    "Null" /* Edm.Null */
]);
function convertExpression(namespaceMap, currentNamespace, element, options) {
    const expressionValues = [];
    // check if element itself represents the value
    if (EXPRESSION_TYPES.has(element.name)) {
        expressionValues.push(convertExpressionValue(namespaceMap, currentNamespace, element, options));
    }
    // check if value is provided as attribute
    for (const attributeName of Object.keys(element.attributes)) {
        if (EXPRESSION_TYPES.has(attributeName)) {
            const attribute = (0, odata_annotation_core_1.getElementAttribute)(element, attributeName);
            if (attribute) {
                expressionValues.push(createExpression(namespaceMap, currentNamespace, attribute.name, attribute.value));
            }
        }
    }
    // check if value is provided as sub node
    const children = (element.content ?? []).filter((child) => child.type === odata_annotation_core_types_1.ELEMENT_TYPE && EXPRESSION_TYPES.has(child.name));
    for (const child of children) {
        expressionValues.push(convertExpressionValue(namespaceMap, currentNamespace, child, options));
    }
    return expressionValues[0];
}
function createExpression(namespaceMap, currentNamespace, name, value) {
    switch (name) {
        case 'String':
            return {
                type: 'String',
                String: value
            };
        case 'Bool':
            return {
                type: 'Bool',
                Bool: value === 'true'
            };
        case 'Decimal':
            return {
                type: 'Decimal',
                Decimal: parseFloat(value)
            };
        case 'Date':
            return {
                type: 'Date',
                Date: value
            };
        case 'Int':
            return {
                type: 'Int',
                Int: parseInt(value, 10)
            };
        case 'Path':
            return {
                type: 'Path',
                Path: (0, utils_1.resolvePath)(namespaceMap, currentNamespace, value)
            };
        case 'PropertyPath':
            return {
                type: 'PropertyPath',
                PropertyPath: (0, utils_1.resolvePath)(namespaceMap, currentNamespace, value)
            };
        case 'AnnotationPath':
            return {
                type: 'AnnotationPath',
                AnnotationPath: (0, utils_1.resolvePath)(namespaceMap, currentNamespace, value)
            };
        case 'NavigationPropertyPath':
            return {
                type: 'NavigationPropertyPath',
                NavigationPropertyPath: (0, utils_1.resolvePath)(namespaceMap, currentNamespace, value)
            };
        case 'EnumMember':
            return {
                type: 'EnumMember',
                EnumMember: (0, utils_1.resolveEnumMemberValue)(namespaceMap, currentNamespace, value)
            };
        case 'Null':
            return {
                type: 'Null'
            };
        default:
            return {
                type: 'Unknown'
            };
    }
}
/**
 * Convert expression value from internal:
 *  - value for an expression can be primitive or non primitive (AnnotationRecord, Collection, Apply).
 *  - all primitive values are returned in their stringified version.
 *
 * @param namespaceMap - Namespace and alias mapping.
 * @param currentNamespace - Current files namespace.
 * @param element - Is supposed to represent a value of an expression.
 * @param options - Conversion options.
 * @returns AVT expression.
 */
function convertExpressionValue(namespaceMap, currentNamespace, element, options) {
    switch (element.name) {
        case 'Collection': {
            const { collection, collectionOrigins } = convertCollection(namespaceMap, currentNamespace, element, options);
            const result = {
                type: 'Collection',
                Collection: collection
            };
            if (options?.addOrigins) {
                result.collectionOrigins = collectionOrigins;
            }
            return result;
        }
        case 'Record':
            return {
                type: 'Record',
                Record: convertRecord(namespaceMap, currentNamespace, element, options)
            };
        case 'Apply':
            return {
                type: 'Apply',
                Apply: convertApply(namespaceMap, currentNamespace, element)
            };
        default: {
            const singleTextNode = (0, odata_annotation_core_1.getSingleTextNode)(element);
            const value = singleTextNode?.text ?? '';
            return createExpression(namespaceMap, currentNamespace, element.name, value);
        }
    }
}
function convertRecord(namespaceMap, currentNamespace, recordElement, options) {
    const origins = [];
    const type = (0, odata_annotation_core_1.getElementAttributeValue)(recordElement, 'Type');
    let resolvedRecordType;
    if (type) {
        const parsedIdentifier = (0, odata_annotation_core_1.parseIdentifier)(type);
        resolvedRecordType = (0, odata_annotation_core_1.toFullyQualifiedName)(namespaceMap, '', parsedIdentifier);
    }
    const propertyValues = (recordElement.content || [])
        .filter((child) => child.type === odata_annotation_core_types_1.ELEMENT_TYPE && child.name === "PropertyValue" /* Edm.PropertyValue */)
        .map((propValueChild) => {
        if (options?.addOrigins) {
            origins.push(propValueChild.range);
        }
        const name = (0, odata_annotation_core_1.getElementAttributeValue)(propValueChild, 'Property');
        const propertyValue = {
            name,
            value: convertExpression(namespaceMap, currentNamespace, propValueChild, options) || { type: 'Unknown' } // when property value have default value
        };
        const annotations = convertEmbeddedAnnotations(namespaceMap, currentNamespace, propValueChild, options);
        if (annotations?.length) {
            propertyValue.annotations = annotations;
        }
        if (propertyValue?.value?.type === 'Unknown' && Object.keys(propertyValue?.value).length === 1) {
            propertyValue.value = { type: 'Bool', Bool: true }; // presumably boolean property with default value true
        }
        return propertyValue;
    });
    const record = { propertyValues };
    if (options?.addOrigins) {
        record.propertyValuesOrigins = origins;
    }
    if (resolvedRecordType) {
        record.type = resolvedRecordType;
    }
    const annotations = convertEmbeddedAnnotations(namespaceMap, currentNamespace, recordElement, options);
    if (annotations.length) {
        record.annotations = annotations;
    }
    return record;
}
function convertCollection(namespaceMap, currentNamespace, collectionElement, options) {
    const collection = [];
    const collectionOrigins = [];
    (collectionElement.content || [])
        .filter((child) => child.type === odata_annotation_core_types_1.ELEMENT_TYPE)
        .forEach((collectionEntryElement) => {
        const value = convertExpression(namespaceMap, currentNamespace, collectionEntryElement, options);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let entry = value;
        if (value && value.type) {
            // record and string can be used directly as collection entries
            if (value.type === 'Record') {
                entry = value.Record;
            }
            else if (value.type === 'String') {
                entry = value.String;
            }
        }
        collection.push(entry);
        if (options?.addOrigins && collectionEntryElement.range) {
            collectionOrigins.push(collectionEntryElement.range);
        }
    });
    return { collection, collectionOrigins };
}
function convertApply(namespaceMap, currentNamespace, element) {
    // use internal representation (without alias) to represent Apply value
    const clone = JSON.parse(JSON.stringify(element));
    return replaceAliasInElement(namespaceMap, currentNamespace, clone);
}
function replaceAliasInElement(namespaceMap, currentNamespace, element) {
    const result = element;
    // replace aliased in all attributes/sub nodes with full namespaces (reverse = true ? vice versa):
    // in attributes: term or type attributes, enumValue and any path values provided as attributes
    Object.keys(result.attributes || {}).forEach((attributeName) => {
        const attribute = result.attributes[attributeName];
        if (attributeName === "Term" /* Edm.Term */ || attributeName === 'Type') {
            const parsedIdentifier = (0, odata_annotation_core_1.parseIdentifier)(attribute.value);
            const fullyQualifiedName = (0, odata_annotation_core_1.toFullyQualifiedName)(namespaceMap, '', parsedIdentifier);
            if (fullyQualifiedName) {
                attribute.value = fullyQualifiedName;
            }
        }
        else if (attributeName === 'EnumMember') {
            attribute.value = (0, utils_1.resolveEnumMemberValue)(namespaceMap, currentNamespace, attribute.value);
        }
        else if (attributeName.endsWith('Path')) {
            attribute.value = (0, utils_1.resolvePath)(namespaceMap, currentNamespace, attribute.value);
        }
    });
    if ((result.content || []).some((entry) => entry.type === odata_annotation_core_types_1.ELEMENT_TYPE)) {
        // sub elements present: filter out empty text nodes
        result.content = result.content.filter((entry) => !(entry.type === odata_annotation_core_types_1.TEXT_TYPE && !(entry.text || '').trim()));
    }
    // in sub nodes
    replaceAliasInElementContent(namespaceMap, currentNamespace, result);
    return result;
}
function replaceAliasInElementContent(namespaceMap, currentNamespace, element) {
    for (const subNode of element.content || []) {
        if (subNode.type === odata_annotation_core_types_1.ELEMENT_TYPE) {
            replaceAliasInElement(namespaceMap, currentNamespace, subNode);
        }
        else if (subNode.type === odata_annotation_core_types_1.TEXT_TYPE) {
            const text = subNode.text;
            if (element.name === 'EnumMember') {
                subNode.text = (0, utils_1.resolveEnumMemberValue)(namespaceMap, currentNamespace, text);
            }
            else if (subNode.type === odata_annotation_core_types_1.TEXT_TYPE && element.name.endsWith('Path')) {
                subNode.text = (0, utils_1.resolvePath)(namespaceMap, currentNamespace, text);
            }
        }
    }
}
//# sourceMappingURL=annotations.js.map