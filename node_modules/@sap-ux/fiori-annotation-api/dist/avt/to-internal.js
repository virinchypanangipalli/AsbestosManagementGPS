"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertPrimitiveValueToInternal = exports.convertApplyToInternal = exports.convertExpressionToInternal = exports.convertPropertyValueToInternal = exports.convertRecordToInternal = exports.convertCollectionElement = exports.convertCollectionToInternal = exports.convertAnnotationToInternal = exports.buildEmptyTarget = exports.convertTargetAnnotationsToInternal = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const expressions_1 = require("./expressions");
const utils_1 = require("./utils");
/**
 * Convert target annotations to internal format.
 *
 * @param targetAnnotations - AVT annotation list
 * @param aliasInfo - Alias Information.
 * @returns Internal representation of the Target.
 */
function convertTargetAnnotationsToInternal(targetAnnotations, aliasInfo) {
    const target = buildEmptyTarget(getAliasedPath(aliasInfo, targetAnnotations.target));
    target.terms = targetAnnotations.annotations.map((annotation) => convertAnnotationToInternal(annotation, aliasInfo));
    return target;
}
exports.convertTargetAnnotationsToInternal = convertTargetAnnotationsToInternal;
/**
 * Build empty target (generic annotation file format).
 *
 * @param path - Target name.
 * @returns Internal representation of the target.
 */
function buildEmptyTarget(path) {
    return { type: 'target', name: path, terms: [], range: undefined, nameRange: undefined, termsRange: undefined };
}
exports.buildEmptyTarget = buildEmptyTarget;
/**
 * Convert annotation to internal format.
 *
 * @param annotation - Annotation.
 * @param aliasInfo - Alias Information.
 * @returns Internal representation of the annotation.
 */
function convertAnnotationToInternal(annotation, aliasInfo) {
    const annotationElement = (0, odata_annotation_core_types_1.createElementNode)({ name: "Annotation" /* Edm.Annotation */ });
    annotationElement.attributes["Term" /* Edm.Term */] = (0, odata_annotation_core_types_1.createAttributeNode)("Term" /* Edm.Term */, (0, odata_annotation_core_1.toAliasQualifiedName)(annotation.term, aliasInfo));
    if (annotation.qualifier) {
        annotationElement.attributes["Qualifier" /* Edm.Qualifier */] = (0, odata_annotation_core_types_1.createAttributeNode)("Qualifier" /* Edm.Qualifier */, annotation.qualifier);
    }
    if (annotation.collection) {
        annotationElement.content = annotationElement.content || [];
        annotationElement.content.push(convertCollectionToInternal(aliasInfo, annotation.collection));
    }
    else if (annotation.record) {
        annotationElement.content = annotationElement.content || [];
        annotationElement.content.push(convertRecordToInternal(aliasInfo, annotation.record));
    }
    else if (annotation.value) {
        convertExpressionToInternal(aliasInfo, annotation.value, annotationElement);
    }
    if (annotation.annotations?.length) {
        // add embedded annotations
        annotation.annotations.forEach((annotation) => {
            annotationElement.content = annotationElement.content || [];
            annotationElement.content.push(convertAnnotationToInternal(annotation, aliasInfo));
        });
    }
    return annotationElement;
}
exports.convertAnnotationToInternal = convertAnnotationToInternal;
/**
 * Convert collection to internal format.
 *
 * @param aliasInfo - Alias Information.
 * @param collection - Collection.
 * @returns Internal representation of the collection.
 */
function convertCollectionToInternal(aliasInfo, collection) {
    const collectionElement = (0, odata_annotation_core_types_1.createElementNode)({ name: "Collection" /* Edm.Collection */ });
    for (const entry of collection) {
        const entryNode = convertCollectionElement(aliasInfo, entry);
        if (entryNode) {
            collectionElement.content.push(entryNode);
        }
    }
    return collectionElement;
}
exports.convertCollectionToInternal = convertCollectionToInternal;
/**
 *
 * @param aliasInfo - Alias Information.
 * @param entry - Collection entry.
 * @returns Internal representation of the collection entry.
 */
function convertCollectionElement(aliasInfo, entry) {
    if (typeof entry === 'object') {
        if ((0, expressions_1.isExpression)(entry)) {
            // entry is expression
            return convertExpressionToInternal(aliasInfo, entry);
        }
        else {
            // entry must be record
            return convertRecordToInternal(aliasInfo, entry);
        }
    }
    else if (typeof entry === 'string') {
        return (0, odata_annotation_core_types_1.createElementNode)({ name: "String" /* Edm.String */, content: [(0, odata_annotation_core_types_1.createTextNode)(entry.toString())] });
    }
    else if (typeof entry === 'boolean') {
        // obvious extension of annotation.record definition
        return (0, odata_annotation_core_types_1.createElementNode)({ name: "Bool" /* Edm.Bool */, content: [(0, odata_annotation_core_types_1.createTextNode)(entry ? 'true' : 'false')] });
    }
    return undefined;
}
exports.convertCollectionElement = convertCollectionElement;
/**
 * Convert record to internal format.
 *
 * @param aliasInfo - Alias Information.
 * @param record - Record.
 * @returns Internal representation of the record.
 */
function convertRecordToInternal(aliasInfo, record) {
    const recordElement = (0, odata_annotation_core_types_1.createElementNode)({ name: "Record" /* Edm.Record */ });
    if (record.type) {
        recordElement.attributes["Type" /* Edm.Type */] = (0, odata_annotation_core_types_1.createAttributeNode)("Type" /* Edm.Type */, (0, odata_annotation_core_1.toAliasQualifiedName)(record.type, aliasInfo));
    }
    record.propertyValues.forEach((propertyValue) => {
        const propValueElement = convertPropertyValueToInternal(aliasInfo, propertyValue);
        recordElement.content.push(propValueElement);
    });
    if (record.annotations?.length) {
        // add embedded annotations
        recordElement.content = recordElement.content || [];
        record.annotations.forEach((annotation) => {
            recordElement.content.push(convertAnnotationToInternal(annotation, aliasInfo));
        });
    }
    return recordElement;
}
exports.convertRecordToInternal = convertRecordToInternal;
/**
 *
 * @param aliasInfo - Alias Information.
 * @param propertyValue - Property value.
 * @returns Internal representation of the property value.
 */
function convertPropertyValueToInternal(aliasInfo, propertyValue) {
    const propValueElement = (0, odata_annotation_core_types_1.createElementNode)({ name: "PropertyValue" /* Edm.PropertyValue */ });
    propValueElement.attributes["Property" /* Edm.Property */] = (0, odata_annotation_core_types_1.createAttributeNode)("Property" /* Edm.Property */, propertyValue.name);
    convertExpressionToInternal(aliasInfo, propertyValue.value, propValueElement);
    if (propertyValue.annotations?.length) {
        // add embedded annotations
        propValueElement.content = propValueElement.content || [];
        propertyValue.annotations.forEach((annotation) => {
            propValueElement.content.push(convertAnnotationToInternal(annotation, aliasInfo));
        });
    }
    return propValueElement;
}
exports.convertPropertyValueToInternal = convertPropertyValueToInternal;
/**
 * Convert expression to internal representation.
 *
 * @param aliasInfo - Alias Information.
 * @param value - Expression value.
 * @param hostElement add value to this element as host (e.g. add for elements Annotation and PropertyValue)
 * @returns Internal representation of the expression.
 */
function convertExpressionToInternal(aliasInfo, value, hostElement) {
    const elementName = expressions_1.expressionNames[value.type] ? value.type : '';
    let element = hostElement ?? (elementName ? (0, odata_annotation_core_types_1.createElementNode)({ name: elementName }) : undefined);
    if (!element) {
        return undefined;
    }
    let collectionElement;
    let recordElement;
    let nullElement;
    let primitiveValue;
    switch (value.type) {
        case 'Collection':
            collectionElement = convertCollectionToInternal(aliasInfo, value.Collection);
            element = consumeElement(element, collectionElement, hostElement);
            break;
        case 'Record':
            recordElement = convertRecordToInternal(aliasInfo, value.Record);
            element = consumeElement(element, recordElement, hostElement);
            break;
        case 'Apply':
            recordElement = convertApplyToInternal(aliasInfo, value.Apply);
            element = consumeElement(element, recordElement, hostElement);
            break;
        case 'Null':
            nullElement = (0, odata_annotation_core_types_1.createElementNode)({ name: elementName });
            element = consumeElement(element, nullElement, hostElement);
            break;
        case 'Unknown':
            return undefined;
        default: {
            // value type is EDMX primitive expression
            const rawPrimitiveValue = value[value.type]; // There is always a property with on the object as type name, Typescript does not infer this case as expected
            primitiveValue = convertPrimitiveValueToInternal(value.type, rawPrimitiveValue, aliasInfo);
            if (hostElement) {
                // add value to host element as attribute
                element.attributes = element.attributes || {};
                element.attributes[value.type] = (0, odata_annotation_core_types_1.createAttributeNode)(value.type, primitiveValue);
            }
            else {
                // add value as single text sub node
                element.content.push((0, odata_annotation_core_types_1.createTextNode)(primitiveValue));
            }
            break;
        }
    }
    return element;
}
exports.convertExpressionToInternal = convertExpressionToInternal;
/**
 *
 * @param aliasInfo - Alias Information.
 * @param apply - Apply expression.
 * @returns Internal representation of apply.
 */
function convertApplyToInternal(aliasInfo, apply) {
    // Apply value is regular internal representation (without alias)
    const clone = JSON.parse(JSON.stringify(apply));
    return replaceAliasInElement(clone, aliasInfo, true);
}
exports.convertApplyToInternal = convertApplyToInternal;
/**
 *
 * @param type - Type of primitive value.
 * @param value - Primitive value.
 * @param aliasInfo - Alias Information.
 * @returns Internal representation of primitive value
 */
function convertPrimitiveValueToInternal(type, value, aliasInfo) {
    const text = value === undefined ? '' : value.toString();
    if (!text) {
        return text;
    }
    else if (type === "EnumMember" /* Edm.EnumMember */) {
        return (0, utils_1.getAliasedEnumMember)(aliasInfo, text);
    }
    else if (type.indexOf('Path') >= 0) {
        return getAliasedPath(aliasInfo, text);
    }
    else if (type === "Type" /* Edm.Type */ || type === "Term" /* Edm.Term */) {
        return (0, odata_annotation_core_1.toAliasQualifiedName)(text, aliasInfo);
    }
    else {
        return text;
    }
}
exports.convertPrimitiveValueToInternal = convertPrimitiveValueToInternal;
function consumeElement(element, collectionElement, hostElement) {
    if (hostElement) {
        element.content = element.content || [];
        element.content.push(collectionElement); // add whole collection as sub element
    }
    else {
        element = collectionElement;
    }
    return element;
}
function replaceAliasInElement(element, aliasInfo, reverse) {
    // replace aliases in all attributes/sub nodes with full namespaces (reverse = true ? vice versa):
    const result = element;
    removeEmptyTextNodes(result);
    replaceAliasInAttributes(result, aliasInfo, reverse);
    replaceAliasInSubNodes(result, aliasInfo, reverse);
    return result;
}
function replaceAliasInAttributes(result, aliasInfo, reverse) {
    // in attributes: term or type attributes, enumValue and any path values provided as attributes
    Object.keys(result.attributes || {}).forEach((attributeName) => {
        const attribute = result.attributes[attributeName];
        switch (attributeName) {
            case "Term" /* Edm.Term */:
            case "Type" /* Edm.Type */:
                attribute.value = reverse
                    ? (0, odata_annotation_core_1.toAliasQualifiedName)(attribute.value, aliasInfo)
                    : (0, odata_annotation_core_1.resolveName)(attribute.value, aliasInfo.aliasMap)?.qName;
                break;
            case "EnumMember" /* Edm.EnumMember */:
                attribute.value = reverse
                    ? (0, utils_1.getAliasedEnumMember)(aliasInfo, attribute.value)
                    : (0, utils_1.resolveEnumMemberValue)(aliasInfo.aliasMap, aliasInfo.currentFileNamespace, attribute.value);
                break;
            default:
                if (attributeName.endsWith('Path')) {
                    attribute.value = reverse
                        ? getAliasedPath(aliasInfo, attribute.value)
                        : (0, utils_1.resolvePath)(aliasInfo.aliasMap, aliasInfo.currentFileNamespace, attribute.value);
                }
                break;
        }
    });
}
function replaceAliasInSubNodes(result, aliasInfo, reverse) {
    for (const subNode of result.content) {
        if (subNode.type === odata_annotation_core_types_1.ELEMENT_TYPE) {
            replaceAliasInElement(subNode, aliasInfo, reverse);
        }
        else if (subNode.type === odata_annotation_core_types_1.TEXT_TYPE && result.name === "EnumMember" /* Edm.EnumMember */) {
            subNode.text = reverse
                ? (0, utils_1.getAliasedEnumMember)(aliasInfo, subNode.text)
                : (0, utils_1.resolveEnumMemberValue)(aliasInfo.aliasMap, aliasInfo.currentFileNamespace, subNode.text);
        }
        else if (subNode.type === odata_annotation_core_types_1.TEXT_TYPE && result.name.endsWith('Path')) {
            subNode.text = reverse
                ? getAliasedPath(aliasInfo, subNode.text)
                : (0, utils_1.resolvePath)(aliasInfo.aliasMap, aliasInfo.currentFileNamespace, subNode.text);
        }
    }
}
function removeEmptyTextNodes(result) {
    if ((result.content ?? []).some((entry) => entry.type === odata_annotation_core_types_1.ELEMENT_TYPE)) {
        // sub elements present: filter out empty text nodes
        result.content = result.content.filter((entry) => !(entry.type === odata_annotation_core_types_1.TEXT_TYPE && !(entry.text ?? '').trim()));
    }
}
function getAliasedSegment(aliasInfo, segment) {
    const [path, term] = segment.split('@');
    if (term) {
        return `${path}@${(0, odata_annotation_core_1.toAliasQualifiedName)(term, aliasInfo)}`;
    }
    else if (segment.indexOf('.') > -1) {
        return (0, odata_annotation_core_1.toAliasQualifiedName)(segment, aliasInfo);
    }
    else {
        return segment;
    }
}
function getAliasedPath(aliasInfo, path) {
    return path
        .split('/')
        .map((segment) => getAliasedSegment(aliasInfo, segment))
        .join('/');
}
//# sourceMappingURL=to-internal.js.map