"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAnnotationByReference = exports.findAnnotation = exports.getAvtNodeFromPointer = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const error_1 = require("../error");
const utils_1 = require("../utils");
const pointer_1 = require("./pointer");
/**
 * Finds a node matching to the pointer from root.
 *
 * @param root - Root node.
 * @param pointer - Pointer to a node.
 * @returns Node matching pointer.
 */
function getAvtNodeFromPointer(root, pointer) {
    const segments = pointer.split('/');
    if (segments[0] === '') {
        segments.shift(); // Remove the first empty segment
    }
    if (segments.length === 0) {
        return undefined;
    }
    let node = root;
    for (const segment of segments) {
        const next = node[segment];
        if (next) {
            node = next;
        }
        else {
            return undefined;
        }
    }
    return node;
}
exports.getAvtNodeFromPointer = getAvtNodeFromPointer;
/**
 *  Fins first annotation matching the reference.
 *
 * @param annotationLists - Annotation lists.
 * @param reference - Annotation reference.
 * @returns Matching annotation.
 */
function findAnnotation(annotationLists, reference) {
    for (const annotationList of annotationLists) {
        if (annotationList.target === reference.target) {
            for (const annotation of annotationList.annotations) {
                if (annotation.term === reference.term && annotation.qualifier === reference.qualifier) {
                    return annotation;
                }
            }
        }
    }
    return undefined;
}
exports.findAnnotation = findAnnotation;
/**
 *
 * @param aliasInfo - Alias information.
 * @param file - Internal representation.
 * @param mergeMap - Annotation merge map.
 * @param reference - Annotation reference.
 * @param pointer - Pointer to a node.
 * @param mergeAnnotations - Flag indicating if annotations were merged.
 * @param valueType - Current value type.
 * @returns Annotation search result.
 */
function findAnnotationByReference(aliasInfo, file, mergeMap, reference, pointer, mergeAnnotations, valueType) {
    // find generic representation of annotation (take first match for term and qualifier)
    for (let i = 0; i < file.targets.length; i++) {
        const target = file.targets[i];
        const targetName = resolvePath(aliasInfo.aliasMap, aliasInfo.currentFileNamespace, target.name);
        if (targetName !== reference.target) {
            continue;
        }
        for (let j = 0; j < target.terms.length; j++) {
            const term = target.terms[j];
            const qualifier = (0, odata_annotation_core_1.getElementAttributeValue)(term, "Qualifier" /* Edm.Qualifier */);
            const termName = (0, odata_annotation_core_1.resolveName)((0, odata_annotation_core_1.getElementAttributeValue)(term, "Term" /* Edm.Term */), aliasInfo.aliasMap).qName;
            if (reference.term === termName &&
                ((!qualifier && !reference.qualifier) || qualifier === reference.qualifier)) {
                if (mergeAnnotations) {
                    const suffix = qualifier ? '#' + qualifier : '';
                    const id = `${targetName}@${termName}${suffix}`;
                    const result = searchInMergedAnnotations(file, mergeMap, id, pointer, valueType);
                    if (result) {
                        return result;
                    }
                }
                const internalPointer = (0, pointer_1.convertPointerInAnnotationToInternal)(term, pointer, valueType);
                return { element: term, target, targetPointer: `/targets/${i}/terms/${j}`, internalPointer };
            }
        }
    }
    const path = (0, utils_1.annotationReferenceToString)(reference);
    throw new error_1.ApiError(`Term '${path}' does not exist`, error_1.ApiErrorCode.General);
}
exports.findAnnotationByReference = findAnnotationByReference;
function searchInMergedAnnotations(file, mergeMap, id, pointer, valueType) {
    const mergedSegments = pointer.split('/').filter((x) => !!x);
    const keyRoot = `${id}/0/0`;
    for (let segmentIndex = mergedSegments.length; segmentIndex > 0; segmentIndex--) {
        const key = `${keyRoot}/${mergedSegments.slice(0, segmentIndex).join('/')}`;
        const match = mergeMap[key];
        if (match) {
            const [, targetIndexSegment, termIndexSegment, ...mappedSourceSegments] = match.replace(id, '').split('/');
            const targetIndex = parseInt(targetIndexSegment, 10);
            const termIndex = parseInt(termIndexSegment, 10);
            const sourceTerm = file.targets[targetIndex].terms[termIndex];
            const internalPointer = (0, pointer_1.convertPointerInAnnotationToInternal)(sourceTerm, '/' + [...mappedSourceSegments, ...mergedSegments.slice(segmentIndex)].join('/'), valueType);
            return {
                element: sourceTerm,
                target: file.targets[targetIndex],
                targetPointer: `/targets/${targetIndex}/terms/${termIndex}`,
                internalPointer
            };
        }
    }
    return undefined;
}
function resolvePath(namespaceMap, currentNamespace, path) {
    const parsedPath = (0, odata_annotation_core_1.parsePath)(path);
    parsedPath.segments = parsedPath.segments.map((segment, i) => {
        if (segment.namespaceOrAlias === undefined && i === 0) {
            return {
                ...segment,
                namespaceOrAlias: currentNamespace
            };
        }
        return segment;
    });
    return (0, odata_annotation_core_1.toFullyQualifiedPath)(namespaceMap, currentNamespace, parsedPath);
}
//# sourceMappingURL=find.js.map