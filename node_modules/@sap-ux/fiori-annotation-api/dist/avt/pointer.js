"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertPointerInAnnotationToInternal = void 0;
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const expressions_1 = require("./expressions");
/*
  Fiori Annotation API uses paths (in JsonPointer format) to specify locations inside a (non embedded) annotation value.

  Annotation values are represented as in internal annotation file representation (Element, Attribute, TextNode) and
  paths therein use JsonPointer format.

  Remark: Internal representation of annotation value has more flexibility (choice between attribute and sub element notation)
  Hence - converting path to internal needs to have the actual internal representation.
  Also: error situations can occur in internal representation, which cannot be expressed in AVT format (e.g. multiple values for a PropertyValue)
 */
/**
 * Convert path in annotation to internal representation.
 *
 * @param annotation - Internal representation element.
 * @param pointer - path in external representation
 * @param valueType - Current value type
 * @returns Pointer to an internal representation node.
 */
function convertPointerInAnnotationToInternal(annotation, pointer, valueType) {
    // e.g.
    // "/record/propertyValues/3/value/Collection/0/PropertyPath"
    // into "/content/0/content/3/content/0/content/0/text"
    // based on
    /*
    <Annotation Term="UI.Chart">
        <Record Type="UI.ChartDefinitionType">
            <PropertyValue Property="Title" String="Sales Data"/>
            <PropertyValue Property="Description" String="Sales"/>
            <PropertyValue Property="ChartType" EnumMember="UI.ChartType/Bar"/>
            <PropertyValue Property="Dimensions">
                <Collection>
                    <PropertyPath>Revenue</PropertyPath> // <<<====
    */
    let path = [''];
    const segments = pointer.split('/').filter((segment) => !!segment);
    let currentElement = annotation;
    let indexedSubElementName; // '' is valid value when looking for all sub element names
    segments.forEach((segment) => {
        if (!currentElement || !path) {
            // further path segments but no element to resolve it: error
            path = [];
            return;
        }
        let result = { subElementIndex: -1 };
        switch (segment) {
            case 'annotations':
                // n'th Annotation sub element should represent n'th embedded annotation
                indexedSubElementName = "Annotation" /* Edm.Annotation */;
                break;
            case 'record':
            case 'Record':
                // must be record sub element
                result = findSubElement(currentElement, "Record" /* Edm.Record */, 0);
                break;
            case 'propertyValues':
                // n'th PropertyValue sub element should represent n'th entry in propertyValues
                indexedSubElementName = "PropertyValue" /* Edm.PropertyValue */;
                break;
            case 'collection':
            case 'Collection':
                // just goto n'th subElement
                result = findSubElement(currentElement, "Collection" /* Edm.Collection */, 0);
                indexedSubElementName = '';
                break;
            case 'value':
                // if last segment: stay on current element, if further segments follow: they are handled in default
                path.push(...handleExpressionValueSegment(currentElement, valueType));
                break;
            case 'type':
                // type attribute in a Record
                path.push('attributes', 'Type', 'value');
                break;
            default:
                if (isNaN(Number(segment))) {
                    // segment is not an index
                    const { subElement, clearPath, pathSegments } = handleStringSegment(segment, currentElement);
                    result.subElement = subElement;
                    path = clearPath ? [] : [...path, ...(pathSegments ?? [])];
                }
                else if (indexedSubElementName !== null) {
                    // segment is an index - find sub element with specific name
                    result = findSubElement(currentElement, indexedSubElementName, Number(segment));
                    indexedSubElementName = undefined;
                }
                break;
        }
        if (result?.subElementIndex >= 0) {
            path.push('content', result.subElementIndex.toString());
        }
        if (result?.subElement) {
            currentElement = result.subElement;
        }
    });
    return path.join('/');
}
exports.convertPointerInAnnotationToInternal = convertPointerInAnnotationToInternal;
function handleExpressionValueSegment(currentElement, valueType) {
    if (valueType === undefined) {
        return [];
    }
    if (currentElement.attributes[valueType]) {
        return ['attributes', valueType];
    }
    const elementIndex = currentElement.content.findIndex((element) => element.type === odata_annotation_core_types_1.ELEMENT_TYPE && element.name === valueType);
    if (elementIndex !== -1) {
        return ['content', elementIndex.toString()];
    }
    return [];
}
function handleStringSegment(segment, currentElement) {
    if (expressions_1.expressionNames[segment]) {
        // primitive type name; represented either as attribute or text sub node; should be the last segment
        return handleExpressionNameSegment(currentElement, segment);
    }
    else if (currentElement.attributes[firstCharToUpper(segment)]) {
        // can be qualifier, term, type: all are EDMX attribute names
        return { pathSegments: ['attributes', firstCharToUpper(segment), 'value'] };
    }
    else if (segment === 'name') {
        // propertyValue.name is value of EDMX attribute 'Property'
        return { pathSegments: ['attributes', "Property" /* Edm.Property */, 'value'] };
    }
    else {
        return { clearPath: true };
    }
}
function handleExpressionNameSegment(currentElement, segment) {
    if (currentElement?.attributes[segment]) {
        // primitive type name represented as attribute
        return { pathSegments: ['attributes', segment, 'value'] };
    }
    if (currentElement.name === segment) {
        // point to first text node
        const firstTextNodeIndex = getFirstTextNodeIndex(currentElement);
        if (firstTextNodeIndex < 0) {
            return { clearPath: true };
        }
        else {
            return { pathSegments: ['content', firstTextNodeIndex.toString()] };
        }
    }
    // find sub node representing primitive value and point to it's first text node
    const { subElement, subElementIndex } = findSubElement(currentElement, segment, 0);
    if (subElementIndex < 0) {
        return { clearPath: true, subElement };
    }
    // subElementIndex found
    const pathSegments = ['content', subElementIndex.toString()];
    const firstTextNodeIndex = getFirstTextNodeIndex(currentElement.content[subElementIndex]);
    if (firstTextNodeIndex < 0) {
        return { clearPath: true, subElement };
    }
    pathSegments.push('content', firstTextNodeIndex.toString());
    return { subElement, pathSegments };
}
function getFirstTextNodeIndex(element) {
    return element.content.findIndex((subNode) => subNode.type === odata_annotation_core_types_1.TEXT_TYPE);
}
function findSubElement(element, subElementName, occurrence) {
    const result = {
        subElementIndex: -1
    };
    let currentMatchIndex = -1;
    for (let index = 0; index < element.content.length; index++) {
        const child = element.content[index];
        if (child.type === odata_annotation_core_types_1.ELEMENT_TYPE && (!subElementName || child.name === subElementName)) {
            currentMatchIndex++;
            if (currentMatchIndex === occurrence) {
                result.subElement = child;
                result.subElementIndex = index;
            }
        }
    }
    return result;
}
function firstCharToUpper(source) {
    let out = source;
    if (source) {
        out = source.slice(0, 1).toUpperCase() + source.slice(1);
    }
    return out;
}
//# sourceMappingURL=pointer.js.map