import type { Editor } from 'mem-fs-editor';
import type { RawMetadata } from '@sap-ux/vocabularies-types';
import type { Project } from '@sap-ux/project-access';
import { VocabularyService } from '@sap-ux/odata-vocabularies';
import type { MetadataService } from '@sap-ux/odata-entity-model';
import type { AnnotationListWithOrigins } from './avt';
import type { AnnotationFileChange, AnnotationServiceAdapter, Change, ProjectInfo, TextFile } from './types';
import { ChangeConverter } from './change-converter';
export interface FioriAnnotationServiceConstructor<T> {
    new (vocabularyAPI: VocabularyService, adapter: AnnotationServiceAdapter, changeConverter: ChangeConverter, fs: Editor, options: FioriAnnotationServiceOptions, project: Project, serviceName: string, appName: string): T;
}
export interface FioriAnnotationServiceOptions {
    commitOnSave: boolean;
    clearFileResolutionCache: boolean;
}
export declare const COMPILE_ERROR_MSG = "Update rejected due to changes leading to compile errors";
/**
 * Service for working with OData annotations in SAP Fiori Elements applications.
 *
 */
export declare class FioriAnnotationService {
    protected vocabularyAPI: VocabularyService;
    protected adapter: AnnotationServiceAdapter;
    protected changeConverter: ChangeConverter;
    protected fs: Editor;
    protected options: FioriAnnotationServiceOptions;
    protected serviceName: string;
    protected changes: Change[];
    protected fileMergeMaps: Record<string, Record<string, string>>;
    protected fileCache: Map<string, string>;
    protected isInitialSyncCompleted: boolean;
    protected projectInfo: ProjectInfo;
    /**
     * For creating new instances use the factory function {@link FioriAnnotationService.createService}.
     *
     * @param vocabularyAPI - Vocabulary API instance.
     * @param adapter - Language specific adapter.
     * @param changeConverter ChangeConverter instance.
     * @param fs - `mem-fs-editor` instance.
     * @param options - API configuration.
     * @param project - Project structure.
     * @param serviceName - Name of the service.
     * @param appName - Name of the application
     */
    constructor(vocabularyAPI: VocabularyService, adapter: AnnotationServiceAdapter, changeConverter: ChangeConverter, fs: Editor, options: FioriAnnotationServiceOptions, project: Project, serviceName: string, appName: string);
    /**
     * Creates new FioriAnnotationService instance for the given Fiori application.
     *
     * @param this - Constructor
     * @param project - Project structure.
     * @param serviceName - Name of the service used by the app.
     * @param appName - Name of the application.
     * @param fs - Optional `mem-fs-editor` instance.
     * @param options - API configuration.
     * @returns FioriAnnotationService instance.
     */
    static createService<T extends FioriAnnotationService>(this: FioriAnnotationServiceConstructor<T>, project: Project, serviceName: string, appName: string, fs?: Editor, options?: Partial<FioriAnnotationServiceOptions>): Promise<T>;
    /**
     * Returns a metadata service instance.
     *
     * @returns Metadata service instance.
     */
    getMetadataService(): MetadataService;
    /**
     * Returns a vocabulary service instance.
     *
     * @returns Vocabulary service instance.
     */
    getVocabularyAPI(): VocabularyService;
    /**
     * Returns a list of files which describe the service. The order is from least important to the most important file
     * Annotations defined in the last file would overwrite the ones defined in the previous ones.
     * You can only create changes for files which are not marked as `readOnly`.
     *
     * @param [includeGhostFiles] - If set to true will also include ghost files.
     * @returns Text files.
     */
    getAllFiles(includeGhostFiles?: boolean): TextFile[];
    /**
     * Refreshes file content from the file system.
     */
    sync(): Promise<void>;
    /**
     * Provides initial annotation file content.
     *
     * @param filePath - Path to the newly created file.
     * @returns Annotation file content.
     */
    getInitialFileContent(filePath: string): string;
    /**
     * Reads annotations for a specific service in an application.
     *
     * @returns Service metadata in AVT format.
     */
    getSchema(): RawMetadata;
    /**
     * Add change(s) to the stack.
     *
     * @param change - Pending changes.
     */
    edit(change: Change | Change[]): void;
    /**
     * Applies the collected changes to the file system.
     *
     * @param options Save options
     * @returns number of files changed.
     */
    save(options?: SaveOptions): Promise<{
        files: number;
    }>;
    /**
     * Utility function: serialize target with annotations.
     *
     * @param targetAnnotations - Annotations that will be serialized.
     * @param fileUri - use alias information from this file; if none provided, use default aliases for vocabularies, non for metadata
     * @returns Annotations serialized as string for the specified language.
     */
    serializeTarget(targetAnnotations: AnnotationListWithOrigins, fileUri?: string): string;
    /**
     * Converts changes to the internal annotation file change format.
     *
     * @param changes - Changes in AVT format.
     * @returns Changes in internal format.
     */
    protected convertChanges(changes: Change[]): AnnotationFileChange[];
    private saveFile;
    private commit;
}
export interface SaveOptions {
    /**
     * After saving file the internal data structures will be refreshed with the updated file content.
     * Useful if you want to continue using the service instance after save.
     */
    resyncAfterSave?: boolean;
}
//# sourceMappingURL=fiori-service.d.ts.map