"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getItems = exports.getChildCount = exports.getGhostFileDocument = exports.getDocument = exports.CDS_DOCUMENT_TYPE = void 0;
const url_1 = require("url");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const cds_odata_annotation_converter_1 = require("@sap-ux/cds-odata-annotation-converter");
const utils_1 = require("../utils");
const comments_1 = require("./comments");
exports.CDS_DOCUMENT_TYPE = 'document';
/**
 * Creates CDS document.
 *
 * @param serviceName - Name of the service.
 * @param vocabularyService - Vocabulary API.
 * @param facade - CDS compiler facade instance.
 * @param fileCache - File content cache.
 * @param file - File
 * @param metadataCollector - Metadata collector instance.
 * @returns CDS document.
 */
function getDocument(serviceName, vocabularyService, facade, fileCache, file, metadataCollector) {
    const comments = getComments(fileCache, file, facade, false);
    const cdsAnnotationFile = (0, cds_odata_annotation_converter_1.toTargetMap)(facade.blitzIndex.forUri(file.uri), file.uri, vocabularyService, facade);
    const tokens = facade.getTokensForUri((0, utils_1.pathFromUri)(file.uri));
    const line = fileCache.get(file.uri)?.split('\n').length ?? 0;
    const character = fileCache.get(file.uri)?.split('\n').pop()?.length ?? 0;
    const range = odata_annotation_core_types_1.Range.create(0, 0, line, character);
    const cdsDocument = {
        type: 'document',
        uri: file.uri,
        range,
        namespace: cdsAnnotationFile.namespace,
        references: cdsAnnotationFile.references,
        targets: [...(cdsAnnotationFile.targetMap || [])].map(([, value]) => value)
    };
    const annotationFile = (0, cds_odata_annotation_converter_1.toAnnotationFile)(file.uri, vocabularyService, cdsAnnotationFile, metadataCollector).file;
    filterTargets(serviceName, annotationFile);
    return {
        uri: file.uri,
        comments,
        ast: cdsDocument,
        annotationFile: annotationFile,
        tokens
    };
}
exports.getDocument = getDocument;
function getComments(fileCache, file, facade, ignoreComments = true) {
    const content = fileCache.get(file.uri);
    if (content === undefined || content === null) {
        throw new Error(`File ${file.uri} not found in cache!`);
    }
    const tokenVector = facade.getTokensForUri((0, url_1.fileURLToPath)(file.uri));
    return ignoreComments ? [] : (0, comments_1.collectComments)(tokenVector);
}
/**
 * Creates ghost file document.
 *
 * @param serviceName - Name of the service.
 * @param vocabularyService - Vocabulary API.
 * @param facade - CDS compiler facade instance.
 * @param fileCache - File content cache.
 * @param file - File
 * @param metadataCollector - Metadata collector instance.
 * @param propagatedTargetMap - Propagation map.
 * @returns Ghost file document.
 */
function getGhostFileDocument(serviceName, vocabularyService, facade, fileCache, file, metadataCollector, propagatedTargetMap) {
    const comments = getComments(fileCache, file, facade, false);
    const tokens = facade.getTokensForUri((0, utils_1.pathFromUri)(file.uri));
    const cdsAnnotationFile = (0, cds_odata_annotation_converter_1.toTargetMap)(facade.blitzIndex.forUri(file.uri), file.uri, vocabularyService, facade);
    const annotationFile = (0, cds_odata_annotation_converter_1.toAnnotationFile)(file.uri, vocabularyService, cdsAnnotationFile, metadataCollector, undefined, propagatedTargetMap).file;
    filterTargets(serviceName, annotationFile);
    annotationFile.uri = '!' + annotationFile.uri;
    const cdsDocument = {
        type: 'document',
        uri: annotationFile.uri,
        namespace: cdsAnnotationFile.namespace,
        references: cdsAnnotationFile.references,
        targets: [...(cdsAnnotationFile.targetMap || [])].map(([, value]) => value)
    };
    return {
        uri: annotationFile.uri,
        comments,
        tokens,
        ast: cdsDocument,
        annotationFile: annotationFile
    };
}
exports.getGhostFileDocument = getGhostFileDocument;
function filterTargets(serviceName, annotationFile) {
    // only allow targets pointing to current service
    const serviceNamespace = annotationFile.namespace?.name === serviceName ? annotationFile.namespace : undefined;
    const aliasName = serviceNamespace ? serviceNamespace.alias : '';
    annotationFile.targets = annotationFile.targets.filter((target) => target.name.startsWith(serviceName + '.') || (aliasName && target.name.startsWith(aliasName + '.')));
}
/**
 * Returns the number of children in the container node.
 *
 * @param container - Container AST node.
 * @returns Number of children.
 */
function getChildCount(container) {
    return getItems(container).length;
}
exports.getChildCount = getChildCount;
/**
 * Returns child nodes for the given container node.
 *
 * @param container - Container AST node.
 * @returns All child nodes of the container.
 */
function getItems(container) {
    switch (container.type) {
        case 'target':
            return container.assignments;
        case 'record':
            return container.annotations?.length
                ? [...container.properties, ...container.annotations].sort(utils_1.compareByRange)
                : container.properties;
        case 'annotation-group-items':
        case 'collection':
            return container.items;
        default:
            return [];
    }
}
exports.getItems = getItems;
//# sourceMappingURL=document.js.map