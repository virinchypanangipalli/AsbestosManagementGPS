"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMissingRefs = exports.resolvePath = exports.isAvailable = void 0;
const url_1 = require("url");
const path_1 = require("path");
const os_1 = require("os");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const error_1 = require("../error");
const utils_1 = require("./utils");
function buildDefinitionIndex(metadataService, files) {
    /**
     * Mapping annotation path to file uri where the annotation is defined
     */
    const definitionIndex = new Map();
    const virtualProperties = new Map();
    for (const file of files) {
        for (const target of file.targets) {
            const metadataElement = metadataService.getMetadataElement(target.name);
            if (!metadataElement) {
                continue;
            }
            buildDefinitionIndexForTarget(definitionIndex, virtualProperties, metadataElement, target, file.uri);
        }
    }
    return { definitionIndex, virtualProperties };
}
function buildDefinitionIndexForTarget(definitionIndex, virtualProperties, metadataElement, target, fileUri) {
    for (const annotation of target.terms) {
        const qualifier = annotation.attributes["Qualifier" /* Edm.Qualifier */]?.value;
        const termName = annotation.attributes["Term" /* Edm.Term */].value;
        const suffix = qualifier ? `#${qualifier}` : '';
        const path = `${metadataElement.path}/@${termName}${suffix}`;
        if (annotation.range) {
            // only consider previously existing annotations
            registerReference(definitionIndex, fileUri, path);
            collectAnnotations(definitionIndex, fileUri, path, annotation);
            if (termName === 'Analytics.AggregatedProperties') {
                const collection = annotation.content.find((element) => element.type === odata_annotation_core_types_1.ELEMENT_TYPE && element.name === "Collection" /* Edm.Collection */);
                if (!collection) {
                    continue;
                }
                collectVirtualProperties(virtualProperties, fileUri, metadataElement, collection);
            }
        }
    }
}
function collectVirtualProperties(virtualProperties, fileUri, metadataElement, collection) {
    for (const record of collection.content) {
        if (record.type === odata_annotation_core_types_1.ELEMENT_TYPE && record.name === "Record" /* Edm.Record */) {
            const nameElement = record.content.find((element) => element.type === odata_annotation_core_types_1.ELEMENT_TYPE &&
                element.name === "PropertyValue" /* Edm.PropertyValue */ &&
                element.attributes["Property" /* Edm.Property */]?.value === 'Name');
            if (nameElement) {
                const valueElement = nameElement.content.find((element) => element.type === odata_annotation_core_types_1.ELEMENT_TYPE && element.name === "String" /* Edm.String */);
                if (valueElement) {
                    const textNode = valueElement.content.find((element) => element.type === odata_annotation_core_types_1.TEXT_TYPE);
                    virtualProperties.set(`${metadataElement.path}/${textNode?.text}`, fileUri);
                }
            }
        }
    }
}
function collectAnnotations(definitionIndex, fileUri, prefix, element) {
    for (const child of element.content) {
        if (child.type !== 'element') {
            continue;
        }
        if (child.name === "Annotation" /* Edm.Annotation */) {
            traverseAnnotation(definitionIndex, fileUri, prefix, child);
        }
        else if (child.name === "Record" /* Edm.Record */) {
            traverseRecord(definitionIndex, fileUri, prefix, child);
        }
        else if (child.name === "Collection" /* Edm.Collection */) {
            traverseCollection(definitionIndex, fileUri, prefix, child);
        }
    }
}
function traverseCollection(definitionIndex, fileUri, prefix, collection) {
    const elements = collection.content.filter((node) => node.type === odata_annotation_core_types_1.ELEMENT_TYPE);
    for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        const path = `${prefix}/${i.toString()}`;
        if (element.range) {
            // only consider previously existing annotations
            registerReference(definitionIndex, fileUri, path);
            for (const grandChild of element.content) {
                if (grandChild.type === 'element') {
                    collectAnnotations(definitionIndex, fileUri, path, grandChild);
                }
            }
        }
    }
}
function traverseRecord(definitionIndex, fileUri, prefix, element) {
    for (const property of element.content) {
        if (property.type !== 'element' || property.name !== "PropertyValue" /* Edm.PropertyValue */) {
            continue;
        }
        const name = property.attributes["Property" /* Edm.Property */]?.value;
        const suffix = name ?? '';
        const path = `${prefix}/${suffix}`;
        if (element.range) {
            // only consider previously existing annotations
            registerReference(definitionIndex, fileUri, path);
            for (const grandChild of property.content) {
                if (grandChild.type === 'element') {
                    collectAnnotations(definitionIndex, fileUri, path, grandChild);
                }
            }
        }
    }
}
function traverseAnnotation(definitionIndex, fileUri, prefix, element) {
    const qualifier = element.attributes["Qualifier" /* Edm.Qualifier */]?.value;
    const suffix = qualifier ? `#${qualifier}` : '';
    const path = `${prefix}@${element.attributes["Term" /* Edm.Term */].value}${suffix}`;
    if (element.range) {
        // only consider previously existing annotations
        registerReference(definitionIndex, fileUri, path);
        collectAnnotations(definitionIndex, fileUri, path, element);
    }
}
function registerReference(definitionIndex, fileUri, path) {
    const entry = definitionIndex.get(path);
    // We can't point to ghost files, we need to use the real url
    const normalizedUri = fileUri.startsWith(odata_annotation_core_types_1.GHOST_FILENAME_PREFIX) ? fileUri.substring(1) : fileUri;
    if (entry) {
        entry.push(normalizedUri);
    }
    else {
        definitionIndex.set(path, [normalizedUri]);
    }
}
function getPathsInElement(element, basePath) {
    const paths = [];
    // add all paths in attributes
    Object.keys(element.attributes || {}).forEach((attrName) => {
        if (attrName.indexOf('Path') >= 0) {
            let path = element.attributes[attrName].value;
            if (!path.startsWith('/')) {
                path = basePath + '/' + path;
            }
            paths.push({ path });
        }
    });
    // add all paths from content
    (element.content || []).forEach((entry) => {
        if (entry.type === 'text' && element.name.indexOf('Path') >= 0) {
            let path = entry.text;
            if (!path.startsWith('/')) {
                path = basePath + '/' + path;
            }
            paths.push({ path });
        }
        else if (entry.type === 'element') {
            paths.push(...getPathsInElement(entry, basePath));
        }
    });
    return paths;
}
function getPathsInTarget(target, metadata, aliasInfo) {
    const paths = [];
    paths.push({ path: target.name });
    // find base path (for relative paths in annotation value) for target
    const pathBaseMdElement = (0, odata_annotation_core_1.getPathBaseMetadataElement)(metadata, target.name, aliasInfo);
    const pathBase = pathBaseMdElement?.path ?? target.name;
    target.terms.forEach((term) => {
        getPathsInAnnotation(term, paths, target.name, pathBase);
    });
    return paths;
}
function getPathsInAnnotation(element, paths, targetName, pathBase) {
    // new target term qualifier combination in this file ? then avoid duplicates in unrelated layers!
    const termName = (0, odata_annotation_core_1.getElementAttributeValue)(element, "Term" /* Edm.Term */);
    const qualifier = (0, odata_annotation_core_1.getElementAttributeValue)(element, "Qualifier" /* Edm.Qualifier */);
    // new target/term/qualifier: add path pointing to this term, then using statement will be created if this combination exists elsewhere
    paths.push({
        path: targetName + '/@' + termName + (qualifier ? '#' + qualifier : ''),
        forOverriding: true
    });
    paths.push(...getPathsInElement(element, pathBase));
}
function addAvailableNamespaces(fileUri, namespaceMap, projectRoot, documents, fileUrisDone = new Set()) {
    if (!fileUrisDone.has(fileUri)) {
        fileUrisDone.add(fileUri);
        let filePath = (0, url_1.pathToFileURL)((0, path_1.join)(projectRoot, fileUri)).toString();
        if ((0, os_1.platform)() === 'win32' && !documents.has(filePath)) {
            // we can't find the document by uri, it is likely that the drive letter case does not match
            // temporary workaround, this should not be needed once URIs are used everywhere
            let driveLetter = filePath[8];
            if (driveLetter === driveLetter.toLowerCase()) {
                driveLetter = driveLetter.toUpperCase();
            }
            else {
                driveLetter = driveLetter.toLowerCase();
            }
            filePath = filePath.slice(0, 8) + driveLetter + filePath.slice(9);
        }
        const annotationFileInternal = documents.get(filePath)?.annotationFile;
        if (annotationFileInternal) {
            const references = annotationFileInternal.references;
            references
                .filter((reference) => !!reference?.uri)
                .forEach((reference) => {
                const refUri = reference?.uri;
                if (refUri) {
                    const relativeString = (0, path_1.relative)(projectRoot, refUri);
                    namespaceMap.set(reference.name + '|' + relativeString, {
                        uri: refUri,
                        name: reference.name,
                        type: 'reference'
                    });
                    addAvailableNamespaces(relativeString, namespaceMap, projectRoot, documents, fileUrisDone);
                }
            });
        }
    }
}
/**
 *
 * @param projectRoot - Absolute path to the projects root.
 * @param references - Reference objects.
 * @param relativePath - Relative file path to be checked.
 * @param name - Name of the imported object.
 * @returns If the given reference is available in the document.
 */
const isAvailable = (projectRoot, references, relativePath, name) => {
    const matchedReferences = references.filter((reference) => {
        let absoluteUri = (0, path_1.join)(projectRoot, relativePath ?? '');
        if (absoluteUri && process.platform === 'win32') {
            absoluteUri = absoluteUri.charAt(0).toUpperCase() + absoluteUri.slice(1);
        }
        if (!reference.uri || reference.uri !== absoluteUri) {
            return false; // different file
        }
        else if (reference.name && name && !name.startsWith(reference.name)) {
            return false; // imported namespace does not include requested name
        }
        else {
            return true;
        }
    });
    return matchedReferences.length > 0;
};
exports.isAvailable = isAvailable;
/**
 * Converts path to namespace qualified path.
 *
 * @param path - Input path value.
 * @param aliasInfo - Documents alias information.
 * @returns Namespace qualified path.
 */
function resolvePath(path, aliasInfo) {
    const segments = path.split('/');
    const segmentsNoAlias = segments.map((segment) => (0, odata_annotation_core_1.getSegmentWithoutAlias)(aliasInfo, segment));
    return segmentsNoAlias.join('/');
}
exports.resolvePath = resolvePath;
function checkSegments(fileUri, references, missingReferences, segments, metadataService, projectRoot) {
    let currentMdElementPath;
    for (const segment of segments) {
        let metadataElement = metadataService.getMetadataElement(segment);
        if (currentMdElementPath) {
            metadataElement = metadataService.getMetadataElement(currentMdElementPath + '/' + segment);
        }
        if (!metadataElement) {
            break;
        }
        currentMdElementPath = metadataElement.path;
        const importUri = metadataElement.importUri;
        if (![fileUri, undefined].includes(importUri) &&
            !(0, exports.isAvailable)(projectRoot, references, metadataElement?.importUri, metadataElement.originalName)) {
            missingReferences.add(importUri);
        }
        if (metadataService.getEdmTargetKinds(currentMdElementPath).includes('NavigationProperty')) {
            // navigation property : continue with target entity
            const structuredType = metadataElement?.structuredType;
            currentMdElementPath = structuredType ? metadataService.getMetadataElement(structuredType)?.path : '';
        }
    }
    return currentMdElementPath;
}
function checkMetadataDefinitions(fileUri, aliasInfo, references, missingReferences, virtualProperties, entry, metadataService, projectRoot) {
    const atIndex = entry.path.indexOf('@');
    // check path segments involving only metadata
    const metadataPath = atIndex >= 0 ? entry.path.substring(0, Math.max(0, atIndex - 1)) : entry.path;
    const fullyQualifiedPath = resolvePath(metadataPath, aliasInfo);
    const metadataSegments = fullyQualifiedPath.split('/');
    const virtualPropertyUri = virtualProperties.get(fullyQualifiedPath);
    if (virtualPropertyUri &&
        !(0, exports.isAvailable)(projectRoot, references, (0, path_1.relative)(projectRoot, (0, url_1.fileURLToPath)(virtualPropertyUri)), fullyQualifiedPath)) {
        missingReferences.add(virtualPropertyUri);
    }
    const currentMdElementPath = checkSegments(fileUri, references, missingReferences, metadataSegments, metadataService, projectRoot);
    let result;
    if (atIndex !== -1) {
        const termCast = entry.path.slice(atIndex - 1);
        const target = entry.forOverriding ? fullyQualifiedPath : currentMdElementPath;
        result = `${target}${termCast}`;
    }
    return result;
}
/**
 * Get all missing references for target and its annotations.
 *
 * @param documents - URI to Document map.
 * @param fileUri - Identification of current file (relative to project root).
 * @param targetName - Annotation target name.
 * @param targetOrElement - Internal representation of the target or subtree element.
 * @param aliasInfo - Alias information for the document.
 * @param metadataService - Metadata service.
 * @param projectInfo - Data about applications in the project.
 * @returns A set of missing references in the document.
 */
function getMissingRefs(documents, fileUri, targetName, targetOrElement, aliasInfo, metadataService, projectInfo) {
    const relativePath = (0, path_1.relative)(projectInfo.projectRoot, (0, url_1.fileURLToPath)(fileUri));
    const { appName, apps, projectRoot } = projectInfo;
    const missingReferences = new Set();
    // get all paths contained in target and its annotations
    let paths = [];
    if (targetOrElement.type === 'target') {
        paths = getPathsInTarget(targetOrElement, metadataService, aliasInfo);
    }
    else {
        const pathBaseMdElement = (0, odata_annotation_core_1.getPathBaseMetadataElement)(metadataService, targetName, aliasInfo);
        const pathBase = pathBaseMdElement?.path ?? targetName;
        if (targetOrElement.name === "Annotation" /* Edm.Annotation */) {
            getPathsInAnnotation(targetOrElement, paths, targetName, pathBase);
        }
        else {
            paths = getPathsInElement(targetOrElement, pathBase);
        }
    }
    // get all namespaces available for current file
    const nameSpacesMap = new Map();
    addAvailableNamespaces(relativePath, nameSpacesMap, projectRoot, documents);
    const references = [...nameSpacesMap.values()];
    const annotationFiles = [...documents].map(([, document]) => document.annotationFile).reverse();
    const { definitionIndex, virtualProperties } = buildDefinitionIndex(metadataService, annotationFiles);
    for (const entry of paths) {
        const annotationPath = checkMetadataDefinitions(relativePath, aliasInfo, references, missingReferences, virtualProperties, entry, metadataService, projectRoot);
        const uris = findDefinitionForEntry(projectRoot, definitionIndex, annotationPath);
        const addToMissing = hasMissingUri(uris, relativePath, references, projectRoot);
        // if not: collect as missing using statement
        if (!addToMissing) {
            continue;
        }
        const missingUri = uris[0];
        const unifiedMissingUri = (0, utils_1.toUnifiedUri)(missingUri);
        const crossAppFolder = getCrossAppFolder(unifiedMissingUri, appName, apps);
        if (crossAppFolder && entry.forOverriding) {
            // cross app using statement needed for overriding annotation: this will most likely cause cds compiler error -> throw exception
            const message = `Aborted to avoid cross app using statement in '${relativePath}' pointing to '${crossAppFolder}'`;
            throw new error_1.ApiError(message, error_1.ApiErrorCode.General);
        }
        if (!crossAppFolder) {
            // no cross app using statements allowed - ignore missing reference required for referenced path in annotation (we tolerate potential warning message)
            missingReferences.add(missingUri);
        }
    }
    return missingReferences;
}
exports.getMissingRefs = getMissingRefs;
function findDefinitionForEntry(projectRoot, definitionIndex, annotationPath) {
    const uris = [];
    if (annotationPath) {
        const references = definitionIndex.get(annotationPath);
        if (references) {
            const relativePath = (0, path_1.relative)(projectRoot, (0, url_1.fileURLToPath)(references[0]));
            uris.push(relativePath);
        }
    }
    return uris;
}
function getCrossAppFolder(uri, appName, apps) {
    let crossAppFolder = '';
    if (!isSubDirectory((0, utils_1.toUnifiedUri)(`${appName}/`), uri)) {
        (apps || []).forEach((appFolder) => {
            if (isSubDirectory((0, utils_1.toUnifiedUri)(`${appFolder}/`), uri)) {
                crossAppFolder = appFolder;
            }
        });
    }
    return crossAppFolder;
}
function isSubDirectory(parent, child) {
    const relativePath = (0, path_1.relative)(parent, child);
    return !!(relativePath && !relativePath.startsWith('..') && !(0, path_1.isAbsolute)(relativePath));
}
function hasMissingUri(uris, fileUri, references, projectRoot) {
    if (uris.length === 0) {
        return false;
    }
    for (const uri of uris) {
        if (uri === fileUri || (0, exports.isAvailable)(projectRoot, references, uri)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=references.js.map