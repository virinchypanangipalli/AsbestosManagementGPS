"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAnnotationFromAssignment = exports.getTokenRange = exports.toUnifiedUri = void 0;
const ux_cds_compiler_facade_1 = require("@sap/ux-cds-compiler-facade");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const cds_annotation_parser_1 = require("@sap-ux/cds-annotation-parser");
const cds_odata_annotation_converter_1 = require("@sap-ux/cds-odata-annotation-converter");
const error_1 = require("../error");
/**
 *  Normalizes URI.
 *
 * @param fileUri - URI as a string.
 * @param removeGhostFilePrefix - Flag indicating if the ghost file prefix should be removed from the uri.
 * @returns Normalized file URI.
 */
function toUnifiedUri(fileUri, removeGhostFilePrefix = true) {
    const unifiedUri = (fileUri ?? '').replace(/\\/g, '/').replace(/\/\//g, '/');
    return removeGhostFilePrefix ? unifiedUri.replace(odata_annotation_core_types_1.GHOST_FILENAME_PREFIX, '') : unifiedUri;
}
exports.toUnifiedUri = toUnifiedUri;
/**
 * Get token indices for the corresponding range.
 *
 * @param tokens - All tokens in the document.
 * @param range - Range for which tokens will be matched.
 * @returns Start and end token indices for the range.
 */
function getTokenRange(tokens, range) {
    const start = tokens.findIndex((token) => token.line === range.start.line + 1 && token.column === range.start.character);
    let end = -1;
    if (start > -1) {
        end = tokens
            .slice(start)
            .findIndex((token) => token.line > range.end.line + 1 ||
            (token.line === range.end.line + 1 && token.column >= range.end.character));
        end = start + end - 1;
    }
    return { start, end };
}
exports.getTokenRange = getTokenRange;
/**
 * Finds annotation in assignment based on AST node.
 *
 * @param facade - CDS compiler facade instance.
 * @param node - AST node.
 * @param parent - Parent AST node.
 * @param greatGrandParent - Great grand parent node.
 * @returns Annotation node and EDMX path.
 */
function getAnnotationFromAssignment(facade, node, parent, greatGrandParent) {
    const [annotation, target] = findAnnotation(node, parent, greatGrandParent);
    const { edmxPath } = facade.collectMetadataForAbsolutePath(target.name, target.kind, (0, ux_cds_compiler_facade_1.createMetadataCollector)(new Map(), facade));
    return [annotation, edmxPath];
}
exports.getAnnotationFromAssignment = getAnnotationFromAssignment;
function findAnnotation(node, parent, greatGrandParent) {
    if (node.type === cds_odata_annotation_converter_1.TARGET_TYPE) {
        // if no assignment is specified we default to the first one
        const assignment = node.assignments[0];
        if (assignment) {
            const annotation = assignment?.type === 'annotation-group' ? assignment.items.items[0] : assignment;
            return [annotation, node];
        }
    }
    else if (node?.type === cds_annotation_parser_1.ANNOTATION_TYPE) {
        if (parent?.type === cds_odata_annotation_converter_1.TARGET_TYPE) {
            return [node, parent];
        }
        else if (greatGrandParent?.type === cds_odata_annotation_converter_1.TARGET_TYPE && parent?.type === cds_annotation_parser_1.ANNOTATION_GROUP_ITEMS_TYPE) {
            return [node, greatGrandParent];
        }
    }
    throw new error_1.ApiError(`Could not find annotation in node of type ${node.type}.`, error_1.ApiErrorCode.General);
}
//# sourceMappingURL=utils.js.map