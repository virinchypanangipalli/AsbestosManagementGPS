"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CDSAnnotationServiceAdapter = void 0;
const url_1 = require("url");
const path_1 = require("path");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const ux_cds_compiler_facade_1 = require("@sap/ux-cds-compiler-facade");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const odata_entity_model_1 = require("@sap-ux/odata-entity-model");
const cds_annotation_parser_1 = require("@sap-ux/cds-annotation-parser");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const cds_odata_annotation_converter_1 = require("@sap-ux/cds-odata-annotation-converter");
const types_1 = require("../types");
const error_1 = require("../error");
const writer_1 = require("./writer");
const references_1 = require("./references");
const vocabularies_1 = require("../vocabularies");
const document_1 = require("./document");
const pointer_1 = require("./pointer");
const utils_1 = require("../utils");
const change_1 = require("./change");
const internal_change_1 = require("../types/internal-change");
/**
 *
 */
class CDSAnnotationServiceAdapter {
    service;
    project;
    vocabularyService;
    appName;
    metadataService = new odata_entity_model_1.MetadataService();
    splitAnnotationSupport = true;
    fileCache;
    documents = new Map();
    metadata = [];
    missingReferences = {};
    /**
     *
     * @param service - CDS service structure.
     * @param project - Project structure.
     * @param vocabularyService - Vocabulary API.
     * @param appName - Name of the application.
     */
    constructor(service, project, vocabularyService, appName) {
        this.service = service;
        this.project = project;
        this.vocabularyService = vocabularyService;
        this.appName = appName;
        this.fileCache = new Map();
        this._fileSequence = service.serviceFiles;
    }
    facade;
    setFileCache(fileCache) {
        this.fileCache = fileCache;
    }
    setFacade(facade) {
        this.facade = facade;
    }
    _compiledService;
    /**
     * @returns Compiled CDS service.
     */
    get compiledService() {
        if (!this._compiledService) {
            this._compiledService = this._getCompiledService();
        }
        return this._compiledService;
    }
    set compiledService(v) {
        this._compiledService = v;
    }
    _fileSequence;
    /**
     * Refreshes internal data structures from the provided project files.
     *
     * @param fileCache - File uri mapped to file content.
     * @returns Sync errors
     */
    async sync(fileCache) {
        const paths = [...this.service.serviceFiles.map((file) => (0, url_1.fileURLToPath)(file.uri))];
        const facade = await (0, ux_cds_compiler_facade_1.createCdsCompilerFacadeForRoot)(this.project.root, paths, fileCache);
        this.setFacade(facade);
        const compileErrors = facade.getCompilerErrors(this.project.root);
        const relevantErrors = [...compileErrors].filter(([file, compilerMessage]) => {
            return (compilerMessage.messages.filter((value) => value.severity === odata_annotation_core_types_1.DiagnosticSeverity.Error).length &&
                !file.startsWith('../'));
        });
        if (relevantErrors.length > 0) {
            // if model has compiler errors
            for (const [relativePath, compilerMessage] of relevantErrors) {
                console.log(`Compile errors in: ${relativePath}`);
                for (const [fileUri, content] of fileCache) {
                    if (fileUri.endsWith(relativePath)) {
                        console.log(content);
                    }
                }
                console.log(JSON.stringify(compilerMessage, undefined, 2));
            }
            return compileErrors;
        }
        this.documents.clear();
        this.invalidateCaches();
        this.updateFileSequence(facade);
        this.setFileCache(fileCache);
        const metadataElementMap = facade.getMetadata(this.service.serviceName);
        // We collect already full metadata from compile model, we don't need to build it based on paths.
        const metadataCollector = (0, ux_cds_compiler_facade_1.createMetadataCollector)(new Map(), facade);
        const { propagationMap, sourceUris } = facade.getPropagatedTargetMap(this.service.serviceName);
        for (const file of this.service.serviceFiles) {
            const document = (0, document_1.getDocument)(this.service.serviceName, this.vocabularyService, facade, fileCache, file, metadataCollector);
            this.documents.set(file.uri, document);
            // ghost files
            if (sourceUris.has((0, path_1.relative)(this.project.root, (0, url_1.fileURLToPath)(file.uri)))) {
                const ghostDoc = (0, document_1.getGhostFileDocument)(this.service.serviceName, this.vocabularyService, facade, fileCache, file, metadataCollector, propagationMap);
                this.documents.set(ghostDoc.annotationFile.uri, ghostDoc);
            }
        }
        const metadataElements = (0, ux_cds_compiler_facade_1.getMetadataElementsFromMap)(metadataElementMap);
        this.metadataService = new odata_entity_model_1.MetadataService({ uriMap: facade?.getUriMap() || new Map() });
        this.metadataService.import(metadataElements, 'DummyMetadataFileUri');
        return new Map();
    }
    /**
     * Returns all relevant service files.
     *
     * @param includeGhostFiles - Flag indicating if ghost files should be included.
     * @returns All relevant service files.
     */
    getAllFiles(includeGhostFiles) {
        if (includeGhostFiles) {
            const annotationFiles = [...this.compiledService.annotationFiles];
            annotationFiles.reverse();
            return annotationFiles.map((file) => ({
                uri: file.uri,
                isReadOnly: 
                // ghost files are readOnly and should not be in service files
                this.service.serviceFiles.find((serviceFile) => serviceFile.uri === file.uri)?.isReadOnly ?? true
            }));
        }
        return [...this.service.serviceFiles];
    }
    /**
     * Creates empty annotation file content for the given service.
     *
     * @param serviceName - Name of the service.
     * @param uri - URI for the new annotation file.
     * @returns New annotation file content.
     */
    getInitialFileContent(serviceName, uri) {
        if (this.facade) {
            const fileName = this.facade.getFileName(serviceName) ?? '';
            let path = (0, path_1.relative)((0, path_1.dirname)(uri), (0, path_1.join)(this.project.root, (0, path_1.dirname)(fileName))).replace(/\\/g, '/');
            path = (0, path_1.join)(path, (0, path_1.basename)(fileName, '.cds'));
            path = path.split(path_1.sep).join('/'); // always use '/' instead of platform specific separator
            return `using ${serviceName} as service from '${path}';\n`;
        }
        return '';
    }
    /**
     * Converts changes to workspace edits.
     *
     * @param changes - Internal changes.
     * @returns Workspace edits.
     */
    async getWorkspaceEdit(changes) {
        const workspaceChanges = {};
        this.clearState();
        const writers = new Map();
        for (const change of changes) {
            let writer = writers.get(change.uri);
            const document = this.documents.get(change.uri);
            const cachedFile = this.fileCache?.get(change.uri);
            if (!document || cachedFile === undefined || !this.facade) {
                continue;
            }
            if (!writer) {
                //writable cds document (augment)
                const textDocument = vscode_languageserver_textdocument_1.TextDocument.create(change.uri, 'cds', 0, cachedFile);
                writer = new writer_1.CDSWriter(this.facade, this.vocabularyService, document.ast, document.comments, document.tokens, textDocument, this.project.root, document.annotationFile);
                writers.set(change.uri, writer);
            }
            const changeHandler = this[change.type];
            changeHandler(writer, document, change);
        }
        for (const [uri, writer] of writers.entries()) {
            const document = this.documents.get(uri);
            if (!document) {
                continue;
            }
            this.processMissingReferences(uri, writer);
            const edits = await writer.getTextEdits();
            workspaceChanges[uri] = edits;
        }
        return {
            changes: workspaceChanges
        };
    }
    /**
     * Checks if there are no compile errors in the files after update.
     *
     * @param fileCache - Updated file content.
     * @returns Errors.
     */
    async validateChanges(fileCache) {
        return this.sync(fileCache);
    }
    /**
     * Converts annotation object to a string.
     *
     * @param target - Content of an 'Annotations' element.
     * @returns CDS representation of the annotations.
     */
    serializeTarget(target) {
        return (0, cds_odata_annotation_converter_1.printTarget)(target);
    }
    _getCompiledService() {
        const annotationFiles = [];
        for (const file of this._fileSequence ?? []) {
            const document = this.documents.get(file.uri);
            const ghostDocument = this.documents.get('!' + file.uri);
            if (ghostDocument) {
                annotationFiles.push(ghostDocument.annotationFile);
            }
            if (document) {
                annotationFiles.push(document.annotationFile);
            }
            else {
                throw new error_1.ApiError(`Could not compile service. Missing document ${file.uri}`, error_1.ApiErrorCode.General);
            }
        }
        annotationFiles.reverse();
        return Object.freeze({
            odataVersion: '4.0',
            annotationFiles,
            metadata: this.metadata
        });
    }
    clearState() {
        this.missingReferences = {};
    }
    invalidateCaches() {
        this._compiledService = undefined;
        this._fileSequence = undefined;
    }
    updateFileSequence(facade) {
        this._fileSequence = facade.getFileSequence().map((uri) => ({
            uri: (0, url_1.pathToFileURL)(uri).toString(),
            isReadOnly: uri.indexOf('node_modules') !== -1
        }));
        this.service.serviceFiles = [...this._fileSequence];
    }
    processMissingReferences(uri, writer) {
        const missingReferences = this.missingReferences[uri];
        if (missingReferences?.size) {
            const pointer = '/references';
            const normalizedReferences = [...missingReferences].map((reference) => {
                if (reference.startsWith('file://')) {
                    // uri => convert to relative path to root
                    const path = (0, utils_1.pathFromUri)(reference);
                    return (0, path_1.relative)(this.project.root, path);
                }
                else {
                    return reference;
                }
            });
            writer.addChange((0, change_1.createInsertReferenceChange)(pointer, normalizedReferences));
        }
    }
    addMissingReferences(uri, references) {
        const missingReferences = (this.missingReferences[uri] ??= new Set());
        for (const reference of references) {
            missingReferences.add(reference);
        }
    }
    [types_1.INSERT_TARGET] = (writer, document, change) => {
        const aliasInfo = getAliasInfo(document.annotationFile, this.metadataService, this.vocabularyService);
        const missingReferences = (0, references_1.getMissingRefs)(this.documents, change.uri, change.target.name, change.target, aliasInfo, this.metadataService, {
            apps: Object.keys(this.project.apps),
            projectRoot: this.project.root,
            appName: this.appName
        });
        this.addMissingReferences(document.uri, missingReferences);
        // This has to happen after getting refs, because currently it depends on OData path syntax
        const targetName = change.target.name;
        const pathSegments = targetName.split('/');
        const pathBase = pathSegments.shift() ?? '';
        const parsedName = (0, odata_annotation_core_1.parseIdentifier)(pathBase);
        const fullyQualifiedPath = (0, odata_annotation_core_1.toFullyQualifiedName)(aliasInfo.aliasMap, aliasInfo.currentFileNamespace, parsedName) ?? '';
        const metadataElement = this.metadataService.getMetadataElement(fullyQualifiedPath);
        let originalPathBase = metadataElement?.originalName ?? pathBase;
        if (parsedName.namespaceOrAlias !== undefined) {
            const namespace = aliasInfo.aliasMap[parsedName.namespaceOrAlias];
            if (namespace) {
                originalPathBase = originalPathBase.replace(namespace, parsedName.namespaceOrAlias);
            }
        }
        change.target.name = [originalPathBase, ...pathSegments].join('/');
        writer.addChange((0, change_1.createInsertTargetChange)('target', change.target));
    };
    [types_1.DELETE_ELEMENT] = (writer, document, change) => {
        const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        const [currentAstNode, parentAstNode] = (0, pointer_1.getAstNodesFromPointer)(document.ast, pointer).reverse();
        if (currentAstNode?.type === cds_annotation_parser_1.RECORD_PROPERTY_TYPE) {
            writer.addChange({
                type: 'delete-record-property',
                pointer: pointer
            });
        }
        else if (currentAstNode?.type === cds_annotation_parser_1.ANNOTATION_TYPE && parentAstNode.type === cds_annotation_parser_1.RECORD_TYPE) {
            // embedded annotation
            writer.addChange({
                type: 'delete-embedded-annotation',
                pointer: pointer
            });
        }
        else if (currentAstNode.type === cds_odata_annotation_converter_1.TARGET_TYPE) {
            writer.addChange({
                type: 'delete-target',
                pointer: pointer
            });
        }
        else if ((currentAstNode?.type === cds_annotation_parser_1.ANNOTATION_TYPE && parentAstNode.type === cds_odata_annotation_converter_1.TARGET_TYPE) ||
            (currentAstNode?.type === cds_annotation_parser_1.ANNOTATION_TYPE && parentAstNode.type === cds_annotation_parser_1.ANNOTATION_GROUP_ITEMS_TYPE)) {
            writer.addChange({
                type: 'delete-annotation',
                pointer: pointer,
                target: change.target
            });
        }
        else if (currentAstNode?.type === cds_annotation_parser_1.RECORD_TYPE) {
            writer.addChange({
                type: 'delete-record',
                pointer: pointer
            });
        }
        else if (currentAstNode.type === 'boolean' ||
            currentAstNode.type === 'string' ||
            currentAstNode.type === 'path' ||
            currentAstNode.type === 'enum' ||
            currentAstNode.type === 'token' ||
            currentAstNode.type === 'number') {
            writer.addChange({
                type: 'delete-primitive-value',
                pointer: pointer
            });
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer} `, error_1.ApiErrorCode.General);
        }
    };
    [types_1.INSERT_ELEMENT] = (writer, document, change) => {
        const { pointer, containsFlattenedNodes } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        const [currentAstNode] = (0, pointer_1.getAstNodesFromPointer)(document.ast, pointer).slice(-1);
        if (containsFlattenedNodes) {
            this.insertInFlattenedStructure(writer, document, change, pointer);
        }
        else if (currentAstNode.type === cds_odata_annotation_converter_1.TARGET_TYPE) {
            writer.addChange({
                type: 'insert-annotation',
                pointer: pointer,
                element: change.element
            });
        }
        else if (currentAstNode.type === cds_annotation_parser_1.ANNOTATION_TYPE) {
            this.insertAnnotation(writer, change, pointer);
        }
        else if (currentAstNode.type === cds_annotation_parser_1.RECORD_TYPE) {
            this.insertRecord(writer, change, pointer, currentAstNode);
        }
        else if (currentAstNode.type === cds_annotation_parser_1.RECORD_PROPERTY_TYPE) {
            if (utils_1.PRIMITIVE_TYPE_NAMES.includes(change.element.name)) {
                writer.addChange({
                    type: change_1.INSERT_PRIMITIVE_VALUE_TYPE,
                    pointer: pointer, // point to properties
                    element: change.element,
                    index: change.index
                });
            }
        }
        else if (currentAstNode.type === cds_annotation_parser_1.COLLECTION_TYPE) {
            if (change.element.name === "Record" /* Edm.Record */) {
                writer.addChange({
                    type: 'insert-record',
                    pointer: pointer,
                    element: change.element,
                    index: change.index
                });
            }
            else if (utils_1.PRIMITIVE_TYPE_NAMES.includes(change.element.name)) {
                writer.addChange({
                    type: change_1.INSERT_PRIMITIVE_VALUE_TYPE,
                    pointer: pointer,
                    element: change.element,
                    index: change.index
                });
            }
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer} ${change.element.name}`, error_1.ApiErrorCode.General);
        }
        const aliasInfo = getAliasInfo(document.annotationFile, this.metadataService, this.vocabularyService);
        const missingReferences = (0, references_1.getMissingRefs)(this.documents, change.uri, change.target, change.element, aliasInfo, this.metadataService, { apps: Object.keys(this.project.apps), projectRoot: this.project.root, appName: '' });
        this.addMissingReferences(document.uri, missingReferences);
    };
    insertInFlattenedStructure(writer, document, change, pointer) {
        const targetPointer = pointer.split('/').slice(0, 3).join('/');
        const termPointer = change.pointer.split('/').slice(0, 5).join('/');
        const annotationValuePointer = change.pointer.split('/').slice(5).join('/');
        const element = (0, utils_1.getGenericNodeFromPointer)(document.annotationFile, termPointer);
        if (element?.type === odata_annotation_core_types_1.ELEMENT_TYPE) {
            const annotation = buildAnnotation(element, annotationValuePointer, change.element);
            if (annotation) {
                writer.addChange({
                    type: 'insert-annotation',
                    element: annotation,
                    pointer: targetPointer
                });
            }
        }
    }
    insertAnnotation(writer, change, pointer) {
        // insert annotation value
        if (change.element.name === "Annotation" /* Edm.Annotation */) {
            writer.addChange((0, change_1.createInsertEmbeddedAnnotationChange)(pointer, change.element));
        }
        else if (change.element.name === "Collection" /* Edm.Collection */) {
            writer.addChange((0, change_1.createInsertCollectionChange)(pointer, change.element));
        }
        else if (change.element.name === "Record" /* Edm.Record */) {
            writer.addChange((0, change_1.createInsertRecordChange)(pointer, change.element));
        }
        else if (utils_1.PRIMITIVE_TYPE_NAMES.includes(change.element.name)) {
            writer.addChange((0, change_1.createInsertPrimitiveValueChange)(pointer, change.element));
        }
    }
    insertRecord(writer, change, pointer, record) {
        if (change.element.name === "PropertyValue" /* Edm.PropertyValue */) {
            const index = adaptRecordPropertyIndex(record, change.index);
            const modifiedPointer = [...pointer.split('/'), 'properties'].join('/'); // pointer is record
            writer.addChange((0, change_1.createInsertRecordPropertyChange)(modifiedPointer, change.element, index));
        }
        else if (change.element.name === "Annotation" /* Edm.Annotation */) {
            const index = adaptRecordPropertyIndex(record, change.index);
            writer.addChange((0, change_1.createInsertEmbeddedAnnotationChange)(pointer, change.element, index));
        }
        else if (change.element.name === "Record" /* Edm.Record */) {
            const segment = pointer.split('/');
            const changeIndex = parseInt(segment.pop() ?? '', 10);
            const modifiedPointer = segment.join('/'); //point to annotations
            writer.addChange((0, change_1.createInsertRecordChange)(modifiedPointer, change.element, changeIndex));
        }
    }
    [types_1.INSERT_ATTRIBUTE] = (writer, document, change) => {
        const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        const [currentAstNode] = (0, pointer_1.getAstNodesFromPointer)(document.ast, pointer).slice(-1);
        if (pointer) {
            if (currentAstNode.type === cds_annotation_parser_1.ANNOTATION_TYPE && change.name === "Qualifier" /* Edm.Qualifier */) {
                writer.addChange({
                    type: 'insert-qualifier',
                    pointer: pointer,
                    value: change.value
                });
            }
            if (currentAstNode.type === cds_annotation_parser_1.RECORD_PROPERTY_TYPE ||
                (currentAstNode.type === cds_annotation_parser_1.ANNOTATION_TYPE && change.name !== "Qualifier" /* Edm.Qualifier */)) {
                writer.addChange({
                    type: 'insert-primitive-value',
                    pointer: pointer,
                    element: (0, odata_annotation_core_types_1.createElementNode)({
                        name: change.name,
                        content: [(0, odata_annotation_core_types_1.createTextNode)(change.value)]
                    })
                });
            }
            if (currentAstNode.type === cds_annotation_parser_1.RECORD_TYPE && change.name === "Type" /* Edm.Type */) {
                writer.addChange({
                    type: 'insert-record-property',
                    pointer: pointer + '/properties',
                    index: 0,
                    element: (0, odata_annotation_core_types_1.createElementNode)({
                        name: 'PropertyValue',
                        attributes: {
                            Property: (0, odata_annotation_core_types_1.createAttributeNode)('Property', '$Type')
                        },
                        content: [(0, odata_annotation_core_types_1.createElementNode)({ name: 'String', content: [(0, odata_annotation_core_types_1.createTextNode)(change.value)] })]
                    })
                });
            }
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer} ${change.name}`, error_1.ApiErrorCode.General);
        }
    };
    [types_1.DELETE_ATTRIBUTE] = (writer, document, change) => {
        const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        const [node] = (0, pointer_1.getAstNodesFromPointer)(document.ast, pointer).slice(-1);
        if (pointer && node?.type === cds_annotation_parser_1.QUALIFIER_TYPE) {
            writer.addChange((0, change_1.createDeleteQualifierChange)(pointer));
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer}`, error_1.ApiErrorCode.General);
        }
    };
    [types_1.UPDATE_ATTRIBUTE_VALUE] = (writer, document, change) => {
        const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        if (pointer) {
            writer.addChange((0, change_1.createUpdatePrimitiveValueChange)(pointer, change.newValue));
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer} ${change.newValue}`, error_1.ApiErrorCode.General);
        }
    };
    [internal_change_1.REPLACE_ATTRIBUTE] = (writer, document, change) => {
        const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        const [currentAstNode] = (0, pointer_1.getAstNodesFromPointer)(document.ast, pointer).slice(-1);
        if (pointer) {
            if (currentAstNode.type === cds_annotation_parser_1.RECORD_PROPERTY_TYPE && change.newAttributeValue) {
                writer.addChange({
                    type: 'update-primitive-value',
                    pointer: pointer,
                    newValue: change.newAttributeValue
                });
            }
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer}`, error_1.ApiErrorCode.General);
        }
    };
    [internal_change_1.REPLACE_ELEMENT] = (writer, document, change) => {
        const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        const currentAFNode = (0, utils_1.getGenericNodeFromPointer)(document.annotationFile, change.pointer);
        if (pointer) {
            if (currentAFNode?.type === odata_annotation_core_types_1.ELEMENT_TYPE && currentAFNode.name === "PropertyValue" /* Edm.PropertyValue */) {
                writer.addChange({
                    type: 'replace-record-property',
                    pointer: pointer,
                    newProperty: change.newElement
                });
            }
            else {
                writer.addChange({
                    type: 'replace-node',
                    pointer: pointer,
                    newElement: change.newElement
                });
            }
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer} ${change.newElement.name}`, error_1.ApiErrorCode.General);
        }
    };
    [internal_change_1.REPLACE_TEXT] = (writer, document, change) => {
        const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        const segments = change.pointer.split('/');
        const lastSegment = segments.pop();
        const annotationFileNode = (0, utils_1.getGenericNodeFromPointer)(document.annotationFile, segments.join('/'));
        if (pointer) {
            if (lastSegment === 'text' && elementHasFlags(annotationFileNode)) {
                // CDS has specific syntax for flags and
                writer.addChange({
                    type: 'set-flags',
                    pointer: pointer,
                    value: change.text.text
                });
            }
            else {
                writer?.addChange({
                    type: 'replace-text-value',
                    pointer: pointer,
                    newValue: change.text.text
                });
            }
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer} ${change.text}`, error_1.ApiErrorCode.General);
        }
    };
    [internal_change_1.REPLACE_ELEMENT_CONTENT] = (writer, document, change) => {
        const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, change.pointer, document.ast);
        const [currentAstNode] = (0, pointer_1.getAstNodesFromPointer)(document.ast, pointer).slice(-1);
        const annotationFileNode = (0, utils_1.getGenericNodeFromPointer)(document.annotationFile, change.pointer);
        const newValue = change.newValue[0];
        if (pointer && currentAstNode && newValue?.type === odata_annotation_core_types_1.TEXT_TYPE) {
            if (annotationFileNode?.type === odata_annotation_core_types_1.ELEMENT_TYPE && annotationFileNode.name === "EnumMember" /* Edm.EnumMember */) {
                if (elementHasFlags(annotationFileNode)) {
                    writer.addChange({
                        type: 'set-flags',
                        pointer: pointer,
                        value: newValue.text
                    });
                }
                else {
                    writer.addChange({
                        type: 'replace-text-value',
                        pointer: pointer,
                        newValue: newValue.text
                    });
                }
            }
            else {
                writer.addChange({
                    type: 'update-primitive-value',
                    pointer: pointer,
                    newValue: newValue.text
                });
            }
        }
        else {
            throw new error_1.ApiError(`Could not process change ${change.type} ${change.uri} ${change.pointer} ${change.newValue}`, error_1.ApiErrorCode.General);
        }
    };
    [internal_change_1.MOVE_ELEMENT] = (writer, document, change) => {
        const { pointer, index } = change;
        const { pointer: toPointer } = (0, pointer_1.convertPointer)(document.annotationFile, pointer, document.ast);
        const toNode = (0, utils_1.getGenericNodeFromPointer)(document.annotationFile, pointer);
        if (toPointer && (0, odata_annotation_core_1.isElementWithName)(toNode, 'Collection')) {
            writer.addChange({
                type: 'move-collection-value',
                pointer: toPointer,
                index,
                fromPointers: change.fromPointers.map((ptr) => {
                    const { pointer } = (0, pointer_1.convertPointer)(document.annotationFile, ptr, document.ast);
                    return pointer;
                })
            });
        }
    };
    [internal_change_1.UPDATE_ELEMENT_NAME] = () => {
        // noop, such changes have no effect in CDS
    };
    [internal_change_1.DELETE_REFERENCE] = () => {
        // noop, such changes are not supported in CDS
    };
}
exports.CDSAnnotationServiceAdapter = CDSAnnotationServiceAdapter;
function getAliasInfo(annotationFileInternal, metadataService, vocabularyAPI) {
    const namespaces = (0, odata_annotation_core_1.getAllNamespacesAndReferences)(annotationFileInternal.namespace, annotationFileInternal.references);
    const aliasInfo = (0, odata_annotation_core_1.getAliasInformation)(namespaces, metadataService.getNamespaces());
    return (0, vocabularies_1.addAllVocabulariesToAliasInformation)(aliasInfo, vocabularyAPI.getVocabularies());
}
function elementHasFlags(element) {
    if (!element || element.type !== 'element') {
        return false;
    }
    const content = element.content[0];
    if (content?.type === 'text' && element.name === "EnumMember" /* Edm.EnumMember */) {
        return content.text.split(' ').length > 1;
    }
    return false;
}
function buildAnnotation(root, pointer, lastContent) {
    const segments = pointer.split('/');
    let node = root;
    if (node.type !== odata_annotation_core_types_1.ELEMENT_TYPE) {
        return undefined;
    }
    const result = buildElement(node);
    let current = result;
    for (const segment of segments) {
        const next = node[segment];
        if (next) {
            node = next;
            if (node.type === odata_annotation_core_types_1.ELEMENT_TYPE) {
                const nextElement = buildElement(node);
                current.content.push(nextElement);
                current = nextElement;
            }
            else if (!Array.isArray(node)) {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    }
    current.content.push(lastContent);
    return result;
}
function buildElement(node) {
    const result = (0, odata_annotation_core_types_1.createElementNode)({ name: node.name });
    if (node.name === "Annotation" /* Edm.Annotation */) {
        result.attributes["Term" /* Edm.Term */] = node.attributes["Term" /* Edm.Term */];
        if (node.attributes["Qualifier" /* Edm.Qualifier */]) {
            result.attributes["Qualifier" /* Edm.Qualifier */] = node.attributes["Qualifier" /* Edm.Qualifier */];
        }
    }
    if (node.name === "PropertyValue" /* Edm.PropertyValue */) {
        result.attributes["Property" /* Edm.Property */] = node.attributes["Property" /* Edm.Property */];
    }
    return result;
}
function adaptRecordPropertyIndex(record, currentIndex) {
    if (currentIndex === undefined) {
        return currentIndex;
    }
    let adaptedIdx = currentIndex;
    for (let index = 0; index < record.properties.length; index++) {
        const propertyName = record.properties[index].name.value;
        if ((0, cds_annotation_parser_1.isReservedProperty)(propertyName) && index <= adaptedIdx) {
            adaptedIdx = adaptedIdx + 1;
        }
    }
    return adaptedIdx;
}
//# sourceMappingURL=adapter.js.map