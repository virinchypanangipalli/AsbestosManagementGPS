"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeConverter = void 0;
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const avt_1 = require("./avt");
const vocabularies_1 = require("./vocabularies");
const types_1 = require("./types");
const utils_1 = require("./utils");
const error_1 = require("./error");
/**
 * Converts changes to the internal change format.
 */
class ChangeConverter {
    serviceName;
    vocabularyAPI;
    metadataService;
    splitAnnotationSupport;
    aliasInfoCache = {};
    newTargetChanges = new Map();
    annotationFileChanges = [];
    /**
     *
     * @param serviceName Name of the service.
     * @param vocabularyAPI Vocabulary API instance.
     * @param metadataService Metadata service.
     * @param splitAnnotationSupport Flag indicating if partial annotation definitions are supported.
     */
    constructor(serviceName, vocabularyAPI, metadataService, splitAnnotationSupport) {
        this.serviceName = serviceName;
        this.vocabularyAPI = vocabularyAPI;
        this.metadataService = metadataService;
        this.splitAnnotationSupport = splitAnnotationSupport;
    }
    /**
     * Converts changes to the internal change format.
     *
     * @param compiledService Service in internal format.
     * @param fileMergeMaps Maps containing references of merged split annotations.
     * @param schemaProvider Function which returns current service RawMetadata.
     * @param changes AVT changes to be converted.
     * @returns Annotation file changes.
     */
    convert(compiledService, fileMergeMaps, schemaProvider, changes) {
        this.reset();
        const mergedChanges = mergeChanges(changes);
        for (const change of mergedChanges) {
            const file = compiledService.annotationFiles.find((file) => file.uri === change.uri);
            if (!file) {
                throw new Error(`Invalid change. File ${change.uri} does not exist.`);
            }
            const aliasInfoMod = this.getAliasInformation(file);
            if (change.kind === types_1.ChangeType.InsertAnnotation) {
                this.insertAnnotation(compiledService, aliasInfoMod, change);
            }
            else if (change.kind === types_1.ChangeType.InsertEmbeddedAnnotation) {
                this.insertEmbeddedAnnotation(file, fileMergeMaps, aliasInfoMod, change);
            }
            else if (change.kind === types_1.ChangeType.Insert) {
                this.convertInsert(file, fileMergeMaps, aliasInfoMod, change);
            }
            else if (change.kind === types_1.ChangeType.Delete) {
                this.convertDelete(file, fileMergeMaps, aliasInfoMod, change);
            }
            else if (change.kind === types_1.ChangeType.Update) {
                this.convertUpdate(file, fileMergeMaps, aliasInfoMod, schemaProvider, change);
            }
            else if (change.kind === types_1.ChangeType.Move) {
                this.convertMove(file, fileMergeMaps, aliasInfoMod, change);
            }
        }
        this.addTargetChanges(compiledService);
        return this.annotationFileChanges;
    }
    insertAnnotation(compiledService, aliasInfo, change) {
        const annotationFile = compiledService.annotationFiles.find((file) => file.uri === change.uri);
        const targetName = (0, odata_annotation_core_1.toAliasQualifiedName)(change.content.target, aliasInfo);
        const targetIndex = annotationFile?.targets.findIndex((target) => (0, odata_annotation_core_1.toAliasQualifiedName)(target.name, aliasInfo) === targetName);
        if (targetIndex === -1) {
            // no existing target found, we need to create one
            const changesForUri = this.newTargetChanges.get(change.uri);
            if (!changesForUri) {
                this.newTargetChanges.set(change.uri, new Map([[targetName, [change]]]));
            }
            else {
                const changesForTarget = changesForUri.get(targetName);
                if (changesForTarget) {
                    changesForTarget.push(change);
                }
                else {
                    changesForUri.set(targetName, [change]);
                }
            }
        }
        else {
            // add annotation to existing target
            const internal = {
                type: types_1.INSERT_ELEMENT,
                uri: change.uri,
                target: targetName,
                pointer: `/targets/${targetIndex}`,
                element: (0, avt_1.convertAnnotationToInternal)(change.content.value, aliasInfo)
            };
            this.annotationFileChanges.push(internal);
        }
    }
    insertEmbeddedAnnotation(file, fileMergeMaps, aliasInfo, change) {
        const { reference, content } = change;
        const { targetPointer, internalPointer } = (0, avt_1.findAnnotationByReference)(aliasInfo, file, fileMergeMaps[change.uri], reference, change.pointer, this.splitAnnotationSupport);
        const internal = {
            type: types_1.INSERT_ELEMENT,
            uri: change.uri,
            target: change.reference.target,
            element: (0, avt_1.convertAnnotationToInternal)(content.value, aliasInfo),
            pointer: targetPointer + internalPointer,
            index: change.index
        };
        this.annotationFileChanges.push(internal);
    }
    convertInsert(file, fileMergeMaps, aliasInfo, change) {
        const { reference, content } = change;
        const { element, targetPointer: pointer, internalPointer } = (0, avt_1.findAnnotationByReference)(aliasInfo, file, fileMergeMaps[change.uri], reference, change.pointer, this.splitAnnotationSupport);
        const index = change.kind === types_1.ChangeType.Insert ? change.index : undefined;
        if (content.type === 'record') {
            const internal = {
                type: types_1.INSERT_ELEMENT,
                uri: change.uri,
                target: change.reference.target,
                pointer: pointer + internalPointer,
                element: (0, avt_1.convertRecordToInternal)(aliasInfo, content.value),
                index
            };
            this.annotationFileChanges.push(internal);
        }
        else if (content.type === 'property-value') {
            const internal = {
                type: types_1.INSERT_ELEMENT,
                uri: change.uri,
                target: change.reference.target,
                pointer: pointer + internalPointer,
                element: (0, avt_1.convertPropertyValueToInternal)(aliasInfo, content.value),
                index
            };
            this.annotationFileChanges.push(internal);
        }
        else if (content.type === 'collection') {
            const internal = {
                type: types_1.INSERT_ELEMENT,
                uri: change.uri,
                target: change.reference.target,
                pointer: pointer + internalPointer,
                element: (0, avt_1.convertCollectionToInternal)(aliasInfo, content.value),
                index
            };
            this.annotationFileChanges.push(internal);
        }
        else if (content.type === 'expression') {
            this.convertInsertExpression(file, aliasInfo, pointer + internalPointer, change, content, index);
        }
        else if (content.type === 'primitive') {
            this.convertInsertPrimitive(element, aliasInfo, pointer, internalPointer, change, content, index);
        }
    }
    convertInsertExpression(file, aliasInfoMod, pointer, change, content, index) {
        const node = (0, utils_1.getGenericNodeFromPointer)(file, pointer);
        if (node?.type === odata_annotation_core_types_1.ELEMENT_TYPE && node.name === "Collection" /* Edm.Collection */) {
            const expression = (0, avt_1.convertExpressionToInternal)(aliasInfoMod, content.value);
            if (expression) {
                const internal = {
                    type: types_1.INSERT_ELEMENT,
                    uri: change.uri,
                    target: change.reference.target,
                    pointer: pointer,
                    element: expression,
                    index
                };
                this.annotationFileChanges.push(internal);
            }
        }
        else {
            const container = (0, avt_1.convertExpressionToInternal)(aliasInfoMod, content.value, (0, odata_annotation_core_types_1.createElementNode)({ name: 'placeholder' }));
            if (container) {
                const expression = container.content[0];
                if (expression?.type === odata_annotation_core_types_1.ELEMENT_TYPE) {
                    const internal = {
                        type: types_1.INSERT_ELEMENT,
                        uri: change.uri,
                        target: change.reference.target,
                        pointer: pointer,
                        element: expression,
                        index
                    };
                    this.annotationFileChanges.push(internal);
                    return;
                }
                else if (Object.keys(container.attributes).length > 0) {
                    const attribute = container.attributes[Object.keys(container.attributes)[0]];
                    const internal = {
                        type: types_1.INSERT_ATTRIBUTE,
                        uri: change.uri,
                        pointer: pointer,
                        name: attribute.name,
                        value: attribute.value
                    };
                    this.annotationFileChanges.push(internal);
                    return;
                }
            }
        }
    }
    convertInsertPrimitive(element, aliasInfoMod, pointer, internalPointer, change, content, index) {
        if (content.expressionType === types_1.ExpressionType.Unknown) {
            const attributePointer = (0, avt_1.convertPointerInAnnotationToInternal)(element, 
            // last segment is used to determine attribute name
            change.pointer.split('/').slice(0, -1).join('/'));
            const attributeName = getAttributeNameFromPointer(change.pointer);
            if (attributeName) {
                const value = (0, avt_1.convertPrimitiveValueToInternal)(attributeName, content.value, aliasInfoMod);
                const internal = {
                    type: types_1.INSERT_ATTRIBUTE,
                    uri: change.uri,
                    pointer: pointer + attributePointer,
                    name: attributeName,
                    value: value
                };
                this.annotationFileChanges.push(internal);
            }
        }
        else if (content.expressionType === types_1.ExpressionType.Null) {
            const internal = {
                type: types_1.INSERT_ELEMENT,
                uri: change.uri,
                target: change.reference.target,
                pointer: pointer + internalPointer,
                element: (0, odata_annotation_core_types_1.createElementNode)({ name: "Null" /* Edm.Null */ }),
                index
            };
            this.annotationFileChanges.push(internal);
        }
        else if (typeof content.expressionType === 'string') {
            const internal = {
                type: types_1.INSERT_ATTRIBUTE,
                uri: change.uri,
                pointer: pointer + internalPointer,
                name: content.expressionType,
                value: content.value.toString()
            };
            this.annotationFileChanges.push(internal);
        }
    }
    convertDelete(file, fileMergeMaps, aliasInfo, change) {
        const { reference } = change;
        const { target, targetPointer: pointer, internalPointer } = (0, avt_1.findAnnotationByReference)(aliasInfo, file, fileMergeMaps[change.uri], reference, change.pointer, this.splitAnnotationSupport);
        // look for attribute pointer suffix e.g attributes/Qualifier/value
        const suffix = internalPointer.split('/').slice(-3);
        if (suffix[0] === 'attributes' && suffix.length === 3) {
            // its an attribute change
            const [, , property] = suffix;
            if (property === 'value') {
                const internal = {
                    type: types_1.DELETE_ATTRIBUTE,
                    uri: change.uri,
                    pointer: pointer + internalPointer.split('/').slice(0, -1).join('/')
                };
                this.annotationFileChanges.push(internal);
            }
        }
        else if (change.pointer === '') {
            const internal = {
                type: types_1.DELETE_ELEMENT,
                target: target.name,
                uri: change.uri,
                pointer: pointer
            };
            this.annotationFileChanges.push(internal);
        }
        else if (internalPointer !== '') {
            const internal = {
                type: types_1.DELETE_ELEMENT,
                uri: change.uri,
                target: target.name,
                pointer: pointer + internalPointer
            };
            this.annotationFileChanges.push(internal);
        }
    }
    convertUpdate(file, fileMergeMaps, aliasInfo, schemaProvider, change) {
        const { reference, content } = change;
        const valueType = this.getValueType(schemaProvider, change);
        const { element, targetPointer: pointer, internalPointer } = (0, avt_1.findAnnotationByReference)(aliasInfo, file, fileMergeMaps[change.uri], reference, change.pointer, this.splitAnnotationSupport, valueType);
        if (internalPointer === '') {
            // value does not exist, treat this as insert
            this.convertInsert(file, fileMergeMaps, aliasInfo, change);
            return;
        }
        // look for attribute pointer suffix e.g attributes/Qualifier/value
        const suffix = internalPointer.split('/').slice(-3);
        if (suffix[0] === 'attributes' && suffix.length === 3) {
            // its an attribute change
            const [, attributeName, property] = suffix;
            this.convertUpdateAttribute(aliasInfo, attributeName, property, pointer, internalPointer, change);
        }
        else if (content.type === 'expression' && content.value.type === 'Collection') {
            const node = (0, utils_1.getGenericNodeFromPointer)(file, pointer + internalPointer);
            const newElement = (0, avt_1.convertExpressionToInternal)(aliasInfo, content.value);
            if (node?.type === odata_annotation_core_types_1.ELEMENT_TYPE && newElement) {
                const internalChange = {
                    type: types_1.REPLACE_ELEMENT,
                    uri: change.uri,
                    pointer: pointer + internalPointer,
                    newElement
                };
                this.annotationFileChanges.push(internalChange);
            }
        }
        else if (content.type === 'expression') {
            this.convertUpdateExpression(file, aliasInfo, content, pointer + internalPointer, valueType, reference.target);
        }
        else if (content.type === 'primitive' && content.value !== undefined) {
            const internalPointerForPrimitiveValues = (0, avt_1.convertPointerInAnnotationToInternal)(element, change.pointer, content.expressionType);
            const replaceTextPointer = pointer + internalPointerForPrimitiveValues + '/text';
            this.convertUpdatePrimitiveValue(file, aliasInfo, content, pointer + internalPointer, replaceTextPointer);
        }
        else {
            const element = convertChangeToElement(aliasInfo, file, change);
            if (element) {
                const internal = {
                    type: types_1.REPLACE_ELEMENT,
                    uri: change.uri,
                    pointer: pointer + internalPointer,
                    newElement: element
                };
                this.annotationFileChanges.push(internal);
            }
        }
    }
    convertUpdateAttribute(aliasInfo, attributeName, property, pointer, internalPointer, change) {
        const value = this.getAttributeValue(change.content);
        if (property === 'value' && value !== undefined) {
            const type = this.getPrimitiveValueType(change.content) ?? attributeName;
            const newValue = (0, avt_1.convertPrimitiveValueToInternal)(type, value, aliasInfo);
            const internal = {
                type: types_1.UPDATE_ATTRIBUTE_VALUE,
                uri: change.uri,
                pointer: pointer + internalPointer.split('/').slice(0, -1).join('/'),
                newValue
            };
            this.annotationFileChanges.push(internal);
        }
    }
    getPrimitiveValueType(content) {
        if (content.type === 'primitive') {
            if (content.expressionType === types_1.ExpressionType.Unknown) {
                return undefined;
            }
            return content.expressionType;
        }
        if (content.type === 'expression') {
            if (content.value.type === types_1.ExpressionType.Unknown) {
                return undefined;
            }
            return content.value.type;
        }
        return undefined;
    }
    getAttributeValue(content) {
        if (content.type === 'primitive') {
            return content.value;
        }
        if (content.type === 'expression') {
            return this.getExpressionValue(content);
        }
        return undefined;
    }
    getExpressionValue(content) {
        return content.value[content.value.type]; // There is always a property with on the object as type name, Typescript does not infer this case as expected
    }
    convertUpdateExpression(file, aliasInfo, content, pointer, valueType, targetName) {
        const rawPrimitiveValue = this.getExpressionValue(content);
        const newValue = (0, avt_1.convertPrimitiveValueToInternal)(content.value.type, rawPrimitiveValue, aliasInfo);
        const type = valueType ?? content.value.type;
        const node = (0, utils_1.getGenericNodeFromPointer)(file, pointer);
        if (node?.type === odata_annotation_core_types_1.ELEMENT_TYPE) {
            const onlyChangeValue = content.previousType === undefined && content.value.type === valueType;
            if (onlyChangeValue && node.attributes[type]) {
                // attribute notation
                const internalChange = {
                    type: types_1.UPDATE_ATTRIBUTE_VALUE,
                    uri: file.uri,
                    pointer: pointer + `/attributes/${type}`,
                    newValue
                };
                this.annotationFileChanges.push(internalChange);
            }
            else if (onlyChangeValue && node.name === valueType) {
                // element notation
                const internalChange = {
                    type: types_1.REPLACE_ELEMENT_CONTENT,
                    uri: file.uri,
                    pointer: pointer,
                    newValue: [(0, odata_annotation_core_types_1.createTextNode)(newValue)]
                };
                this.annotationFileChanges.push(internalChange);
            }
            else if (node.attributes[type]) {
                // attribute notation
                this.annotationFileChanges.push({
                    type: types_1.REPLACE_ATTRIBUTE,
                    uri: file.uri,
                    pointer: pointer + `/attributes/${type}`,
                    newAttributeName: content.value.type,
                    newAttributeValue: newValue
                });
            }
            else if (node.name === valueType) {
                // element notation
                const childContent = [];
                if (content.value.type !== "Null" /* Edm.Null */) {
                    childContent.push((0, odata_annotation_core_types_1.createTextNode)(newValue));
                }
                const internalChange = {
                    type: types_1.REPLACE_ELEMENT,
                    uri: file.uri,
                    pointer: pointer,
                    newElement: (0, odata_annotation_core_types_1.createElementNode)({
                        name: content.value.type,
                        content: childContent
                    })
                };
                this.annotationFileChanges.push(internalChange);
            }
        }
        else if (node?.type === odata_annotation_core_types_1.ATTRIBUTE_TYPE) {
            this.convertUpdateExpressionForAttrributeType(file.uri, targetName, valueType, content, pointer, newValue);
        }
    }
    convertUpdateExpressionForAttrributeType(fileUri, targetName, valueType, content, pointer, newValue) {
        if (content.previousType === undefined && content.value.type === valueType) {
            // attribute notation
            const internalChange = {
                type: types_1.UPDATE_ATTRIBUTE_VALUE,
                uri: fileUri,
                pointer: pointer,
                newValue
            };
            this.annotationFileChanges.push(internalChange);
        }
        else if (content.value.type === "Null" /* Edm.Null */) {
            this.annotationFileChanges.push({
                type: types_1.DELETE_ATTRIBUTE,
                uri: fileUri,
                pointer: pointer
            });
            this.annotationFileChanges.push({
                type: types_1.INSERT_ELEMENT,
                uri: fileUri,
                target: targetName,
                pointer: pointer.split('/').slice(0, -2).join('/'),
                element: (0, odata_annotation_core_types_1.createElementNode)({ name: "Null" /* Edm.Null */ })
            });
        }
        else {
            // attribute notation
            const internalChange = {
                type: types_1.REPLACE_ATTRIBUTE,
                uri: fileUri,
                pointer: pointer,
                newAttributeName: content.value.type,
                newAttributeValue: newValue
            };
            this.annotationFileChanges.push(internalChange);
        }
    }
    convertUpdatePrimitiveValue(file, aliasInfo, content, pointer, replaceTextPointer) {
        const newValue = (0, avt_1.convertPrimitiveValueToInternal)(content.expressionType ?? '', content.value, aliasInfo);
        const node = (0, utils_1.getGenericNodeFromPointer)(file, pointer);
        if (node?.type === odata_annotation_core_types_1.TEXT_TYPE) {
            const containerPointer = pointer.split('/').slice(0, -2).join('/');
            const container = (0, utils_1.getGenericNodeFromPointer)(file, containerPointer);
            if (container?.type === odata_annotation_core_types_1.ELEMENT_TYPE &&
                content.expressionType &&
                container.name !== content.expressionType) {
                const internal = {
                    type: types_1.REPLACE_ELEMENT,
                    uri: file.uri,
                    pointer: containerPointer,
                    newElement: (0, odata_annotation_core_types_1.createElementNode)({
                        name: content.expressionType,
                        content: [(0, odata_annotation_core_types_1.createTextNode)(newValue)]
                    })
                };
                this.annotationFileChanges.push(internal);
                return;
            }
        }
        else if (node?.type === odata_annotation_core_types_1.ELEMENT_TYPE &&
            content.expressionType &&
            replaceTextPointer.split('/').includes('attributes')) {
            const oldAttributeName = replaceTextPointer.split('/').slice(-2)[0];
            if (node.attributes[content.expressionType]) {
                const internal = {
                    type: types_1.UPDATE_ATTRIBUTE_VALUE,
                    uri: file.uri,
                    pointer: `${pointer}/attributes/${content.expressionType}`,
                    newValue
                };
                this.annotationFileChanges.push(internal);
                return;
            }
            else {
                const internal = {
                    type: types_1.REPLACE_ATTRIBUTE,
                    uri: file.uri,
                    pointer: `${pointer}/attributes/${oldAttributeName}`,
                    newAttributeName: content.expressionType,
                    newAttributeValue: newValue
                };
                this.annotationFileChanges.push(internal);
                return;
            }
        }
        const internal = {
            type: types_1.REPLACE_TEXT,
            uri: file.uri,
            pointer: replaceTextPointer,
            text: (0, odata_annotation_core_types_1.createTextNode)(newValue)
        };
        this.annotationFileChanges.push(internal);
    }
    convertMove(file, fileMergeMaps, aliasInfo, change) {
        const { reference, index, moveReference } = change;
        const { targetPointer: pointer, internalPointer } = (0, avt_1.findAnnotationByReference)(aliasInfo, file, fileMergeMaps[change.uri], reference, change.pointer, this.splitAnnotationSupport);
        const internal = {
            type: types_1.MOVE_ELEMENT,
            uri: change.uri,
            pointer: pointer + internalPointer,
            index: index,
            fromPointers: moveReference.reduce((acc, moveRef) => {
                acc.push(...moveRef.fromPointer.map((fromPointer) => {
                    const { targetPointer: fromTargetPointer, internalPointer: internalFromPointer } = (0, avt_1.findAnnotationByReference)(aliasInfo, file, fileMergeMaps[change.uri], moveRef.reference ?? change.reference, fromPointer, this.splitAnnotationSupport);
                    return fromTargetPointer + internalFromPointer;
                }));
                return acc;
            }, new Array())
        };
        this.annotationFileChanges.push(internal);
    }
    addTargetChanges(compiledService) {
        const insertTargetChanges = [];
        for (const [uri, changesForUri] of this.newTargetChanges) {
            const file = compiledService.annotationFiles.find((file) => file.uri === uri);
            if (!file) {
                throw new Error(`Invalid change. File ${uri} does not exist.`);
            }
            const aliasInfoMod = this.getAliasInformation(file);
            for (const [targetName, inserts] of changesForUri) {
                const target = (0, odata_annotation_core_types_1.createTarget)(targetName);
                target.terms = inserts.map((change) => (0, avt_1.convertAnnotationToInternal)(change.content.value, aliasInfoMod));
                const internal = {
                    type: types_1.INSERT_TARGET,
                    uri: uri,
                    target
                };
                insertTargetChanges.push(internal);
            }
        }
        this.annotationFileChanges.unshift(...insertTargetChanges);
    }
    getValueType(schemaProvider, change) {
        const { content } = change;
        if (content.type === 'expression') {
            if (content.previousType) {
                return content.previousType;
            }
            return this.getValueTypeFromSchema(schemaProvider, change);
        }
        // else if (content.type === 'primitive') {
        //     if (content.expressionType) {
        //         return content.expressionType;
        //     }
        //     return this.getValueTypeFromSchema(schemaProvider, change);
        // }
        return undefined;
    }
    getValueTypeFromSchema(schemaProvider, change) {
        const { reference, uri, pointer } = change;
        const annotationLists = schemaProvider().schema.annotations[uri] ?? [];
        const annotation = (0, avt_1.findAnnotation)(annotationLists, reference);
        if (!annotation) {
            const refString = (0, utils_1.annotationReferenceToString)(reference, uri);
            throw new error_1.ApiError(`Could not find annotation '${refString}' in file '${uri}'.`, error_1.ApiErrorCode.General);
        }
        const node = (0, avt_1.getAvtNodeFromPointer)(annotation, pointer);
        if (!node) {
            const refString = (0, utils_1.annotationReferenceToString)(reference, uri);
            throw new error_1.ApiError(`Could not resolve pointer '${pointer}' from annotation '${refString}'.`, error_1.ApiErrorCode.General);
        }
        if (this.isExpression(node)) {
            return node.type;
        }
        return undefined;
    }
    isExpression(node) {
        return typeof node.type !== 'undefined' && typeof node.propertyValues === 'undefined';
    }
    getAliasInformation(file) {
        const cachedValue = this.aliasInfoCache[file.uri];
        if (cachedValue) {
            return cachedValue;
        }
        const namespaces = (0, odata_annotation_core_1.getAllNamespacesAndReferences)(file.namespace ?? { name: this.serviceName, type: 'namespace' }, file.references);
        const aliasInfo = (0, odata_annotation_core_1.getAliasInformation)(namespaces, this.metadataService.getNamespaces());
        const aliasInfoWithAllVocabularies = (0, vocabularies_1.addAllVocabulariesToAliasInformation)(aliasInfo, this.vocabularyAPI.getVocabularies());
        this.aliasInfoCache[file.uri] = aliasInfoWithAllVocabularies;
        return aliasInfoWithAllVocabularies;
    }
    reset() {
        this.aliasInfoCache = {};
        this.newTargetChanges = new Map();
        this.annotationFileChanges = [];
    }
}
exports.ChangeConverter = ChangeConverter;
function mergeChanges(changes) {
    const result = [];
    const inserts = changes
        .filter((change) => change.kind === types_1.ChangeType.InsertAnnotation)
        .reduce((acc, change) => {
        const reference = {
            target: change.content.target,
            term: change.content.value.term,
            qualifier: change.content.value.qualifier
        };
        const key = (0, utils_1.annotationReferenceToString)(reference, change.uri);
        acc.set(key, change);
        return acc;
    }, new Map());
    for (const change of changes) {
        if (change.kind === types_1.ChangeType.InsertAnnotation) {
            // don't do anything with annotation inserts
            result.push(change);
            continue;
        }
        const key = (0, utils_1.annotationReferenceToString)(change.reference, change.uri);
        const insert = inserts.get(key);
        if (!insert) {
            // reference should exist -> continue normally
            result.push(change);
            continue;
        }
        // new annotation should exist only in memory -> merge changes
        mergeChange(insert, change);
    }
    return result;
}
function mergeChange(target, source) {
    const reference = (0, utils_1.annotationReferenceToString)(source.reference, source.uri);
    switch (source.kind) {
        case types_1.ChangeType.InsertEmbeddedAnnotation: {
            if (target.content.value.annotations) {
                target.content.value.annotations.push(source.content.value);
            }
            else {
                target.content.value.annotations = [source.content.value];
            }
            return;
        }
        case types_1.ChangeType.Insert: {
            const node = (0, avt_1.getAvtNodeFromPointer)(target.content.value, source.pointer);
            if (!node) {
                throw new error_1.ApiError(`Change merge for '${reference}' failed! Could not resolve '${source.pointer}'.`, error_1.ApiErrorCode.General);
            }
            if (Array.isArray(node) && source.content.type === 'record') {
                if (source.index === undefined || source.index >= node.length) {
                    node.push(source.content.value);
                }
                else {
                    node.splice(source.index, 0, source.content.value);
                }
                return;
            }
            throw new error_1.ApiError(`Change merge for '${reference}' failed! Change value type '${source.content.type}' is not supported.`, error_1.ApiErrorCode.General);
        }
        default:
            break;
    }
    throw new error_1.ApiError(`Change merge for '${reference}' failed! Change type '${source.kind}' is not supported.`, error_1.ApiErrorCode.General);
}
function convertChangeToElement(aliasInfoMod, file, change) {
    if (change.content.type === 'record') {
        const { content } = change;
        return (0, avt_1.convertRecordToInternal)(aliasInfoMod, content.value);
    }
    else if (change.content.type === 'property-value') {
        const { content } = change;
        return (0, avt_1.convertPropertyValueToInternal)(aliasInfoMod, content.value);
    }
    else if (change.content.type === 'collection') {
        const { content } = change;
        return (0, avt_1.convertCollectionToInternal)(aliasInfoMod, content.value);
    }
    else if (change.content.type === 'expression') {
        const { content } = change;
        return (0, avt_1.convertExpressionToInternal)(aliasInfoMod, content.value);
    }
    else if (change.content.type === 'primitive') {
        const { content } = change;
        if (content.expressionType === types_1.ExpressionType.Null) {
            return (0, odata_annotation_core_types_1.createElementNode)({ name: "Null" /* Edm.Null */ });
        }
    }
    return undefined;
}
function getAttributeNameFromPointer(pointer) {
    const lastSegment = pointer.split('/').slice(-1)[0];
    // new primitive value: can always be added as attributes, namespaces are already replaced
    if (lastSegment?.length) {
        // convert property names used in AVT types to attribute names (e.g. 'type', 'term' and 'qualifier')
        // (EDMX Attribute names always start with upper case letter)
        return lastSegment.substring(0, 1).toUpperCase() + lastSegment.substring(1);
    }
    return undefined;
}
//# sourceMappingURL=change-converter.js.map