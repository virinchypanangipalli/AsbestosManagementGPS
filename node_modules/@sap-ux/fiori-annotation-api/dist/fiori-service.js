"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FioriAnnotationService = exports.COMPILE_ERROR_MSG = void 0;
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const mem_fs_1 = require("mem-fs");
const mem_fs_editor_1 = require("mem-fs-editor");
const odata_vocabularies_1 = require("@sap-ux/odata-vocabularies");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const avt_1 = require("./avt");
const xml_1 = require("./xml");
const cds_1 = require("./cds");
const vocabularies_1 = require("./vocabularies");
const error_1 = require("./error");
const utils_1 = require("./utils");
const change_converter_1 = require("./change-converter");
function getOptionsWithDefaults(options) {
    return {
        commitOnSave: options.commitOnSave ?? true,
        clearFileResolutionCache: options.clearFileResolutionCache ?? false
    };
}
exports.COMPILE_ERROR_MSG = 'Update rejected due to changes leading to compile errors';
/**
 * Service for working with OData annotations in SAP Fiori Elements applications.
 *
 */
class FioriAnnotationService {
    vocabularyAPI;
    adapter;
    changeConverter;
    fs;
    options;
    serviceName;
    changes = [];
    fileMergeMaps = {};
    fileCache = new Map();
    isInitialSyncCompleted = false;
    projectInfo = {
        appName: '',
        apps: [],
        projectRoot: ''
    };
    /**
     * For creating new instances use the factory function {@link FioriAnnotationService.createService}.
     *
     * @param vocabularyAPI - Vocabulary API instance.
     * @param adapter - Language specific adapter.
     * @param changeConverter ChangeConverter instance.
     * @param fs - `mem-fs-editor` instance.
     * @param options - API configuration.
     * @param project - Project structure.
     * @param serviceName - Name of the service.
     * @param appName - Name of the application
     */
    constructor(vocabularyAPI, adapter, changeConverter, fs, options, project, serviceName, appName) {
        this.vocabularyAPI = vocabularyAPI;
        this.adapter = adapter;
        this.changeConverter = changeConverter;
        this.fs = fs;
        this.options = options;
        this.serviceName = serviceName;
        this.projectInfo = {
            apps: Object.keys(project.apps) || [],
            appName: appName || '',
            projectRoot: project.root
        };
    }
    /**
     * Creates new FioriAnnotationService instance for the given Fiori application.
     *
     * @param this - Constructor
     * @param project - Project structure.
     * @param serviceName - Name of the service used by the app.
     * @param appName - Name of the application.
     * @param fs - Optional `mem-fs-editor` instance.
     * @param options - API configuration.
     * @returns FioriAnnotationService instance.
     */
    static async createService(project, serviceName, appName, fs, options = {}) {
        const vocabularyAPI = new odata_vocabularies_1.VocabularyService(project.projectType === 'CAPJava' || project.projectType === 'CAPNodejs');
        const finalOptions = getOptionsWithDefaults(options);
        const service = await getService(project, serviceName, appName, finalOptions.clearFileResolutionCache);
        const adapter = createAdapter(project, service, vocabularyAPI, appName);
        // prepare fs editor if not provided
        let fsEditor;
        if (fs) {
            fsEditor = fs;
        }
        else {
            const store = (0, mem_fs_1.create)();
            fsEditor = (0, mem_fs_editor_1.create)(store);
        }
        const changeConverter = new change_converter_1.ChangeConverter(serviceName, vocabularyAPI, adapter.metadataService, adapter.splitAnnotationSupport);
        const fioriService = new this(vocabularyAPI, adapter, changeConverter, fsEditor, finalOptions, project, serviceName, appName);
        return fioriService;
    }
    /**
     * Returns a metadata service instance.
     *
     * @returns Metadata service instance.
     */
    getMetadataService() {
        return this.adapter.metadataService;
    }
    /**
     * Returns a vocabulary service instance.
     *
     * @returns Vocabulary service instance.
     */
    getVocabularyAPI() {
        return this.vocabularyAPI;
    }
    /**
     * Returns a list of files which describe the service. The order is from least important to the most important file
     * Annotations defined in the last file would overwrite the ones defined in the previous ones.
     * You can only create changes for files which are not marked as `readOnly`.
     *
     * @param [includeGhostFiles] - If set to true will also include ghost files.
     * @returns Text files.
     */
    getAllFiles(includeGhostFiles = false) {
        return this.adapter.getAllFiles(includeGhostFiles);
    }
    /**
     * Refreshes file content from the file system.
     */
    async sync() {
        this.fileCache.clear();
        const files = await Promise.all(this.adapter.getAllFiles().map(async (file) => {
            const path = (0, utils_1.pathFromUri)(file.uri);
            const content = this.fs.read(path) ?? '';
            return { ...file, content };
        }));
        for (const file of files) {
            this.fileCache.set(file.uri, file.content);
        }
        await this.adapter.sync(this.fileCache);
        this.isInitialSyncCompleted = true;
    }
    /**
     * Provides initial annotation file content.
     *
     * @param filePath - Path to the newly created file.
     * @returns Annotation file content.
     */
    getInitialFileContent(filePath) {
        return this.adapter.getInitialFileContent?.(this.serviceName, filePath) ?? '';
    }
    /**
     * Reads annotations for a specific service in an application.
     *
     * @returns Service metadata in AVT format.
     */
    getSchema() {
        const rawMetadata = {
            version: this.adapter.metadataService.ODataVersion,
            identification: 'metadataFile',
            schema: (0, avt_1.convertMetadataToAvtSchema)(this.adapter.metadataService),
            references: []
        };
        this.fileMergeMaps = mergeAnnotations(this.adapter.compiledService, rawMetadata, this.serviceName, {
            vocabulary: this.vocabularyAPI
        }, this.adapter.splitAnnotationSupport);
        return rawMetadata;
    }
    /**
     * Add change(s) to the stack.
     *
     * @param change - Pending changes.
     */
    edit(change) {
        if (Array.isArray(change)) {
            this.changes.push(...change);
        }
        else {
            this.changes.push(change);
        }
    }
    /**
     * Applies the collected changes to the file system.
     *
     * @param options Save options
     * @returns number of files changed.
     */
    async save(options) {
        if (!this.isInitialSyncCompleted) {
            await this.sync();
        }
        const newContent = {};
        const annotationFileChanges = this.convertChanges(this.changes);
        const workspaceEdit = await this.adapter.getWorkspaceEdit(annotationFileChanges);
        const changes = workspaceEdit.changes ?? {};
        const fileUris = Object.keys(changes);
        // copy the cache to temp to revert if changes caused cds compiler error
        const temp = new Map(this.fileCache);
        for (const fileUri of fileUris) {
            const path = (0, utils_1.pathFromUri)(fileUri);
            const text = this.fs.read(path) ?? '';
            const newText = applyWorkspaceEdits(fileUri, '', workspaceEdit, text);
            this.fileCache.set(fileUri, newText);
            newContent[path] = newText;
        }
        this.changes = [];
        // Validate implicitly syncs, so we don't need to call it again
        if (typeof this.adapter.validateChanges === 'function') {
            const errors = await this.adapter.validateChanges(this.fileCache);
            if (errors?.size) {
                this.fileCache = new Map(temp);
                const messages = compilerMessagesToErrors(errors);
                throw new error_1.ApiError(exports.COMPILE_ERROR_MSG, error_1.ApiErrorCode.CompileError, messages);
            }
            else {
                // if no compiler error persist the newly applied text edits
                for (const path of Object.keys(newContent)) {
                    const content = newContent[path];
                    this.saveFile(path, content);
                }
            }
        }
        else if (options?.resyncAfterSave) {
            await this.adapter.sync(this.fileCache);
        }
        if (this.options.commitOnSave) {
            await this.commit();
        }
        this.changes = [];
        this.fileMergeMaps = {};
        return { files: fileUris.length };
    }
    /**
     * Utility function: serialize target with annotations.
     *
     * @param targetAnnotations - Annotations that will be serialized.
     * @param fileUri - use alias information from this file; if none provided, use default aliases for vocabularies, non for metadata
     * @returns Annotations serialized as string for the specified language.
     */
    serializeTarget(targetAnnotations, fileUri) {
        const service = this.adapter.compiledService;
        const annotationFileInternal = service.annotationFiles.find((file) => file.uri === fileUri);
        let aliasInfo = null;
        let namespaces = [];
        if (annotationFileInternal) {
            namespaces = (0, odata_annotation_core_1.getAllNamespacesAndReferences)(annotationFileInternal.namespace, annotationFileInternal.references);
        }
        aliasInfo = (0, odata_annotation_core_1.getAliasInformation)(namespaces, this.getMetadataService().getNamespaces());
        if (!annotationFileInternal) {
            aliasInfo = (0, vocabularies_1.addAllVocabulariesToAliasInformation)(aliasInfo, this.vocabularyAPI.getVocabularies());
        }
        return this.adapter.serializeTarget((0, avt_1.convertTargetAnnotationsToInternal)(targetAnnotations, aliasInfo));
    }
    /**
     * Converts changes to the internal annotation file change format.
     *
     * @param changes - Changes in AVT format.
     * @returns Changes in internal format.
     */
    convertChanges(changes) {
        const compiledService = this.adapter.compiledService;
        let schema;
        if (this.adapter.splitAnnotationSupport && Object.keys(this.fileMergeMaps).length === 0) {
            // make sure merge maps are filled
            schema = this.getSchema();
        }
        const schemaProvider = () => {
            if (schema) {
                return schema;
            }
            else {
                schema = this.getSchema();
                return schema;
            }
        };
        return this.changeConverter.convert(compiledService, this.fileMergeMaps, schemaProvider, changes);
    }
    saveFile(path, content) {
        this.fs.write(path, content);
    }
    async commit() {
        await new Promise((resolve, reject) => {
            this.fs.commit((error) => {
                if (error instanceof Error) {
                    reject(error);
                }
                else if (typeof error === 'string') {
                    reject(new Error(error));
                }
                else if (error) {
                    reject(new Error('Unknown error.'));
                }
                resolve();
            });
        });
    }
}
exports.FioriAnnotationService = FioriAnnotationService;
function applyWorkspaceEdits(fileUri, languageId, workspaceEdits, content) {
    const document = vscode_languageserver_textdocument_1.TextDocument.create(fileUri, languageId, 0, content);
    const fileChanges = workspaceEdits.changes ? workspaceEdits.changes[fileUri] ?? [] : [];
    return vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, fileChanges);
}
function mergeAnnotations(compiledService, rawMetadata, serviceName, options, mergeSplitAnnotations) {
    const fileMergeMaps = {};
    for (const annotationFile of [...compiledService.annotationFiles]) {
        const mergeMap = {};
        fileMergeMaps[annotationFile.uri] = mergeMap;
        const targets = (0, avt_1.convertAnnotationFile)(annotationFile, serviceName, {
            addOrigins: true,
            vocabularyService: options.vocabulary,
            mergeSplitAnnotations: mergeSplitAnnotations,
            mergeMap
        });
        rawMetadata.schema.annotations[annotationFile.uri] = targets;
    }
    return fileMergeMaps;
}
async function getService(project, serviceName, appName, clearCache) {
    if (project.projectType === 'EDMXBackend') {
        return (0, xml_1.getLocalEDMXService)(project, serviceName, appName);
    }
    else if (project.projectType === 'CAPJava' || project.projectType === 'CAPNodejs') {
        return (0, cds_1.getCDSService)(project.root, serviceName, clearCache);
    }
    else {
        throw new Error(`Unsupported project type "${project.projectType}"!`);
    }
}
function createAdapter(project, service, vocabularyService, appName) {
    if (service.type === 'local-edmx') {
        return new xml_1.XMLAnnotationServiceAdapter(service, vocabularyService, project, appName);
    }
    else if (service.type === 'cap-cds') {
        return new cds_1.CDSAnnotationServiceAdapter(service, project, vocabularyService, appName);
    }
    else {
        throw new Error(`Unsupported service type "${service.type}"!`);
    }
}
function compilerMessagesToErrors(compileMessages) {
    const result = new Map();
    [...compileMessages.entries()].forEach((entry) => {
        const [file, value] = entry;
        if (value.hasSyntaxErrors && !file.startsWith('../')) {
            const errorMsgs = value.messages
                .filter((value) => value.severity === odata_annotation_core_types_1.DiagnosticSeverity.Error)
                .map((msg) => msg.message);
            result.set(file, errorMsgs);
        }
    });
    return result;
}
//# sourceMappingURL=fiori-service.js.map