"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unescapeAttribute = exports.escapeAttribute = exports.unescapeText = exports.escapeText = exports.printCsdlNodeToXmlString = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const builders_1 = require("./builders");
const printCsdlNodeToXmlString = (snippet, opts, context) => {
    const snippets = Array.isArray(snippet) ? snippet : [snippet];
    const doc = (0, builders_1.concat)(snippets.map((item, idx) => (0, builders_1.concat)([printCsdlRootNode(item, context), idx === snippets.length - 1 ? '' : builders_1.hardline])));
    doc.parts.forEach((part, index) => {
        for (let i = 0; i < context.cursorIndentLevel; i++) {
            doc.parts[index] = (0, builders_1.indent)(doc.parts[index]);
        }
    });
    return (0, builders_1.printDocumentToString)(doc, opts);
};
exports.printCsdlNodeToXmlString = printCsdlNodeToXmlString;
const escapeText = (input) => {
    if (!input || typeof input !== 'string') {
        return input;
    }
    return input.replace(/([<&])/g, (_str, item) => ({ '<': '&lt;', '&': '&amp;' }[item]));
};
exports.escapeText = escapeText;
const unescapeText = (input) => {
    if (!input || typeof input !== 'string') {
        return input;
    }
    return input.replace(/(&lt;|&amp;)/g, (_str, item) => ({ '&lt;': '<', '&amp;': '&' }[item]));
};
exports.unescapeText = unescapeText;
const escapeAttribute = (input) => {
    if (!input || typeof input !== 'string') {
        return input;
    }
    return input.replace(/([<&"])/g, (_str, item) => ({ '<': '&lt;', '&': '&amp;', '"': '&quot;' }[item]));
};
exports.escapeAttribute = escapeAttribute;
const unescapeAttribute = (input) => {
    if (!input || typeof input !== 'string') {
        return input;
    }
    return input.replace(/(&lt;|&amp;|&quot;)/g, (_str, item) => ({ '&lt;': '<', '&amp;': '&', '&quot;': '"' }[item]));
};
exports.unescapeAttribute = unescapeAttribute;
const printCsdlRootNode = (node, context) => {
    switch (node.type) {
        case odata_annotation_core_1.ELEMENT_TYPE: {
            return printElement(node, context);
        }
        case odata_annotation_core_1.TEXT_TYPE:
            return printText(node, true);
        default:
            return '';
    }
};
const printCsdlNode = (node, context) => {
    switch (node.type) {
        case odata_annotation_core_1.ELEMENT_TYPE:
            return printElement(node, context);
        case odata_annotation_core_1.TEXT_TYPE:
            return printText(node, true);
        default:
            return '';
    }
};
const join = (sep) => (values) => values.filter((value) => value !== undefined && value !== null).join(sep);
const joinWithColon = join(':');
const prefixName = (prefix, name) => joinWithColon([prefix, name]);
const prefixElementNameIfNeeded = (name, namespaceAlias, namespaces = {}) => {
    switch (namespaceAlias) {
        case odata_annotation_core_1.EDMX_NAMESPACE_ALIAS:
            return prefixName(namespaces[odata_annotation_core_1.EDMX_NAMESPACE_ALIAS], name);
        case odata_annotation_core_1.EDM_NAMESPACE_ALIAS:
            return prefixName(namespaces[odata_annotation_core_1.EDM_NAMESPACE_ALIAS], name);
        default:
            return prefixName(namespaces[odata_annotation_core_1.EDM_NAMESPACE_ALIAS], name);
    }
};
const printEmptyElement = (element, context) => {
    const name = prefixElementNameIfNeeded(element.name, element.namespaceAlias, context.namespaces);
    return (0, builders_1.concat)(['<', name, printAttributes(element.attributes), '/>']);
};
const printText = (node, doEscape) => {
    return doEscape ? (0, exports.escapeText)(node.text) : node.text;
};
const printAttribute = (name, value) => {
    if (value !== undefined && value !== null) {
        return `${name}="${(0, exports.escapeAttribute)(value)}"`;
    }
    return name;
};
const structuredExpressions = new Set([
    'Annotations',
    'Annotation',
    'Collection',
    'Record',
    'PropertyValue',
    'Apply',
    'LabeledElement'
]);
const dynamicExpressions = new Set([
    "If" /* Edm.If */,
    "Not" /* Edm.Not */,
    "And" /* Edm.And */,
    "Or" /* Edm.Or */,
    "Eq" /* Edm.Eq */,
    "Ne" /* Edm.Ne */,
    "Gt" /* Edm.Gt */,
    "Ge" /* Edm.Ge */,
    "Lt" /* Edm.Lt */,
    "Le" /* Edm.Le */,
    "In" /* Edm.In */
]);
const printElement = (element, context) => {
    const dynamicExpression = dynamicExpressions.has(element.name);
    const structured = structuredExpressions.has(element.name) || dynamicExpression;
    if ((element.content || []).length === 0) {
        return printEmptyElement(element, context);
    }
    const textNode = element.content[0].type === odata_annotation_core_1.TEXT_TYPE;
    const name = prefixElementNameIfNeeded(element.name, element.namespaceAlias, context.namespaces);
    const opening = (0, builders_1.concat)(['<', name, printAttributes(element.attributes), '>']);
    const closing = (0, builders_1.concat)(['</', name, '>']);
    const content = concatElementContent(element, structured, context);
    return (0, builders_1.concat)([opening, (0, builders_1.indent)(content), textNode && !structured ? '' : builders_1.hardline, closing]);
};
const printAttributes = (attributes = {}) => {
    const names = Object.keys(attributes);
    if (names.length === 0) {
        return '';
    }
    const parts = names.reduce((accumulator, name) => [...accumulator, builders_1.line, printAttribute(name, attributes[name].value)], []);
    return (0, builders_1.indent)((0, builders_1.concat)(parts));
};
const concatElementContent = (element, structured, context) => {
    let addHardLineBeforeText = true;
    return (0, builders_1.concat)(element.content.map((node, idx) => {
        let result;
        if (idx === 0 && node.type === odata_annotation_core_1.ELEMENT_TYPE) {
            addHardLineBeforeText = false;
        }
        if (node.type === odata_annotation_core_1.TEXT_TYPE) {
            const text = structured && addHardLineBeforeText ? builders_1.hardline : '';
            result = (0, builders_1.concat)([text, printText(node)]);
        }
        else {
            result = (0, builders_1.concat)([builders_1.hardline, printCsdlNode(node, context)]);
        }
        return result;
    }));
};
//# sourceMappingURL=csdl-to-xml.js.map