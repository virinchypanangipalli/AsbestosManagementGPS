"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printDocumentToString = exports.indent = exports.concat = exports.hardline = exports.line = void 0;
exports.line = { type: 'line', hard: false };
exports.hardline = { type: 'line', hard: true };
/**
 * Creates Concat.
 *
 * @param parts
 * @returns concat object
 */
function concat(parts) {
    return { type: 'concat', parts };
}
exports.concat = concat;
/**
 * Creates Indent.
 *
 * @param content
 * @returns indent object
 */
function indent(content) {
    return { type: 'indent', content };
}
exports.indent = indent;
const TRAILING_WHITESPACE_PATTERN = /\n[\t ]*$/;
/**
 * Serializes given document to string.
 *
 * @param document document object.
 * @param options serialization options
 * @returns stringified document
 */
function printDocumentToString(document, options) {
    const commands = [[{ length: 0, value: '', level: 0 }, document]];
    const fragments = [];
    while (commands.length > 0) {
        const command = commands.pop();
        if (command?.length) {
            const [indent, doc] = command;
            if (typeof doc === 'string') {
                processStringDoc(fragments, indent, doc);
            }
            else {
                processComplexDoc(fragments, commands, options, indent, doc);
            }
        }
    }
    return fragments.join('');
}
exports.printDocumentToString = printDocumentToString;
/**
 * Inserts given doc into fragments considering spacing.
 *
 * @param fragments fragments array
 * @param indent current indent data
 * @param doc new fragment
 */
function processStringDoc(fragments, indent, doc) {
    // trim trailing whitespace of previous line
    if (doc) {
        if (fragments.length === 0) {
            fragments.push(indent.value);
        }
        if (TRAILING_WHITESPACE_PATTERN.test(fragments[fragments.length - 1]) && doc.startsWith(indent.value)) {
            fragments[fragments.length - 1] = fragments[fragments.length - 1].replace(TRAILING_WHITESPACE_PATTERN, '\n');
        }
        fragments.push(doc);
    }
}
const newLine = '\n';
const whitespace = ' ';
/**
 * Processes Concat, Indent and Line elements.
 *
 * @param fragments
 * @param commands
 * @param options
 * @param indent
 * @param doc
 */
function processComplexDoc(fragments, commands, options, indent, doc) {
    switch (doc.type) {
        case 'concat': {
            for (let i = doc.parts.length - 1; i >= 0; i--) {
                commands.push([indent, doc.parts[i]]);
            }
            break;
        }
        case 'indent': {
            commands.push([addIndent(indent, options), doc.content]);
            break;
        }
        case 'line': {
            // trim trailing whitespace of previous line
            if (TRAILING_WHITESPACE_PATTERN.test(fragments[fragments.length - 1])) {
                fragments[fragments.length - 1] = fragments[fragments.length - 1].replace(TRAILING_WHITESPACE_PATTERN, '\n');
            }
            if (doc.hard) {
                fragments.push(newLine + indent.value);
            }
            else {
                fragments.push(whitespace);
            }
            break;
        }
        default:
    }
}
/**
 * Adds single indent.
 *
 * @param indent
 * @param options
 * @returns indent information
 */
function addIndent(indent, options) {
    return generateIndent(indent, 1, options);
}
/**
 * Generates indent by given level index.
 *
 * @param indent indent information
 * @param change adjustment level
 * @param options
 * @returns indentation information
 */
function generateIndent(indent, change, options) {
    const level = indent.level + change;
    let value = '';
    let length = 0;
    for (let i = 0; i < level; i++) {
        value += ' '.repeat(options.tabWidth);
        length += options.tabWidth;
    }
    return { value, length, level };
}
//# sourceMappingURL=builders.js.map