"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNewAnnotationFile = exports.serializeTarget = exports.serializeElement = exports.serializeAttribute = exports.serializeReference = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const csdl_to_xml_1 = require("./csdl-to-xml");
const namespaces_1 = require("./namespaces");
const namespaces = {
    Edmx: 'edmx'
};
/**
 * Serializes reference.
 *
 * @param data namespace data (must not be undefined)
 * @param parentStartPosition
 * @returns string
 */
function serializeReference(data, parentStartPosition = -1) {
    const includeSnippet = (0, odata_annotation_core_1.createElementNode)({
        name: "Include" /* Edmx.Include */,
        namespaceAlias: 'Edmx',
        attributes: {
            ["Namespace" /* Edmx.Namespace */]: (0, odata_annotation_core_1.createAttributeNode)("Namespace" /* Edmx.Namespace */, data.namespace)
        }
    });
    if (data.alias) {
        includeSnippet.attributes["Alias" /* Edmx.Alias */] = (0, odata_annotation_core_1.createAttributeNode)("Alias" /* Edmx.Alias */, data.alias);
    }
    const snippet = (0, odata_annotation_core_1.createElementNode)({
        name: "Reference" /* Edmx.Reference */,
        namespaceAlias: 'Edmx',
        content: [includeSnippet],
        attributes: {
            ["Uri" /* Edmx.Uri */]: (0, odata_annotation_core_1.createAttributeNode)("Uri" /* Edmx.Uri */, data.referenceUri)
        }
    });
    const indentLevel = (0, odata_annotation_core_1.getIndentLevel)(parentStartPosition, odata_annotation_core_1.printOptions.tabWidth) + 1;
    return ('\n' +
        (0, csdl_to_xml_1.printCsdlNodeToXmlString)(snippet, odata_annotation_core_1.printOptions, {
            cursorIndentLevel: indentLevel,
            namespaces
        }));
}
exports.serializeReference = serializeReference;
/**
 * Serializes attribute.
 *
 * @param attribute
 * @returns string
 */
function serializeAttribute(attribute) {
    return attribute.name + '="' + attribute.value + '"';
}
exports.serializeAttribute = serializeAttribute;
/**
 * Serializes element.
 *
 * @param element
 * @param parentElementStartPosition
 * @returns string
 */
function serializeElement(element, parentElementStartPosition = -1) {
    const indentLevel = (0, odata_annotation_core_1.getIndentLevel)(parentElementStartPosition, odata_annotation_core_1.printOptions.tabWidth) + 1;
    return '\n' + (0, csdl_to_xml_1.printCsdlNodeToXmlString)(element, odata_annotation_core_1.printOptions, { cursorIndentLevel: indentLevel });
}
exports.serializeElement = serializeElement;
/**
 * Serializes target.
 *
 * @param target
 * @param parentStartPostition
 * @returns string
 */
function serializeTarget(target, parentStartPostition = 0) {
    const indentLevel = (0, odata_annotation_core_1.getIndentLevel)(parentStartPostition, odata_annotation_core_1.printOptions.tabWidth) + 1;
    const terms = (0, csdl_to_xml_1.printCsdlNodeToXmlString)(target.terms, odata_annotation_core_1.printOptions, {
        cursorIndentLevel: indentLevel + 1
    });
    const annotationTargetSnippet = (0, odata_annotation_core_1.createElementNode)({
        name: "Annotations" /* Edm.Annotations */,
        attributes: {
            ["Target" /* Edm.Target */]: (0, odata_annotation_core_1.createAttributeNode)("Target" /* Edm.Target */, target.name)
        },
        content: [(0, odata_annotation_core_1.createTextNode)(terms)]
    });
    return ('\n' +
        (0, csdl_to_xml_1.printCsdlNodeToXmlString)(annotationTargetSnippet, odata_annotation_core_1.printOptions, {
            cursorIndentLevel: indentLevel
        }));
}
exports.serializeTarget = serializeTarget;
/**
 * Creates new annotation file object.
 *
 * @param aliasInfo
 * @param metadataUri
 * @param vocabularies
 * @returns annotation file object
 */
function getNewAnnotationFile(aliasInfo, metadataUri, vocabularies) {
    // build map with all edmx references
    const references = new Map();
    Object.keys(aliasInfo.aliasMap).forEach((nsOrAlias) => {
        if (aliasInfo.aliasMap[nsOrAlias] === nsOrAlias) {
            collectReferences(references, vocabularies, aliasInfo, nsOrAlias, metadataUri);
        }
        else if (nsOrAlias !== aliasInfo.currentFileAlias) {
            // alias
            if (!references.has(aliasInfo.aliasMap[nsOrAlias])) {
                references.set(aliasInfo.aliasMap[nsOrAlias], { alias: '', uri: '' });
            }
            const aliasMap = references.get(aliasInfo.aliasMap[nsOrAlias]);
            if (aliasMap) {
                aliasMap.alias = nsOrAlias;
            }
        }
    });
    // build references EDMX snippet
    let referencesSnippet = '';
    references.forEach((value, namespace) => {
        const alias = value.alias;
        const referenceUri = value.uri;
        const data = {
            alias,
            namespace,
            referenceUri
        };
        referencesSnippet += serializeReference(data, 0);
    });
    const schemaSnippet = (0, odata_annotation_core_1.createElementNode)({
        name: "Schema" /* Edm.Schema */,
        attributes: {
            ['xmlns']: (0, odata_annotation_core_1.createAttributeNode)('xmlns', namespaces_1.EDM_V4_NAMESPACE),
            ["Namespace" /* Edm.Namespace */]: (0, odata_annotation_core_1.createAttributeNode)("Namespace" /* Edm.Namespace */, aliasInfo.currentFileNamespace)
        },
        content: [
            (0, odata_annotation_core_1.createTextNode)('\n' +
                (0, odata_annotation_core_1.indent)(odata_annotation_core_1.printOptions.tabWidth, odata_annotation_core_1.printOptions.useTabs, 3) +
                'INSERT_TOKEN' +
                '\n' +
                (0, odata_annotation_core_1.indent)(odata_annotation_core_1.printOptions.tabWidth, odata_annotation_core_1.printOptions.useTabs, 2))
        ]
    });
    if (aliasInfo.currentFileAlias) {
        schemaSnippet.attributes["Alias" /* Edm.Alias */] = (0, odata_annotation_core_1.createAttributeNode)("Alias" /* Edm.Alias */, aliasInfo.currentFileAlias);
    }
    const dataServiceSnippet = (0, odata_annotation_core_1.createElementNode)({
        name: "DataServices" /* Edmx.DataServices */,
        namespaceAlias: 'Edmx',
        content: [schemaSnippet]
    });
    const rootElement = (0, odata_annotation_core_1.createElementNode)({
        name: "Edmx" /* Edmx.Edmx */,
        namespaceAlias: 'Edmx',
        attributes: {
            ['xmlns:edmx']: (0, odata_annotation_core_1.createAttributeNode)('xmlns:edmx', namespaces_1.EDMX_V4_NAMESPACE),
            ["Version" /* Edmx.Version */]: (0, odata_annotation_core_1.createAttributeNode)("Version" /* Edmx.Version */, '4.0')
        },
        content: [(0, odata_annotation_core_1.createTextNode)(referencesSnippet), dataServiceSnippet, (0, odata_annotation_core_1.createTextNode)('\n')]
    });
    const fileContent = (0, csdl_to_xml_1.printCsdlNodeToXmlString)(rootElement, odata_annotation_core_1.printOptions, {
        cursorIndentLevel: 0,
        namespaces
    }) + '\n';
    // find position of insert token
    const { lastLine, lastCharacter } = getLastPosition(fileContent.substring(0, fileContent.indexOf('INSERT_TOKEN')));
    return {
        fileContent: fileContent.replace('INSERT_TOKEN', ''),
        position: { line: lastLine, character: lastCharacter }
    };
}
exports.getNewAnnotationFile = getNewAnnotationFile;
/**
 * Returns last position data in given content.
 *
 * @param fileContent
 * @returns last position data
 */
function getLastPosition(fileContent) {
    const contentLines = fileContent.split('\n');
    const lastLine = contentLines.length - 1;
    const lastCharacter = contentLines[lastLine].length;
    return { lastLine, lastCharacter };
}
/**
 * Collects references.
 *
 * @param references references map
 * @param vocabularies vocabularies map
 * @param aliasInfo alias information
 * @param nsOrAlias namespace or alias
 * @param metadataUri md uri
 */
function collectReferences(references, vocabularies, aliasInfo, nsOrAlias, metadataUri) {
    // namespace
    if (nsOrAlias !== aliasInfo.currentFileNamespace) {
        if (!references.has(nsOrAlias)) {
            references.set(nsOrAlias, { alias: '', uri: '' });
        }
        const reference = references.get(nsOrAlias);
        if (reference) {
            const vocabulary = vocabularies.get(nsOrAlias);
            if (vocabulary) {
                reference.uri = vocabulary?.defaultUri;
                if (!reference.alias) {
                    reference.alias = vocabulary.defaultAlias;
                }
            }
            else {
                reference.uri = metadataUri; // TODO support multiple metadata Uris
            }
        }
    }
}
//# sourceMappingURL=serializer-edmx.js.map