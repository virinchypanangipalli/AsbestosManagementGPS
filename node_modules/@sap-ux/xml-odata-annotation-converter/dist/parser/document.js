"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDocument = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const range_1 = require("./range");
const element_getters_1 = require("./element-getters");
const attribute_getters_1 = require("./attribute-getters");
const escaping_1 = require("./escaping");
/**
 * Convert AST of an XML document to annotation document.
 *
 * @param uri Uri of the document.
 * @param ast XML document containing annotations.
 * @returns annotation file.
 */
function convertDocument(uri, ast) {
    if (ast.rootElement) {
        const dataServices = (0, element_getters_1.getElementsWithName)('DataServices', ast.rootElement);
        const schemas = dataServices.length ? (0, element_getters_1.getElementsWithName)('Schema', dataServices[0]) : [];
        const targets = schemas.reduce((acc, schema) => [...acc, ...convertSchema(schema)], []);
        const range = (0, range_1.transformElementRange)(ast.rootElement.position, ast.rootElement);
        const contentRange = (0, range_1.getGapRangeBetween)(ast.rootElement.syntax.openBody, ast.rootElement.syntax.closeName);
        const references = convertReferences(ast.rootElement);
        if (range) {
            const namespace = createNamespace(schemas[0]);
            const file = {
                type: 'annotation-file',
                uri,
                range,
                references,
                targets
            };
            if (contentRange) {
                file.contentRange = contentRange;
            }
            if (namespace) {
                file.namespace = namespace;
            }
            return file;
        }
    }
    return {
        type: 'annotation-file',
        uri,
        range: undefined,
        contentRange: undefined,
        references: [],
        targets: []
    };
}
exports.convertDocument = convertDocument;
/**
 * Creates namespace object.
 *
 * @param schema schema XML element
 * @returns Namespace object
 */
function createNamespace(schema) {
    if (!schema) {
        return;
    }
    const namespace = (0, attribute_getters_1.getElementAttributeByName)('Namespace', schema);
    const alias = (0, attribute_getters_1.getElementAttributeByName)('Alias', schema);
    if (!namespace?.value) {
        return;
    }
    const currentNamespace = {
        type: 'namespace',
        name: namespace.value,
        range: (0, range_1.transformElementRange)(schema.position, schema),
        nameRange: (0, range_1.transformRange)(namespace.syntax.value)
    };
    const contentRange = schema.syntax.openBody && schema.syntax.closeName
        ? (0, range_1.getGapRangeBetween)(schema.syntax.openBody, schema.syntax.closeName)
        : undefined;
    if (contentRange) {
        currentNamespace.contentRange = contentRange;
    }
    if (currentNamespace.nameRange) {
        (0, range_1.adjustRange)(currentNamespace.nameRange, 1, -1);
    }
    if (alias) {
        currentNamespace.alias = alias.value ?? '';
        currentNamespace.aliasRange = (0, range_1.transformRange)(alias.syntax.value);
        if (currentNamespace.aliasRange) {
            (0, range_1.adjustRange)(currentNamespace.aliasRange, 1, -1);
        }
    }
    return currentNamespace;
}
/**
 * Creates reference object from XML element.
 *
 * @param element EDMX XML Element
 * @returns references contained in the XML element
 */
function convertReferences(element) {
    const referenceElements = (0, element_getters_1.getElementsWithName)('Reference', element);
    const references = [];
    for (const referenceElement of referenceElements) {
        const uri = (0, attribute_getters_1.getElementAttributeByName)('Uri', referenceElement)?.value ?? undefined;
        const refRange = (0, range_1.transformRange)(referenceElement.position);
        for (const namespaceElement of (0, element_getters_1.getElementsWithName)('Include', referenceElement)) {
            const reference = createReference(namespaceElement, refRange, uri);
            if (reference) {
                references.push(reference);
            }
        }
    }
    return references;
}
/**
 * Creates referece.
 *
 * @param namespaceElement namespace XML element
 * @param range reference element range
 * @param uri reference uri
 * @returns reference object or undefined if namespace is not provided in the corresponding attribute
 */
function createReference(namespaceElement, range, uri) {
    const namespace = (0, attribute_getters_1.getElementAttributeByName)('Namespace', namespaceElement);
    const alias = (0, attribute_getters_1.getElementAttributeByName)('Alias', namespaceElement);
    if (!namespace?.value) {
        return;
    }
    const reference = {
        type: 'reference',
        name: namespace.value,
        nameRange: (0, range_1.transformRange)(namespace.syntax.value),
        range,
        uri
    };
    if (reference.nameRange) {
        (0, range_1.adjustRange)(reference.nameRange, 1, -1);
    }
    if (alias) {
        reference.alias = alias.value ?? '';
        reference.aliasRange = (0, range_1.transformRange)(alias.syntax.value);
        if (reference.aliasRange) {
            (0, range_1.adjustRange)(reference.aliasRange, 1, -1);
        }
    }
    return reference;
}
/**
 * Converts schema.
 *
 * @param schema Schema XML Element
 * @returns targets contained in the XML element
 */
function convertSchema(schema) {
    const targets = [];
    const annotationsElements = (0, element_getters_1.getElementsWithName)("Annotations" /* Edm.Annotations */, schema);
    for (const annotations of annotationsElements) {
        const targetAttribute = (0, attribute_getters_1.getElementAttributeByName)('Target', annotations);
        if (targetAttribute) {
            const targetName = targetAttribute.value ?? '';
            const targetNamePosition = (0, range_1.transformRange)(targetAttribute.syntax.value);
            if (targetNamePosition) {
                (0, range_1.adjustRange)(targetNamePosition, 1, -1);
                const terms = (0, element_getters_1.getElementsWithName)("Annotation" /* Edm.Annotation */, annotations)
                    .map(convertElement)
                    .filter((node) => node?.type === odata_annotation_core_1.ELEMENT_TYPE);
                const termsRange = annotations.syntax.closeName
                    ? (0, range_1.getGapRangeBetween)(annotations.syntax.openBody, annotations.syntax.closeName)
                    : undefined;
                const range = (0, range_1.transformElementRange)(annotations.position, annotations);
                const target = {
                    type: 'target',
                    name: targetName,
                    nameRange: targetNamePosition,
                    terms,
                    range,
                    termsRange
                };
                targets.push(target);
            }
        }
    }
    return targets;
}
/**
 * Returns namespace details.
 *
 * @param element XML element
 * @returns element default namespace if it exists
 */
function getNamespace(element) {
    if (element.ns) {
        const namespace = element.namespaces[element.ns];
        if (namespace) {
            return {
                alias: element.ns,
                uri: namespace
            };
        }
    }
    return undefined;
}
/**
 * Converts element.
 *
 * @param element XMLElement
 * @returns generic annotation file Element
 */
function convertElement(element) {
    const range = (0, range_1.transformElementRange)(element.position, element);
    const nameRange = getElementNameRange(element);
    const contentRange = element.syntax.openBody && element.syntax.closeName
        ? (0, range_1.getGapRangeBetween)(element.syntax.openBody, element.syntax.closeName)
        : undefined;
    const namespace = getNamespace(element);
    const textNodes = element.textContents ?? [];
    const elementNodes = element.subElements ?? [];
    const sortedContentNodes = [...textNodes, ...elementNodes].sort((a, b) => a.position.startOffset - b.position.endOffset);
    // merge adjacent text fragments into solid text node
    const children = mergeContentNodes(sortedContentNodes);
    const attributes = element.attributes.reduce((acc, attribute) => {
        if (!attribute.key) {
            return acc;
        }
        const value = attribute.value ? (0, escaping_1.removeEscapeSequences)(attribute.value) : '';
        const attributeNode = (0, odata_annotation_core_1.createAttributeNode)(attribute.key, value, (0, range_1.transformRange)(attribute.syntax.key), (0, range_1.transformRange)(attribute.syntax.value));
        if (attributeNode.valueRange) {
            (0, range_1.adjustRange)(attributeNode.valueRange, 1, -1);
        }
        acc[attribute.key] = attributeNode;
        return acc;
    }, {});
    return (0, odata_annotation_core_1.createElementNode)({
        name: element.name ?? '',
        range,
        nameRange,
        attributes,
        content: children.nodes,
        contentRange,
        namespace: namespace?.uri,
        namespaceAlias: namespace?.alias
    });
}
/**
 * Returns element name range.
 *
 * @param element XML element
 * @returns range
 */
function getElementNameRange(element) {
    if (element.syntax.openName) {
        return (0, range_1.transformRange)(element.syntax.openName);
    }
    if (element.name === null) {
        if (element.syntax.openBody) {
            // element name is missing: "< ></>"
            const range = (0, range_1.transformRange)(element.syntax.openBody);
            if (!range) {
                return undefined;
            }
            // element name starts 1 character after "<"
            range.start.character += 1;
            // element name range should cover only the single character after "<"
            range.end = odata_annotation_core_1.Position.create(range.start.line, range.start.character);
            return range;
        }
        else {
            // closing bracket is missing: "<"
            const range = (0, range_1.transformRange)(element.position);
            if (!range) {
                return undefined;
            }
            // name range should start after <, so we need to increment elements start range by 1
            range.start.character++;
            return range;
        }
    }
    return undefined;
}
/**
 * Converts text node.
 *
 * @param textNode XML text node
 * @returns annotation file TextNode
 */
function convertTextNode(textNode) {
    const range = (0, range_1.transformRange)(textNode.position);
    return (0, odata_annotation_core_1.createTextNode)(textNode.text ?? '', range);
}
/**
 * Merges content nodes.
 *
 * @param sortedContentNodes
 * @returns merged nodes data
 */
function mergeContentNodes(sortedContentNodes) {
    return sortedContentNodes.reduce((acc, child, index, array) => {
        if (child.type === 'XMLTextContent') {
            if (index + 1 < array.length && array[index + 1].type === 'XMLTextContent') {
                acc.textNodes.push(child);
            }
            else {
                const [first, ...textNodes] = [...acc.textNodes, child];
                const concatenatedTextNode = textNodes.reduce((accTextNode, textNode) => {
                    return {
                        ...accTextNode,
                        text: (accTextNode.text ?? '') + (textNode.text ?? ''),
                        position: {
                            ...accTextNode.position,
                            endColumn: textNode.position.endColumn,
                            endLine: textNode.position.endLine,
                            endOffset: textNode.position.endOffset
                        }
                    };
                }, first);
                acc.nodes.push(convertTextNode(concatenatedTextNode));
                acc.textNodes = [];
            }
        }
        else if (child.type === 'XMLElement') {
            acc.nodes.push(convertElement(child));
        }
        return acc;
    }, {
        textNodes: [],
        nodes: [],
        diagnostics: []
    });
}
//# sourceMappingURL=document.js.map