"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertMetadataDocument = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const attribute_getters_1 = require("./attribute-getters");
const range_1 = require("./range");
const element_getters_1 = require("./element-getters");
const EDMX_METADATA_ELEMENT_NAMES = new Set([
    "Schema" /* Edm.Schema */,
    "EntityType" /* Edm.EntityType */,
    "ComplexType" /* Edm.ComplexType */,
    "Property" /* Edm.Property */,
    "NavigationProperty" /* Edm.NavigationProperty */,
    "EntityContainer" /* Edm.EntityContainer */,
    "EntitySet" /* Edm.EntitySet */,
    "Singleton" /* Edm.Singleton */,
    "Function" /* Edm.Function */,
    "Action" /* Edm.Action */,
    "FunctionImport" /* Edm.FunctionImport */,
    "ActionImport" /* Edm.ActionImport */,
    "Parameter" /* Edm.Parameter */,
    "ReturnType" /* Edm.ReturnType */
]);
const ENTITY_TYPE_NAMES = new Set(["EntityType" /* Edm.EntityType */, "Singleton" /* Edm.Singleton */, "EntitySet" /* Edm.EntitySet */, "NavigationProperty" /* Edm.NavigationProperty */]);
const STRUCTURED_TYPE_NAMES = new Set([
    "Singleton" /* Edm.Singleton */,
    "EntitySet" /* Edm.EntitySet */,
    "NavigationProperty" /* Edm.NavigationProperty */,
    "ActionImport" /* Edm.ActionImport */,
    "FunctionImport" /* Edm.FunctionImport */
]);
const METADATA_ROOT_TYPE_NAMES = new Set([
    "EntityType" /* Edm.EntityType */,
    "ComplexType" /* Edm.ComplexType */,
    "Function" /* Edm.Function */,
    "Action" /* Edm.Action */,
    "EntityContainer" /* Edm.EntityContainer */
]);
const PARAMETER_TYPE_NAMES = new Set(["Property" /* Edm.Property */, "ReturnType" /* Edm.ReturnType */, "Parameter" /* Edm.Parameter */]);
const EDM_ENTITY_TYPE = 'Edm.EntityType';
const EDM_COMPLEX_TYPE = 'EDM_COMPLEX_TYPE';
/**
 * Traverses the XML document and collects metadata element definitions.
 *
 * @param uri Uri of the document.
 * @param document XML document containing metadata.
 * @returns an array of MetadataElements extracted from the XML document.
 */
function convertMetadataDocument(uri, document) {
    const root = document.rootElement;
    if (!root) {
        return [];
    }
    const aliasMap = getNamespaceMap(root);
    const dataServices = (0, element_getters_1.getElementsWithName)("DataServices" /* Edmx.DataServices */, root);
    const schemas = dataServices.length ? (0, element_getters_1.getElementsWithName)("Schema" /* Edm.Schema */, dataServices[0]) : [];
    const metadataElements = [];
    for (const schema of schemas) {
        convertSchema(schema, aliasMap, uri, metadataElements);
    }
    return metadataElements;
}
exports.convertMetadataDocument = convertMetadataDocument;
/**
 * Collects metadata element definitions from given schema.
 *
 * @param schema schema element
 * @param aliasMap alias map
 * @param uri Uri of the document
 * @param metadataElements metadata element collector array
 */
function convertSchema(schema, aliasMap, uri, metadataElements) {
    const namespace = (0, attribute_getters_1.getElementAttributeByName)('Namespace', schema)?.value;
    if (!namespace) {
        return;
    }
    const typeMap = {};
    // loop over all direct schema children and collect type information
    const currentNamespace = (0, attribute_getters_1.getAttributeValue)('Namespace', schema);
    for (const element of schema.subElements) {
        const name = (0, attribute_getters_1.getAttributeValue)('Name', element);
        let type = '';
        switch (element.name) {
            case "TypeDefinition" /* Edm.TypeDefinition */:
            case "EnumType" /* Edm.EnumType */:
                type = (0, attribute_getters_1.getAttributeValue)('UnderlyingType', element) || 'Edm.Int32';
                break;
            case "EntityType" /* Edm.EntityType */:
                type = EDM_ENTITY_TYPE;
                break;
            case "ComplexType" /* Edm.ComplexType */:
                type = EDM_COMPLEX_TYPE;
                break;
        }
        if (name && type) {
            typeMap[currentNamespace + '.' + name] = type;
        }
    }
    const associationMap = {};
    const associations = (0, element_getters_1.getElementsWithName)('Association', schema) ?? [];
    for (const association of associations) {
        const name = (0, attribute_getters_1.getAttributeValue)('Name', association);
        if (name) {
            associationMap[name] = createAssociation((0, element_getters_1.getElementsWithName)('End', association), aliasMap, namespace);
        }
    }
    const context = {
        namespace,
        typeMap,
        aliasMap,
        associationMap,
        parentPath: '',
        uri: uri
    };
    for (const child of schema.subElements) {
        const element = convertMetadataElement(context, child);
        if (element) {
            metadataElements.push(element);
        }
    }
}
/**
 *
 * @param context Conversion context
 * @param element Source XML element
 * @returns matching MetadataElement if it exists for the given XML element
 */
function convertMetadataElement(context, element) {
    if (!element.name || !EDMX_METADATA_ELEMENT_NAMES.has(element.name)) {
        return undefined;
    }
    const metadataElement = createMetadataNode(context, element);
    if (metadataElement) {
        const sortedContentNodes = [...element.subElements].sort((a, b) => a.position.startOffset - b.position.endOffset);
        if (!metadataElement.content) {
            metadataElement.content = [];
        }
        for (const child of sortedContentNodes) {
            const childElement = convertMetadataElement({
                ...context,
                parentPath: context.parentPath !== ''
                    ? `${context.parentPath}/${metadataElement.name}`
                    : metadataElement.name
            }, child);
            if (childElement) {
                metadataElement.content?.push(childElement);
            }
        }
    }
    return metadataElement;
}
/**
 *
 * @param context Conversion context
 * @param element Source XML element
 * @returns matching MetadataElement if it exists for the given XML element
 */
function createMetadataNode(context, element) {
    let typeAttrName;
    switch (element.name) {
        case "EntitySet" /* Edm.EntitySet */:
            typeAttrName = 'EntityType';
            break;
        case "FunctionImport" /* Edm.FunctionImport */:
            typeAttrName = 'Function'; // to make FunctionImport reference the Function
            break;
        case "ActionImport" /* Edm.ActionImport */:
            typeAttrName = 'Action'; // to make ActionImport reference the Action
            break;
        default:
            typeAttrName = 'Type';
    }
    let type = attributeValueToFullyQualifiedName(typeAttrName, context.aliasMap, context.namespace, element);
    if (!type) {
        if (element.name === "FunctionImport" /* Edm.FunctionImport */) {
            // OData V2: FunctionImport
            type = (0, attribute_getters_1.getAttributeValue)('ReturnType', element);
        }
        else if (element.name === "NavigationProperty" /* Edm.NavigationProperty */) {
            // OData V2: use association information to determine Type
            type = getTypeForNavigationProperty(context, element);
        }
    }
    const forAction = element.name === "Action" /* Edm.Action */ || element.name === "Function" /* Edm.Function */;
    return createMetadataElementNodeForType(context, element, type, forAction);
}
/**
 * Calculates type for navigation property based on association information.
 *
 * @param context context
 * @param element nav property XML element
 * @returns type or undefined
 */
function getTypeForNavigationProperty(context, element) {
    const relationship = attributeValueToFullyQualifiedName('Relationship', context.aliasMap, context.namespace, element);
    if (!relationship) {
        return undefined;
    }
    const associationName = relationship.split('.').pop();
    if (!associationName) {
        return undefined;
    }
    const association = context.associationMap[associationName];
    if (!association) {
        return undefined;
    }
    const toRole = attributeValueToFullyQualifiedName('ToRole', context.aliasMap, context.namespace, element);
    if (!toRole) {
        return undefined;
    }
    const role = association[toRole];
    if (role?.type) {
        return role.multiplicity === '*' ? `Collection(${role.type})` : role.type;
    }
    return undefined;
}
/**
 * Get OData target kinds for a metadata kind.
 *
 * @param elementKind - element kind
 * @param isCollectionValued - collection value flag
 * @returns OData target kinds.
 */
function getEdmTargetKinds(elementKind, isCollectionValued = false) {
    if (!elementKind) {
        return [];
    }
    const targetKinds = [];
    targetKinds.push(elementKind);
    if (elementKind === "FunctionImport" /* Edm.FunctionImport */) {
        // vocabulary and annotation files are defined based on OData v4, but are used to annotate both OData v2 and OData v4 metadata.
        // OData v2 does not have 'Action' but only 'FunctionImport'. Map to 'Action' to support annotating 'FunctionImport' with terms targeting actions.
        targetKinds.push("Action" /* Edm.Action */);
    }
    if (targetKinds.includes("EntitySet" /* Edm.EntitySet */) || isCollectionValued) {
        targetKinds.push("Collection" /* Edm.Collection */);
    }
    return targetKinds;
}
/**
 * @param context Conversion context
 * @param element Source XML element
 * @param type Fully qualified type name
 * @param forAction Indicates if overloads should be checked
 * @returns matching MetadataElement if it exists for the given XML element
 */
function createMetadataElementNodeForType(context, element, type, forAction = false) {
    if (element.name === null) {
        return undefined;
    }
    // build metadata element
    const metadataElementProperties = {
        isAnnotatable: true,
        kind: element.name,
        name: getMetadataElementName(context, element, forAction),
        isCollectionValued: !!type?.startsWith('Collection(') || element.name === "EntitySet" /* Edm.EntitySet */,
        isComplexType: element.name === "ComplexType" /* Edm.ComplexType */,
        isEntityType: ENTITY_TYPE_NAMES.has(element.name ?? ''),
        targetKinds: []
    };
    if (element.name === "EntityType" /* Edm.EntityType */) {
        const keys = getKeys(element);
        if (keys?.length) {
            metadataElementProperties.keys = keys;
        }
    }
    const targetKinds = getEdmTargetKinds(metadataElementProperties.kind, metadataElementProperties.isCollectionValued);
    metadataElementProperties.targetKinds.push(...targetKinds);
    // adjust metadata element based on type information
    const functionImportV2Nodes = adjustMetadataElement(context, element, type, metadataElementProperties) ?? [];
    const v2ActionFor = attributeValueToFullyQualifiedName('sap:action-for', context.aliasMap, context.namespace, element);
    if ("FunctionImport" /* Edm.FunctionImport */ === element.name && v2ActionFor) {
        // generate binding parameter sub node with name '_it'
        const bindingParameterProperties = {
            isAnnotatable: false, // should be used in path expressions only, not as annotation target
            kind: "Parameter" /* Edm.Parameter */,
            name: '_it',
            isCollectionValued: false,
            isComplexType: false,
            isEntityType: true,
            structuredType: v2ActionFor,
            targetKinds: getEdmTargetKinds("Parameter" /* Edm.Parameter */)
        };
        const attributePosition = (0, attribute_getters_1.getElementAttributeByName)('sap:action-for', element)?.position;
        const bindingParameterRange = (0, range_1.transformElementRange)(attributePosition ?? element.position, element);
        functionImportV2Nodes.push({
            path: `${context.parentPath}/${metadataElementProperties.name}/${bindingParameterProperties.name}`,
            location: bindingParameterRange ? odata_annotation_core_1.Location.create(context.uri, bindingParameterRange) : undefined,
            content: [],
            ...bindingParameterProperties
        });
    }
    const range = (0, range_1.transformElementRange)(element.position, element);
    return {
        path: context.parentPath
            ? `${context.parentPath}/${metadataElementProperties.name}`
            : metadataElementProperties.name,
        location: range ? odata_annotation_core_1.Location.create(context.uri, range) : undefined,
        content: functionImportV2Nodes,
        ...metadataElementProperties
    };
}
/**
 * Creates metadata element name.
 *
 * @param context context
 * @param element XML element
 * @param forAction boolen flag indicating processing of action element
 * @returns metadata element name
 */
function getMetadataElementName(context, element, forAction) {
    // determine metadata element name
    let metadataElementName = (0, attribute_getters_1.getAttributeValue)('Name', element);
    if (forAction) {
        if (element.name === "Action" /* Edm.Action */ && (0, attribute_getters_1.getAttributeValue)('IsBound', element) !== 'true') {
            metadataElementName += '()'; // unbound actions do not support overloading
        }
        else {
            metadataElementName = getOverloadName(context, element);
        }
    }
    if (METADATA_ROOT_TYPE_NAMES.has(element.name ?? '') && context.namespace) {
        metadataElementName = context.namespace + '.' + metadataElementName;
    }
    else if (element.name === "ReturnType" /* Edm.ReturnType */) {
        metadataElementName = '$ReturnType';
    }
    return metadataElementName;
}
/**
 * Returns primitive type name based on current type and element name.
 *
 * @param typeName type name
 * @param baseTypeName base type name
 * @param elementName element name
 * @returns primitive type name
 */
function getPrimitiveTypeName(typeName, baseTypeName, elementName) {
    let edmPrimitiveType = '';
    if (typeName.startsWith('Edm.')) {
        edmPrimitiveType = typeName; // original types namespace is Edm
    }
    else if (baseTypeName !== EDM_COMPLEX_TYPE &&
        baseTypeName !== EDM_ENTITY_TYPE &&
        elementName !== "FunctionImport" /* Edm.FunctionImport */ &&
        elementName !== "ActionImport" /* Edm.ActionImport */) {
        // original type is defined in metadata but based on a primitive type
        edmPrimitiveType = baseTypeName;
    }
    return edmPrimitiveType;
}
/**
 * Adjusts medatata element properties and returns V2 function import md nodes (in case of FunctionImport element) or empty array.
 *
 * @param context context
 * @param element element
 * @param type type
 * @param metadataElementProperties md element properties
 * @returns V2 function import md nodes
 */
function adjustMetadataElement(context, element, type, metadataElementProperties) {
    /**
     *  Converts to singular type name.
     *
     * @param fqTypeName Fully qualified name for a type.
     * @returns singular type name.
     */
    function getTypeName(fqTypeName) {
        // links always go to entityTypes/complexTypes/functions or actions, which are defined as direct container children
        // --> use fully qualified name as path with single segment (strip Collection())
        return fqTypeName.startsWith('Collection(') ? fqTypeName.slice(11, -1) : fqTypeName;
    }
    if (!type) {
        return undefined;
    }
    const typeName = getTypeName(type);
    const baseTypeName = context.typeMap[typeName] || typeName;
    // primitive type name
    const edmPrimitiveType = getPrimitiveTypeName(typeName, baseTypeName, element.name);
    if (edmPrimitiveType && element.name !== "FunctionImport" /* Edm.FunctionImport */) {
        metadataElementProperties.edmPrimitiveType = edmPrimitiveType;
    }
    // structured type name
    handleStructuredTypeElement(element, typeName, baseTypeName, metadataElementProperties);
    // function import
    if ("FunctionImport" /* Edm.FunctionImport */ === element.name && (0, attribute_getters_1.getAttributeValue)('ReturnType', element)) {
        const functionImportV2Nodes = [];
        const returnTypeProperties = getReturnTypeProperties(baseTypeName, type, typeName, edmPrimitiveType);
        const attributePosition = (0, attribute_getters_1.getElementAttributeByName)('ReturnType', element)?.position;
        const returnRange = (0, range_1.transformElementRange)(attributePosition ?? element.position, element);
        functionImportV2Nodes.push({
            path: `${context.parentPath}/${metadataElementProperties.name}/${returnTypeProperties.name}`,
            location: returnRange ? odata_annotation_core_1.Location.create(context.uri, returnRange) : undefined,
            content: [],
            ...returnTypeProperties
        });
        return functionImportV2Nodes;
    }
    return undefined;
}
/**
 *
 * @param element
 * @param typeName
 * @param baseTypeName
 * @param metadataElementProperties
 */
function handleStructuredTypeElement(element, typeName, baseTypeName, metadataElementProperties) {
    if (STRUCTURED_TYPE_NAMES.has(element.name ?? '') &&
        !(0, attribute_getters_1.getAttributeValue)('ReturnType', element) // exclude V2 FunctionImports
    ) {
        // type name contains reference to entityType, function or action
        metadataElementProperties.structuredType = typeName;
    }
    else if (PARAMETER_TYPE_NAMES.has(element.name ?? '')) {
        // handle property, parameter or returnType based on entity or complex type
        if (baseTypeName === EDM_COMPLEX_TYPE) {
            metadataElementProperties.isComplexType = true;
            metadataElementProperties.structuredType = typeName;
        }
        else if (baseTypeName === EDM_ENTITY_TYPE) {
            metadataElementProperties.isEntityType = true;
            metadataElementProperties.structuredType = typeName;
        }
    }
}
/**
 *
 * @param baseTypeName
 * @param type
 * @param typeName
 * @param edmPrimitiveType
 * @returns
 */
function getReturnTypeProperties(baseTypeName, type, typeName, edmPrimitiveType) {
    // FunctionImport in Data V2: type contains ReturnType attribute - build sub node for it
    const isCollectionValued = type.startsWith('Collection(');
    const returnTypeProperties = {
        isAnnotatable: true,
        kind: "ReturnType" /* Edm.ReturnType */,
        name: '$ReturnType',
        isCollectionValued,
        isComplexType: baseTypeName === EDM_COMPLEX_TYPE,
        isEntityType: baseTypeName === EDM_ENTITY_TYPE,
        targetKinds: getEdmTargetKinds("ReturnType" /* Edm.ReturnType */, isCollectionValued)
    };
    if (edmPrimitiveType) {
        returnTypeProperties.edmPrimitiveType = edmPrimitiveType;
    }
    if ([EDM_ENTITY_TYPE, EDM_COMPLEX_TYPE].includes(baseTypeName)) {
        returnTypeProperties.structuredType = typeName;
    }
    return returnTypeProperties;
}
/**
 * Returns overload name.
 *
 * @param context Conversion context
 * @param element Source XML element
 * @returns matching MetadataElement if it exists for the given XML element
 */
function getOverloadName(context, element) {
    // generate overload name MyFunction(MySchema.MyBindingParamType,First.NonBinding.ParamType)
    const name = (0, attribute_getters_1.getAttributeValue)('Name', element);
    let parameterSubElements = element.subElements.filter((subElement) => subElement.name === "Parameter" /* Edm.Parameter */);
    if (element.name === "Action" /* Edm.Action */) {
        parameterSubElements = parameterSubElements.slice(0, 1);
    }
    const parameterTypes = parameterSubElements.map((parameterElement) => attributeValueToFullyQualifiedName('Type', context.aliasMap, context.namespace, parameterElement));
    return name + '(' + parameterTypes.join(',') + ')';
}
/**
 * Return names of child key elements.
 *
 * @param element Source XML element
 * @returns an array of PropertyRef names
 */
function getKeys(element) {
    // find all PropertyRef sub elements of Key sub element and collect their Name attribute
    // (there should be at most a single 'Key' sub element)
    let keys = [];
    const keyElements = (element.subElements || []).filter((subElement) => subElement.name === 'Key');
    if (keyElements?.length) {
        keys = keyElements[0].subElements
            .filter((subElement) => subElement.name === 'PropertyRef')
            .map((propRefElement) => (0, attribute_getters_1.getAttributeValue)('Name', propRefElement));
    }
    return keys;
}
/**
 * Parses and converts attribute value to fully qualified name.
 *
 * @param attributeName
 * @param namespaceMap
 * @param currentNamespace
 * @param element
 * @returns fully qualified name or undefined
 */
function attributeValueToFullyQualifiedName(attributeName, namespaceMap, currentNamespace, element) {
    const attributeValue = (0, attribute_getters_1.getAttributeValue)(attributeName, element);
    if (attributeValue === '') {
        return undefined;
    }
    const parsedIdentifier = (0, odata_annotation_core_1.parseIdentifier)(attributeValue);
    const fullyQualifiedName = (0, odata_annotation_core_1.toFullyQualifiedName)(namespaceMap, currentNamespace, parsedIdentifier);
    return fullyQualifiedName ?? attributeValue;
}
/**
 * Creates namespace map from given container XML element.
 *
 * @param element container XML element
 * @returns namespace map
 */
function getNamespaceMap(element) {
    const references = (0, element_getters_1.getElementsWithName)('Reference', element);
    const dataServices = (0, element_getters_1.getElementsWithName)('DataServices', element);
    const schemas = dataServices.length ? (0, element_getters_1.getElementsWithName)('Schema', dataServices[0]) : [];
    const aliasMap = {};
    const includes = references.reduce((acc, reference) => [...acc, ...(0, element_getters_1.getElementsWithName)('Include', reference)], []);
    for (const namespaceElement of [...includes, ...schemas]) {
        const namespace = (0, attribute_getters_1.getElementAttributeByName)('Namespace', namespaceElement)?.value;
        const alias = (0, attribute_getters_1.getElementAttributeByName)('Alias', namespaceElement)?.value;
        if (namespace) {
            aliasMap[namespace] = namespace;
            if (alias) {
                aliasMap[alias] = namespace;
            }
        }
    }
    return aliasMap;
}
/**
 * Creates association data object from given association ends XML elements.
 *
 * @param ends XML elements representing association ends
 * @param aliasMap alias map
 * @param currentNamespace namespace
 * @returns association data object
 */
function createAssociation(ends, aliasMap, currentNamespace) {
    const association = {};
    for (const end of ends) {
        const role = attributeValueToFullyQualifiedName('Role', aliasMap, currentNamespace, end);
        const type = attributeValueToFullyQualifiedName('Type', aliasMap, currentNamespace, end);
        const multiplicity = (0, attribute_getters_1.getAttributeValue)('Multiplicity', end);
        if (role && type && multiplicity) {
            association[role] = {
                type,
                multiplicity
            };
        }
    }
    return association;
}
//# sourceMappingURL=metadata.js.map