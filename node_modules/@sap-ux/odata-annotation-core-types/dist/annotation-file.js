"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReference = exports.createNamespace = exports.createTarget = exports.GHOST_FILENAME_PREFIX = exports.createElementNode = exports.createTextNode = exports.createAttributeNode = exports.ANNOTATION_FILE_TYPE = exports.TARGET_TYPE = exports.NAMESPACE_TYPE = exports.REFERENCE_TYPE = exports.EDM_NAMESPACE_ALIAS = exports.EDMX_NAMESPACE_ALIAS = exports.ELEMENT_TYPE = exports.MultilineType = exports.TEXT_TYPE = exports.ATTRIBUTE_TYPE = void 0;
/**
 * representation of an XML node
 */
exports.ATTRIBUTE_TYPE = 'attribute';
exports.TEXT_TYPE = 'text';
var MultilineType;
(function (MultilineType) {
    /**
     * Processor should strip all the indentation before using the value
     */
    MultilineType["StripIndentation"] = "StripIndentation";
    /**
     * Processor should keep the indentation as a part of the value
     */
    MultilineType["KeepIndentation"] = "KeepIndentation";
})(MultilineType || (exports.MultilineType = MultilineType = {}));
exports.ELEMENT_TYPE = 'element';
exports.EDMX_NAMESPACE_ALIAS = 'Edmx';
exports.EDM_NAMESPACE_ALIAS = 'Edm';
exports.REFERENCE_TYPE = 'reference';
exports.NAMESPACE_TYPE = 'namespace';
exports.TARGET_TYPE = 'target';
exports.ANNOTATION_FILE_TYPE = 'annotation-file';
/**
 * Creates attribute node.
 *
 * @param name name
 * @param value value
 * @param nameRange name range
 * @param valueRange value range
 * @returns attribute node object
 */
function createAttributeNode(name, value, nameRange, valueRange) {
    const attribute = {
        type: exports.ATTRIBUTE_TYPE,
        name,
        value
    };
    if (nameRange) {
        attribute.nameRange = nameRange;
    }
    if (valueRange) {
        attribute.valueRange = valueRange;
    }
    return attribute;
}
exports.createAttributeNode = createAttributeNode;
/**
 * Creates text node.
 *
 * @param text text
 * @param range text range
 * @param fragmentRanges text fragment ranges
 * @param multilineType - multiline type
 * @returns text node object
 */
function createTextNode(text, range, fragmentRanges, multilineType) {
    const node = { type: exports.TEXT_TYPE, text };
    if (range) {
        node.range = range;
    }
    if (fragmentRanges) {
        node.fragmentRanges = fragmentRanges;
    }
    if (multilineType) {
        node.multilineType = multilineType;
    }
    return node;
}
exports.createTextNode = createTextNode;
/**
 * Creates element node.
 *
 * @param param0  object with parameters
 * @param param0.name  name
 * @param param0.range  range
 * @param param0.nameRange  name range
 * @param param0.attributes  attributes
 * @param param0.content  content
 * @param param0.contentRange  content range
 * @param param0.namespace  namespace
 * @param param0.namespaceAlias  alias
 * @returns Element object
 */
function createElementNode({ name, range, nameRange, attributes, content, contentRange, namespace, namespaceAlias }) {
    const node = {
        type: exports.ELEMENT_TYPE,
        name,
        attributes: attributes ?? {},
        content: content ?? []
    };
    if (range) {
        node.range = range;
    }
    if (nameRange) {
        node.nameRange = nameRange;
    }
    if (contentRange) {
        node.contentRange = contentRange;
    }
    if (namespace) {
        node.namespace = namespace;
    }
    if (namespaceAlias) {
        node.namespaceAlias = namespaceAlias;
    }
    return node;
}
exports.createElementNode = createElementNode;
exports.GHOST_FILENAME_PREFIX = '!';
/**
 * Builds empty target (generic annotation file format).
 *
 * @param path - target name
 * @returns object - empty target
 */
function createTarget(path) {
    return { type: 'target', name: path, terms: [], range: undefined, nameRange: undefined, termsRange: undefined };
}
exports.createTarget = createTarget;
/**
 * Builds empty namespace (generic annotation file format).
 *
 * @param namespace - namespace name
 * @param alias - alias name
 * @param ranges - object with ranges
 * @param ranges.range - element range
 * @param ranges.nameRange - name range
 * @param ranges.aliasRange alias range
 * @param ranges.contentRange - content range
 * @returns Namespace obejct
 */
function createNamespace(namespace, alias, ranges) {
    const { aliasRange, contentRange, nameRange, range } = ranges ?? {};
    return {
        type: 'namespace',
        name: namespace,
        alias,
        range,
        nameRange,
        aliasRange,
        contentRange
    };
}
exports.createNamespace = createNamespace;
/**
 * Builds empty reference (generic annotation file format).
 *
 * @param name reference name
 * @param alias alias
 * @param uri uri
 * @param ranges object with ranges
 * @param ranges.range - element range
 * @param ranges.nameRange - name range
 * @param ranges.aliasRange alias range
 * @param ranges.uriRange - uri range
 * @returns reference onject
 */
function createReference(name, alias, uri, ranges) {
    const { aliasRange, uriRange, nameRange, range } = ranges ?? {};
    return {
        type: 'reference',
        name,
        alias,
        uri,
        range,
        nameRange,
        aliasRange,
        uriRange
    };
}
exports.createReference = createReference;
//# sourceMappingURL=annotation-file.js.map