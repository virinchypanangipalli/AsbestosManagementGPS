"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toAnnotationFile = exports.toTargetMap = exports.toTarget = exports.toAssignment = exports.adjustCdsTermNames = exports.TARGET_TYPE = void 0;
const text_document_utils_1 = require("@sap-ux/text-document-utils");
const cds_annotation_parser_1 = require("@sap-ux/cds-annotation-parser");
const annotation_1 = require("./annotation");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
var odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
Object.defineProperty(exports, "TARGET_TYPE", { enumerable: true, get: function () { return odata_annotation_core_types_1.TARGET_TYPE; } });
const SERVICE_NAME_PLACEHOLDER = '<ServiceName>';
/**
 * Adapts the segments of an array of Identifiers based on a new name.
 *
 * @param segments - The array of Identifier segments to adapt.
 * @param newName - The new name to use for adaptation.
 * If undefined, the segments will be cleared.
 */
function adaptSegments(segments, newName) {
    const newSegments = newName ? newName.split('.') : [];
    newSegments.forEach((internalSegment, index) => {
        if (segments[index]) {
            segments[index].value = internalSegment;
        }
    });
    // TODO adapt ranges ?
    if (newSegments.length > segments.length) {
        newSegments.slice(segments.length).forEach((newSegment) => {
            segments.push({ type: 'identifier', value: newSegment });
        });
    }
    else if (newSegments.length < segments.length) {
        segments.splice(newSegments.length, segments.length - newSegments.length);
    }
}
const adjustCdsTermNames = (assignment, cdsVocabulary) => {
    if (assignment?.type === cds_annotation_parser_1.ANNOTATION_TYPE) {
        if (cdsVocabulary.nameMap.has(assignment.term.value)) {
            const internalTermName = cdsVocabulary.nameMap.get(assignment.term.value);
            assignment.term.value = internalTermName ?? '';
            adaptSegments(assignment.term.segments, internalTermName);
        }
        else if (assignment.term.segments.length > 2 &&
            cdsVocabulary.groupNames.has(assignment.term.segments[0].value)) {
            // value help e.g. for @cds.persistence.ex| - avoid flattening logic later on by replacing this with truncated CDS term
            // (use name convention for building internal cds term names i.e. cds.persistence.exists => CDS.CdsPersistenceExists)
            const adaptedSegments = assignment.term.segments.map((segment) => segment.value.slice(0, 1).toUpperCase() + segment.value.slice(1));
            const internalTermName = cdsVocabulary.alias + '.' + adaptedSegments.join('');
            assignment.term.value = internalTermName;
            adaptSegments(assignment.term.segments, internalTermName);
        }
    }
    else if (assignment?.type === cds_annotation_parser_1.ANNOTATION_GROUP_TYPE && cdsVocabulary.groupNames.has(assignment.name.value)) {
        // only CDS annotations ? set group name to CDS vocabulary alias and goup item name to internal term name
        const nonCdsItems = (assignment?.items?.items || []).filter((groupItem) => !cdsVocabulary.nameMap.has(assignment.name.value + '.' + groupItem.term.value));
        if (nonCdsItems.length === 0 && cdsVocabulary.nameMap) {
            (assignment?.items?.items || []).forEach((groupItem) => {
                const internalTermName = getInternalTermName(cdsVocabulary, groupItem, assignment);
                groupItem.term.value = internalTermName ?? '';
                adaptSegments(groupItem.term.segments, internalTermName);
            });
            assignment.name.value = cdsVocabulary.alias;
        }
    }
    return assignment;
};
exports.adjustCdsTermNames = adjustCdsTermNames;
/**
 * Get the internal term name from the CDS vocabulary and group item.
 *
 * @param cdsVocabulary - The CDS vocabulary containing nameMap and alias.
 * @param groupItem - The group item annotation.
 * @param assignment - assignment name value
 * @returns The internal term name, or undefined if not found.
 */
function getInternalTermName(cdsVocabulary, groupItem, assignment) {
    if (cdsVocabulary?.nameMap && groupItem) {
        const assignmentName = assignment.name.value;
        const termValue = groupItem.term.value;
        const fullName = assignmentName + '.' + termValue;
        const fullNameFromMap = cdsVocabulary.nameMap.get(fullName);
        if (fullNameFromMap) {
            return fullNameFromMap.slice(cdsVocabulary.alias.length + 1);
        }
    }
    return undefined;
}
const toAssignment = (annotation, vocabularyService) => {
    // Work around solution: CDS returns annotation text along with entity type property
    let text = annotation.text;
    if (annotation.range &&
        annotation.carrier?.range &&
        (0, odata_annotation_core_1.positionContained)(annotation.range, annotation.carrier.range.start)) {
        text = annotation.text.substring(0, annotation.text.length - (annotation.carrier.range.end.character - annotation.carrier.range.start.character));
    }
    // end of work around solution
    const assignment = (0, cds_annotation_parser_1.parse)(text, text_document_utils_1.Position.create(annotation.line, annotation.character));
    (0, exports.adjustCdsTermNames)(assignment, vocabularyService.cdsVocabulary);
    return assignment;
};
exports.toAssignment = toAssignment;
const toTarget = (carrier, carrierName, compilerFacade) => {
    const kind = Array.isArray(carrier?.definitions)
        ? carrier?.definitions[0].kind
        : carrier?.definitions?.kind || 'entity';
    if (['entity', 'view'].includes(kind)) {
        carrierName = compilerFacade?.convertNameToEdmx(carrierName) ?? carrierName;
    }
    return { type: odata_annotation_core_1.TARGET_TYPE, name: carrierName, nameRange: carrier?.range, assignments: [], kind };
};
exports.toTarget = toTarget;
const toTargetMap = (fileIndex, uri, vocabularyService, cdsCompilerFacade) => {
    const targetMap = prepareTargetMap(fileIndex, vocabularyService, cdsCompilerFacade);
    targetMap.forEach((value) => {
        // Ensure value.range is defined before using it
        if (value.range) {
            // Adjust target range
            const { start, end } = value.assignments.reduce((range, assignment) => {
                if (assignment.range && (0, odata_annotation_core_1.isBefore)(assignment.range.start, range.start)) {
                    range.start = (0, cds_annotation_parser_1.copyPosition)(assignment.range.start);
                }
                if (assignment.range && (0, odata_annotation_core_1.isBefore)(range.end, assignment.range.end)) {
                    range.end = (0, cds_annotation_parser_1.copyPosition)(assignment.range.end);
                }
                return range;
            }, (0, cds_annotation_parser_1.copyRange)(value.range));
            value.range = text_document_utils_1.Range.create(start, end);
        }
    });
    let references = [];
    let namespace;
    const namespaces = cdsCompilerFacade?.getNamespaceAndReference(uri);
    if (namespaces) {
        namespace = namespaces.namespace;
        references = namespaces.references;
    }
    return { targetMap, references, namespace };
};
exports.toTargetMap = toTargetMap;
const toAnnotationFile = (fileUri, vocabularyService, cdsAnnotationFile, metadataCollector, position, propagationMap) => {
    const supportedVocabularies = [...vocabularyService.getVocabularies().values()];
    const returnValue = {
        file: {
            type: 'annotation-file',
            uri: fileUri,
            namespace: cdsAnnotationFile.namespace,
            targets: [],
            contentRange: text_document_utils_1.Range.create(0, 0, 0, 0),
            range: text_document_utils_1.Range.create(0, 0, 0, 0),
            references: [
                ...cdsAnnotationFile.references,
                ...supportedVocabularies.map((vocabulary) => ({
                    type: odata_annotation_core_1.REFERENCE_TYPE,
                    name: vocabulary.namespace,
                    alias: vocabulary.defaultAlias
                }))
            ]
        }
    };
    let diagnostics = [];
    returnValue.file.targets = [...cdsAnnotationFile.targetMap].map(([, value], targetIndex) => {
        const { terms, mdPathSet, diag } = convertTargetAnnotations(value, vocabularyService, returnValue, targetIndex, position);
        addMdPathsFromAnnotations(terms, mdPathSet);
        diagnostics = diagnostics.concat(diag);
        if (position && !returnValue.pointer && (0, odata_annotation_core_1.positionContained)(value.range, position)) {
            returnValue.pointer = ['', 'targets', targetIndex].join('/');
            returnValue.nodeRange = value.range;
        }
        const { edmxPath, collectorKey } = metadataCollector.facade
            ? metadataCollector.facade.collectMetadataForAbsolutePath(value.name, value.kind, metadataCollector)
            : { edmxPath: value.name, collectorKey: '' };
        collectRelativePaths(edmxPath, collectorKey, mdPathSet, metadataCollector);
        if (value.range) {
            setFileRange(returnValue, value.range);
            setContentRange(returnValue, value.range);
        }
        return {
            type: odata_annotation_core_1.TARGET_TYPE,
            name: edmxPath,
            nameRange: value.nameRange ?? undefined,
            range: value.range,
            termsRange: value.range,
            terms
        };
    });
    returnValue.diagnostics = diagnostics;
    checkGhostTarget(returnValue, propagationMap);
    return returnValue;
};
exports.toAnnotationFile = toAnnotationFile;
/**
 * Sets the end position of the file range in the return value.
 *
 * @param returnValue - The return value object.
 * @param range - The range to copy the end position from.
 */
function setFileRange(returnValue, range) {
    if (returnValue.file.range) {
        returnValue.file.range.end = (0, cds_annotation_parser_1.copyPosition)(range.end);
    }
}
/**
 * Sets the end position of the content range in the return value.
 *
 * @param returnValue - The return value object.
 * @param range - The range to copy the end position from.
 */
function setContentRange(returnValue, range) {
    if (returnValue.file.contentRange) {
        returnValue.file.contentRange.end = (0, cds_annotation_parser_1.copyPosition)(range.end);
    }
}
/**
 * Converts target annotations from a Target node into Element nodes.
 *
 * @param value - The Target node containing annotations.
 * @param vocabularyService - The vocabulary service for term resolution.
 * @param returnValue - The ReturnValue object to store additional information.
 * @param targetIndex - The index of the target within the context.
 * @param [position] - The optional position within the document for diagnostics.
 * @returns Returns an object containing the converted terms, metadata path set, and diagnostics.
 * @property {Element[]} terms - The array of converted Element nodes representing the terms.
 * @property {Set<string>} mdPathSet - The set of metadata paths extracted from the converted terms.
 * @property {Diagnostic[]} diag - The array of diagnostics generated during conversion.
 */
function convertTargetAnnotations(value, vocabularyService, returnValue, targetIndex, position) {
    let diag = [];
    const mdPathSet = new Set();
    const terms = value.assignments.reduce((acc, assignment) => {
        const options = {
            vocabularyService
        };
        if (position && assignment.range && (0, odata_annotation_core_1.positionContained)(assignment.range, position)) {
            options.position = position;
        }
        const { nodeRange, terms, pointer, pathSet, diagnostics } = (0, annotation_1.convertAnnotation)(assignment, options);
        if (diagnostics?.length > 0) {
            diag = diag.concat(diagnostics);
        }
        if (options.position) {
            // TODO: clean this up
            if (pointer) {
                const [innerIndex, ...rest] = pointer.split('/').slice(1);
                const adjustedTermIndex = acc.length + parseInt(innerIndex, 10);
                returnValue.pointer = ['', 'targets', targetIndex, 'terms', adjustedTermIndex, ...rest].join('/');
                // if there is no pointer, then node range is meaningless
                returnValue.nodeRange = nodeRange;
            }
            else if (assignment.type === cds_annotation_parser_1.ANNOTATION_GROUP_TYPE) {
                returnValue.pointer = ['', 'targets', targetIndex].join('/');
                // if there is no pointer, then node range is meaningless
                returnValue.nodeRange = assignment.items.range;
            }
        }
        (pathSet ?? new Set()).forEach((path) => {
            let mdPath = path.split('@')[0];
            if (mdPath.endsWith('/')) {
                mdPath = mdPath.slice(0, -1);
            }
            if (mdPath) {
                mdPathSet.add(mdPath);
            }
        });
        return [...acc, ...terms];
    }, []);
    return { terms, mdPathSet, diag };
}
/**
 *
 * @param returnValue - The return value containing file targets.
 * @param [propagationMap] - The map of propagated targets.
 */
function checkGhostTarget(returnValue, propagationMap) {
    if (propagationMap) {
        const sourceTargets = returnValue.file.targets;
        const ghostTargets = [];
        sourceTargets.forEach((target) => {
            if (propagationMap[target.name]) {
                Object.keys(propagationMap[target.name]).forEach((propagatedTargetName) => {
                    const ghostTarget = { ...target };
                    ghostTarget.name = propagatedTargetName;
                    ghostTargets.push(ghostTarget);
                });
            }
        });
        returnValue.file.targets = ghostTargets;
    }
}
/**
 *
 * @param valueListParameterRecordElement record element inside value list information.
 * @returns value list property path or undefined.
 */
function getValueListPropertyPathValue(valueListParameterRecordElement) {
    let pathValue;
    const prop = getRecordPropertyElement(valueListParameterRecordElement, 'ValueListProperty');
    if (prop) {
        const valueAttr = (0, odata_annotation_core_1.getElementAttribute)(prop, "String" /* Edm.String */);
        if (valueAttr) {
            pathValue = valueAttr.value;
        }
        else {
            const pathNodes = (0, odata_annotation_core_1.elementsWithName)("String" /* Edm.String */, prop);
            if (pathNodes.length) {
                pathValue = (0, odata_annotation_core_1.getSingleTextNode)(pathNodes[0])?.text;
            }
        }
    }
    return pathValue;
}
const getRecordPropertyElement = (recordElement, propertyName) => {
    return (recordElement?.content ?? []).find((child) => child.type === odata_annotation_core_1.ELEMENT_TYPE &&
        child.name === "PropertyValue" /* Edm.PropertyValue */ &&
        (0, odata_annotation_core_1.getElementAttributeValue)(child, "Property" /* Edm.Property */) === propertyName);
};
/**
 *
 * @param valueListRecordElement record element inside value list information.
 * @returns value of value list CollectionPath
 */
function getValueListCollectionPathValue(valueListRecordElement) {
    let collectionPath;
    const collectionPathProperty = getRecordPropertyElement(valueListRecordElement, 'CollectionPath');
    if (collectionPathProperty) {
        const valueAttr = (0, odata_annotation_core_1.getElementAttribute)(collectionPathProperty, "String" /* Edm.String */);
        if (valueAttr) {
            collectionPath = valueAttr.value;
        }
        else {
            const stringNodes = (0, odata_annotation_core_1.elementsWithName)("String" /* Edm.String */, collectionPathProperty);
            if (stringNodes.length) {
                collectionPath = (0, odata_annotation_core_1.getSingleTextNode)(stringNodes[0])?.text;
            }
        }
    }
    return collectionPath;
}
/**
 *
 * @param term valueList term element
 * @returns value list properties e.g collection path, parameters.
 */
function extractValueListPropertiesFromAnnotation(term) {
    const result = { collectionPath: '', parameters: [] };
    try {
        const mainRecord = (0, odata_annotation_core_1.elementsWithName)("Record" /* Edm.Record */, term)[0];
        if (mainRecord) {
            const collectionPath = getValueListCollectionPathValue(mainRecord);
            if (collectionPath) {
                result.collectionPath = collectionPath;
            }
            const params = getRecordPropertyElement(mainRecord, 'Parameters');
            if (params) {
                const collection = (0, odata_annotation_core_1.elementsWithName)("Collection" /* Edm.Collection */, params)[0];
                if (collection) {
                    result.parameters.push(...collectAllValueListProperty(collection));
                }
            }
        }
    }
    catch (e) {
        // nothing to do
    }
    return result;
}
/**
 *
 * @param collection collection inside valueList Term
 * @returns list of all value list properties in string array.
 */
function collectAllValueListProperty(collection) {
    const parameters = [];
    (0, odata_annotation_core_1.elementsWithName)("Record" /* Edm.Record */, collection).forEach((rec) => {
        const recType = (0, odata_annotation_core_1.getElementAttributeValue)(rec, "Type" /* Edm.Type */) ?? '';
        if (recType) {
            const valueListProperty = getValueListPropertyPathValue(rec);
            if (recType.indexOf('ValueListParameter') >= 0) {
                if (valueListProperty) {
                    parameters.push(valueListProperty);
                }
            }
        }
    });
    return parameters;
}
/**
 *
 * @param terms - An array of elements representing terms with annotations.
 * @param mdPathSet - The set to which metadata paths are added.
 */
function addMdPathsFromAnnotations(terms, mdPathSet) {
    terms
        .filter((t) => ['Common.ValueList', 'com.sap.vocabularies.Common.v1.ValueList'].includes((0, odata_annotation_core_1.getElementAttributeValue)(t, "Term" /* Edm.Term */)))
        .forEach((term) => {
        const valueListData = extractValueListPropertiesFromAnnotation(term);
        if (valueListData.collectionPath) {
            mdPathSet.add(`${SERVICE_NAME_PLACEHOLDER}/${valueListData.collectionPath}`);
            valueListData.parameters.forEach((p) => {
                if (p) {
                    mdPathSet.add(`${SERVICE_NAME_PLACEHOLDER}/${valueListData.collectionPath}/${p}`);
                }
            });
        }
    });
}
/**
 * Prepares a map of targets based on annotation assignments.
 *
 * @param fileIndex - The file index containing annotation assignments.
 * @param vocabularyService - The vocabulary service for resolving types.
 * @param [compilerFacade] - Optional compiler facade for additional functionality.
 * @returns A map where the keys are stringified annotation ranges,
 *          and the values are targets with associated assignments.
 */
function prepareTargetMap(fileIndex, vocabularyService, compilerFacade) {
    const targetMap = new Map();
    for (const annotation of fileIndex.annotationAssignments) {
        const assignment = (0, exports.toAssignment)(annotation, vocabularyService);
        updateTargetMap(annotation, compilerFacade, assignment, targetMap);
    }
    return targetMap;
}
/**
 * Update the target map based on the given annotation and assignment.
 *
 * @param annotation - The annotation containing the carrier information.
 * @param compilerFacade - The CDS compiler facade.
 * @param assignment - The assignment associated with the annotation.
 * @param targetMap - The target map to update.
 */
function updateTargetMap(annotation, compilerFacade, assignment, targetMap) {
    if (annotation.carrier) {
        const { range } = annotation.carrier;
        const id = JSON.stringify(range);
        if (targetMap.has(id)) {
            const target = targetMap.get(id);
            if (assignment && target) {
                target.assignments.push(assignment);
            }
        }
        else {
            const target = (0, exports.toTarget)(annotation.carrier, annotation.carrierName, compilerFacade);
            if (assignment) {
                target.range = assignment.range;
                target.assignments.push(assignment);
            }
            else {
                target.range = (0, cds_annotation_parser_1.copyRange)(annotation.range);
            }
            targetMap.set(id, target);
        }
    }
}
/**
 * Collects metadata for relative paths used in annotation values based on the provided parameters.
 *
 * @param targetPath - The target path for which relative paths are collected.
 * @param targetCollectorKey - The key used for metadata collection related to the target.
 * @param mdPathSet - The set of metadata paths extracted from annotation values.
 * @param metadataCollector - The MetadataCollector for collecting metadata.
 */
function collectRelativePaths(targetPath, targetCollectorKey, mdPathSet, metadataCollector) {
    if (targetCollectorKey && mdPathSet.size > 0 && metadataCollector?.facade) {
        const targetBase = targetPath.split('/')[0].split('(')[0];
        const segments = targetBase.split('.');
        let serviceName = segments.slice(0, segments.length - 1).join('.');
        if (metadataCollector?.facade.getServiceKind(serviceName) !== 'service') {
            serviceName = '';
        }
        // collect metadata for relative paths used in annotation values
        // find base path for relative paths
        let baseKey = targetCollectorKey;
        let baseEntry = metadataCollector.metadataElementMap.get(baseKey);
        const pathBaseKinds = ['entity', 'view', 'action', 'function', 'aspect'];
        let nodeKind = getNodeKind(baseEntry, metadataCollector);
        // go up until parent has allowed pathBaseKind (e.g. needed for annotations targeting nested complex types)
        while (baseEntry?.parentKey && !!nodeKind && !pathBaseKinds?.includes(nodeKind)) {
            baseKey = baseEntry.parentKey;
            baseEntry = metadataCollector.metadataElementMap.get(baseKey);
            nodeKind = getNodeKind(baseEntry, metadataCollector);
        }
        // go further up until parent has no allowed pathBaseKind anymore (example ?)
        while (baseEntry?.parentKey && !!nodeKind && pathBaseKinds?.includes(nodeKind)) {
            baseKey = baseEntry.parentKey;
            baseEntry = metadataCollector.metadataElementMap.get(baseKey);
            nodeKind = getNodeKind(baseEntry, metadataCollector);
        }
        for (const relativePath of [...mdPathSet]) {
            metadataCollector?.facade?.collectMetadataForRelativePath(relativePath, baseKey, serviceName, metadataCollector);
        }
    }
}
/**
 * Get the kind of the parent node associated with a given base entry.
 *
 * @param baseEntry - The base entry for which to retrieve the parent node's kind.
 * @param metadataCollector - The metadata collector containing the metadata element map.
 * @returns The kind of the parent node, or undefined if not found.
 */
function getNodeKind(baseEntry, metadataCollector) {
    return baseEntry?.parentKey
        ? metadataCollector?.metadataElementMap?.get(baseEntry.parentKey)?.node?.kind
        : undefined;
}
//# sourceMappingURL=annotation-file.js.map