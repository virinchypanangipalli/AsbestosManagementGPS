"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pathHandler = void 0;
const cds_annotation_parser_1 = require("@sap-ux/cds-annotation-parser");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const i18n_1 = require("../../../i18n");
const path_utils_1 = require("../path-utils");
exports.pathHandler = {
    type: cds_annotation_parser_1.PATH_TYPE,
    convert(state, node) {
        const elementName = (state.context.valueType ? (0, path_utils_1.pathLikeTypeElementName)(state.context.valueType) : undefined) ?? "Path" /* Edm.Path */;
        const pathText = node.value
            .split('@')
            .map((segment, i) => (i === 0 ? segment.replace(/\./g, '/') : segment))
            .join('@');
        const fragmentRanges = calculateFragmentRanges(state, node);
        state.addPath(pathText);
        const element = (0, odata_annotation_core_types_1.createElementNode)({
            name: elementName,
            range: (0, cds_annotation_parser_1.nodeRange)(node, true),
            contentRange: (0, cds_annotation_parser_1.nodeRange)(node, false),
            content: [(0, odata_annotation_core_types_1.createTextNode)(pathText, (0, cds_annotation_parser_1.nodeRange)(node, false), fragmentRanges)]
        });
        return element;
    }
};
/**
 * Fragment ranges are calculated as following.
 * before first @ all '.' chars have been replaced by '/', hence every segment considered as fragment.
 * after first @ fragments are parts separated by '/', i.e. dots are not separators of fragments in that region.
 *
 * @param state - The visitor state.
 * @param node - The path node containing segments and separators.
 * @returns An array of fragment ranges derived from the positions of segments and separators.
 */
function calculateFragmentRanges(state, node) {
    const tokens = [...node.segments, ...node.separators].sort((a, b) => {
        const startA = a.range?.start?.character;
        const startB = b.range?.start?.character;
        if (startA && startB && startA !== startB) {
            return startA - startB;
        }
        const endA = a.range?.end?.character;
        const endB = b.range?.end?.character;
        if (endA && endB) {
            return endA - endB;
        }
        return 0;
    });
    const fragments = convertToFragments(state, node, tokens);
    return fragments.map((fragment) => fragment.range);
}
/**
 * Converts the segments of a Path node into Fragments, handling both data model segments and annotation references.
 *
 * @param state - The VisitorState object managing the state during the visit.
 * @param node - The Path node representing the path.
 * @param tokens - The array of Identifier or Separator tokens representing the path segments.
 * @returns An array of Fragments representing the converted segments of the path.
 */
function convertToFragments(state, node, tokens) {
    // If any of the token range is not defined,
    // then we can't generate fragment ranges correctly => no ranges are returned
    const fragments = [];
    let i = 0;
    // Process data model segments (until first annotation reference starting with @)
    for (; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.type === cds_annotation_parser_1.IDENTIFIER_TYPE) {
            if (token.value.includes('@')) {
                // segment referencing annotation is found
                break;
            }
            if (!token.range) {
                return [];
            }
            const fragment = {
                image: token.value,
                range: (0, cds_annotation_parser_1.copyRange)(token.range)
            };
            fragments.push(fragment);
        }
        else if (token.value === '/' && !token.escaped) {
            pushWrongPathSeparatorDiagnostic(state, token);
        }
    }
    const annotationFragments = processAnnotationSegments(state, node, tokens, i);
    // TODO: check if we should actually include fragments with 0 length
    // filtering fragments with no content to preserve existing behavior
    return [...fragments, ...annotationFragments].filter((fragment) => fragment.image.length);
}
/**
 * Processes the segments of an annotation path, extracting fragments and checking for missing path escaping.
 *
 * @param state - The VisitorState object managing the state during the visit.
 * @param node - The Path node representing the path.
 * @param tokens - The array of Identifier or Separator tokens representing the path segments.
 * @param startIndex - The index indicating the start of the range in the tokens array.
 * @returns An array of Fragments representing the processed segments of the annotation path.
 */
function processAnnotationSegments(state, node, tokens, startIndex) {
    const fragments = [];
    let requiresEscaping = false;
    let i = startIndex;
    while (i < tokens.length) {
        let token = tokens[i];
        if (!token.range) {
            return [];
        }
        const fragment = {
            image: '',
            range: odata_annotation_core_types_1.Range.create((0, cds_annotation_parser_1.copyPosition)(token.range.start), (0, cds_annotation_parser_1.copyPosition)(token.range.start))
        };
        while (token?.type === cds_annotation_parser_1.IDENTIFIER_TYPE || token?.value === '.') {
            fragment.image += token.value;
            if (fragment.range && token.range) {
                fragment.range.end = (0, cds_annotation_parser_1.copyPosition)(token.range.end);
            }
            i++;
            token = tokens[i];
            if (token?.type === cds_annotation_parser_1.SEPARATOR_TYPE && token.value === '/' && !token.escaped) {
                requiresEscaping = true;
            }
        }
        fragments.push(fragment);
        i++;
    }
    if (requiresEscaping) {
        pushMissingPathEscapingDiagnostic(state, node, tokens, startIndex);
    }
    return fragments;
}
/**
 * Pushes a diagnostic for missing path escaping brackets in the specified range of tokens.
 *
 * @param state - The VisitorState object managing the state during the visit.
 * @param node - The Path node representing the path.
 * @param tokens - The array of Identifier or Separator tokens representing the path segments.
 * @param startIndex - The index indicating the start of the range in the tokens array.
 */
function pushMissingPathEscapingDiagnostic(state, node, tokens, startIndex) {
    const start = tokens[startIndex];
    const end = tokens.slice(-1)[0];
    if (!start?.range || !end?.range) {
        return;
    }
    const pathSeparatorDiagnostic = {
        rule: odata_annotation_core_types_1.ODATA_PATH_SEPARATOR_RULE,
        message: i18n_1.i18n.t('Path_escaping_brackets_should_be_used'),
        range: odata_annotation_core_types_1.Range.create((0, cds_annotation_parser_1.copyPosition)(start.range.start), (0, cds_annotation_parser_1.copyPosition)(end.range.end)),
        severity: odata_annotation_core_types_1.DiagnosticSeverity.Warning
    };
    const valueToBeEscaped = '@' + node.value.split('@').slice(1).join('@');
    const prefix = start.type === cds_annotation_parser_1.IDENTIFIER_TYPE && start.quoted ? '' : '![';
    const suffix = ']';
    // If there are existing escape sequences, we need to remove them
    const body = valueToBeEscaped.replace(/[![\]]/g, '');
    pathSeparatorDiagnostic.data = {
        value: valueToBeEscaped,
        proposedValue: prefix + body + suffix
    };
    state.addDiagnostic(pathSeparatorDiagnostic);
}
/**
 * Pushes a diagnostic for a wrong path separator in the given token range.
 *
 * @param state - The VisitorState object managing the state during the visit.
 * @param token - The Separator token representing the path separator.
 */
function pushWrongPathSeparatorDiagnostic(state, token) {
    if (!token.range) {
        return;
    }
    // code action to correct wrong separator
    const message = i18n_1.i18n.t('Wrong_path_separator_0_Did_you_mean_1', {
        currentValue: '/',
        proposedValue: '.',
        interpolation: { escapeValue: false }
    });
    const diagnostic = odata_annotation_core_types_1.Diagnostic.create(token.range, message, odata_annotation_core_types_1.DiagnosticSeverity.Warning);
    diagnostic.data = {
        caseCheck: {
            value: '/',
            proposedValue: '.',
            lookupPath: [],
            isNamespacedValue: false
        }
    };
    state.addDiagnostic(diagnostic);
}
//# sourceMappingURL=path.js.map