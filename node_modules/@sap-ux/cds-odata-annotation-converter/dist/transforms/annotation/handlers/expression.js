"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unknownOperatorExpressionHandler = exports.incorrectExpressionHandler = exports.correctExpressionHandler = void 0;
const cds_annotation_parser_1 = require("@sap-ux/cds-annotation-parser");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
exports.correctExpressionHandler = {
    type: cds_annotation_parser_1.CORRECT_EXPRESSION_TYPE,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getChildren(state, expression) {
        if ((0, cds_annotation_parser_1.containsIncorrectExpressions)(expression)) {
            return [];
        }
        return expression.operands;
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    convert(state, expression) {
        if ((0, cds_annotation_parser_1.containsIncorrectExpressions)(expression)) {
            return;
        }
        const noContentRange = { line: 0, character: 0 };
        const startRange = (0, cds_annotation_parser_1.nodeRange)(expression.operands[0], true);
        const contentRangeStart = startRange?.start;
        const contentRangeEnd = (0, cds_annotation_parser_1.nodeRange)(expression.operands[expression.operands.length - 1], true)?.end;
        const contentRange = { start: contentRangeStart ?? noContentRange, end: contentRangeEnd ?? noContentRange };
        return buildElementForOperator(expression, contentRange);
    }
};
// incorrect expressions appear as empty values in generic annotation file
exports.incorrectExpressionHandler = {
    type: cds_annotation_parser_1.INCORRECT_EXPRESSION_TYPE,
    convert() {
        return;
    }
};
// expressions with unknown operators appear as nodes with name of unknown operator only (no other operators, no operands as sub nodes)
exports.unknownOperatorExpressionHandler = {
    type: cds_annotation_parser_1.UNSUPPORTED_OPERATOR_EXPRESSION_TYPE,
    getChildren() {
        return [];
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    convert(state, expression) {
        const element = (0, odata_annotation_core_types_1.createElementNode)({
            name: expression.unsupportedOperator.value,
            nameRange: expression.unsupportedOperator.range,
            range: expression.unsupportedOperator.range
        });
        return element;
    }
};
/**
 *
 * @param expression correct expression.
 * @param contentRange element content range.
 * @returns element or subtree containing all the info of range, name. content range..
 */
function buildElementForOperator(expression, contentRange) {
    const operatorDefinition = cds_annotation_parser_1.operatorMap[expression.operatorName];
    const edmName = operatorDefinition.edmName ?? '';
    const elementName = edmName.startsWith('odata.') ? "Apply" /* Edm.Apply */ : edmName;
    const element = (0, odata_annotation_core_types_1.createElementNode)({
        name: elementName,
        contentRange,
        range: (0, cds_annotation_parser_1.nodeRange)(expression, true)
    });
    const operatorRange = expression.operators[0].range;
    if (elementName === "Apply" /* Edm.Apply */) {
        element.attributes = {
            ["Function" /* Edm.Function */]: (0, odata_annotation_core_types_1.createAttributeNode)("Function" /* Edm.Function */, edmName, undefined, operatorRange)
        };
    }
    else {
        element.nameRange = operatorRange;
    }
    if (operatorDefinition.edmName && operatorDefinition.edmNot) {
        // wrap valid edm node into 'Not' expression
        const notElement = (0, odata_annotation_core_types_1.createElementNode)({
            name: "Not" /* Edm.Not */,
            nameRange: operatorRange,
            contentRange,
            content: [element]
        });
        return { root: notElement, leaf: element };
    }
    else {
        element.contentRange = contentRange;
        return element;
    }
}
//# sourceMappingURL=expression.js.map