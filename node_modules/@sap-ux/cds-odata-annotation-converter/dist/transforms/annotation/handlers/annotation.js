"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.annotationHandler = void 0;
const cds_annotation_parser_1 = require("@sap-ux/cds-annotation-parser");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const flattened_1 = require("../flattened");
const type_resolver_1 = require("../type-resolver");
const creators_1 = require("../creators");
exports.annotationHandler = {
    type: cds_annotation_parser_1.ANNOTATION_TYPE,
    convert,
    getChildren(state, annotation) {
        if (annotation.value) {
            return [annotation.value];
        }
        else {
            return [];
        }
    }
};
/**
 * Converts an Annotation node into an Element node and handles flattened structures.
 *
 * @param state - The visitor state.
 * @param annotation - The Annotation node to convert.
 * @returns Returns an Element or Subtree representing the converted structure.
 */
function convert(state, annotation) {
    const element = (0, odata_annotation_core_types_1.createElementNode)({
        name: "Annotation" /* Edm.Annotation */,
        range: (0, cds_annotation_parser_1.nodeRange)(annotation, false)
    });
    const isEmbeddedAnnotation = state.elementStack.length > 0;
    const termSegments = getTermSegments(annotation, isEmbeddedAnnotation);
    const termName = state.context.groupName && !isEmbeddedAnnotation
        ? [state.context.groupName, ...termSegments.slice(0, 1)].join('.')
        : termSegments.slice(0, 2).join('.');
    element.attributes["Term" /* Edm.Term */] = (0, creators_1.createTermAttribute)(termName, getTermNameRange(state, annotation, isEmbeddedAnnotation));
    const [namespaceOrAlias, termSimpleIdentifier] = termName.split('.');
    const term = (0, type_resolver_1.getTerm)(state.vocabularyService, namespaceOrAlias, termSimpleIdentifier);
    if (isEmbeddedAnnotation) {
        state.pushContext({
            valueType: term?.type,
            termType: term?.type,
            isCollection: term?.isCollection
        });
    }
    else if (term) {
        state.pushContext({
            ...state.context,
            valueType: term?.type,
            termType: term.type,
            isCollection: term.isCollection
        });
    }
    if (annotation.qualifier) {
        element.attributes["Qualifier" /* Edm.Qualifier */] = (0, creators_1.createQualifierAttribute)(annotation.qualifier.value, (0, cds_annotation_parser_1.nodeRange)(annotation.qualifier, false));
    }
    if (annotation.value) {
        element.contentRange = (0, cds_annotation_parser_1.nodeRange)(annotation.value, annotation.value.type !== cds_annotation_parser_1.EMPTY_VALUE_TYPE);
        // take into account colon
        if (annotation.colon && element.contentRange) {
            const colonPosition = annotation?.colon?.range?.end;
            // position right after colon should be counted as part of the elements content
            element.contentRange.start = colonPosition
                ? odata_annotation_core_types_1.Position.create(colonPosition.line, colonPosition.character)
                : odata_annotation_core_types_1.Position.create(0, 0);
        }
    }
    const flattenedSubtree = handleFlattenedStructure(state, annotation, element);
    if (flattenedSubtree) {
        return flattenedSubtree;
    }
    return element;
}
/**
 * Get the term segments from an annotation.
 *
 * @param annotation - The annotation object.
 * @param isEmbeddedAnnotation - A flag indicating whether the annotation is embedded.
 * @returns An array of string segments extracted from the annotation's term property.
 */
function getTermSegments(annotation, isEmbeddedAnnotation) {
    return annotation.term.segments.map((identifier, index) => index === 0 && isEmbeddedAnnotation ? identifier.value.slice(1) : identifier.value);
}
/**
 * Gets the range for the term name based on the given annotation node and context.
 *
 * @param state - The visitor state.
 * @param node - The annotation node containing the term.
 * @param isEmbeddedAnnotation - Indicates whether the annotation is embedded within another element.
 * @returns Returns the range for the term name, or undefined if not applicable.
 */
function getTermNameRange(state, node, isEmbeddedAnnotation) {
    const segments = state.context.groupName && !isEmbeddedAnnotation
        ? node.term.segments.slice(0, 1)
        : node.term.segments.slice(0, 2);
    if (segments.length === node.term.segments.length) {
        // use full node if it is a complete match and no flattened syntax is used
        return (0, cds_annotation_parser_1.nodeRange)(node.term, false);
    }
    const start = segments[0];
    const end = segments.slice(-1)[0];
    if (!start || !end) {
        return undefined;
    }
    const startPosition = (0, cds_annotation_parser_1.nodeRange)(start, false)?.start;
    const endPosition = (0, cds_annotation_parser_1.nodeRange)(end, false)?.end;
    if (!startPosition || !endPosition) {
        return undefined;
    }
    return odata_annotation_core_types_1.Range.create(startPosition, endPosition);
}
/**
 * Gets the flattened segments from the term of the given annotation, considering the context and nesting.
 *
 * @param state - The visitor state.
 * @param annotation - The annotation containing the term with segments.
 * @returns Returns the flattened segments of the term.
 */
function getFlattenedSegments(state, annotation) {
    const isEmbeddedAnnotation = state.elementStack.length > 0;
    const trailingTermSegmentStart = state.context.groupName && !isEmbeddedAnnotation ? 1 : 2;
    return annotation.term.segments.slice(trailingTermSegmentStart);
}
/**
 * Handles a flattened structure in the CDS syntax and builds nested structures.
 *
 * @param state - The visitor state.
 * @param annotation - The annotation containing the flattened structure.
 * @param element - The element to which the flattened structure will be added.
 * @returns Returns a Subtree representing the nested structures, or undefined if not applicable.
 */
function handleFlattenedStructure(state, annotation, element) {
    // Build nested structures for CDS flattened syntax
    // e.g UI.Chart.AxisScaling.ScaleBehavior : #AutoScale, @Common.Text.@UI.TextArrangement : #TextFirst
    const flattenedSegments = getFlattenedSegments(state, annotation);
    if (flattenedSegments.length) {
        const subtree = (0, flattened_1.convertFlattenedPath)(state, flattenedSegments, annotation.value);
        if (subtree) {
            const range = subtree.root.range ? (0, cds_annotation_parser_1.copyRange)(subtree.root.range) : undefined;
            if (subtree.root.name === "PropertyValue" /* Edm.PropertyValue */) {
                const record = (0, odata_annotation_core_types_1.createElementNode)({
                    name: "Record" /* Edm.Record */,
                    range,
                    contentRange: range
                });
                record.content.push(subtree.root);
                element.content.push(record);
            }
            else {
                element.content.push(subtree.root);
            }
            element.contentRange = range ? (0, cds_annotation_parser_1.copyRange)(range) : undefined;
            return {
                root: element,
                leaf: subtree.leaf
            };
        }
    }
    return undefined;
}
//# sourceMappingURL=annotation.js.map