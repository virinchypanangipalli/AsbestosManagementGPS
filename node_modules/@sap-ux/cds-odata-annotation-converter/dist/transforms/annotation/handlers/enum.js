"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertFlags = exports.enumHandler = exports.toEnumValue = exports.ENUM_MEMBER_DELIMITER = exports.ENUM_VALUE_DELIMITER = void 0;
const cds_annotation_parser_1 = require("@sap-ux/cds-annotation-parser");
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
/**
 * Delimiter between two enum values, used for flags
 */
exports.ENUM_VALUE_DELIMITER = ' ';
/**
 * Delimiter between enum type and member name
 */
exports.ENUM_MEMBER_DELIMITER = '/';
const toEnumValue = (type, memberName) => [type, memberName].join(exports.ENUM_MEMBER_DELIMITER);
exports.toEnumValue = toEnumValue;
exports.enumHandler = {
    type: cds_annotation_parser_1.ENUM_TYPE,
    convert(state, node) {
        if (!state.context.valueType) {
            return;
        }
        const enumValue = (0, exports.toEnumValue)(state.context.valueType, node.path.value);
        const textNode = (0, odata_annotation_core_types_1.createTextNode)(enumValue, (0, cds_annotation_parser_1.nodeRange)(node, false));
        const enumFragmentRange = (0, cds_annotation_parser_1.nodeRange)(node, true);
        if (enumFragmentRange) {
            textNode.fragmentRanges = [enumFragmentRange];
        }
        return (0, odata_annotation_core_types_1.createElementNode)({
            name: "EnumMember" /* Edm.EnumMember */,
            range: (0, cds_annotation_parser_1.nodeRange)(node, true),
            contentRange: (0, cds_annotation_parser_1.nodeRange)(node, false),
            content: [textNode]
        });
    }
};
/**
 * Converts collection items representing flags (enums) into an EnumMember element.
 *
 * @param state - The visitor state.
 * @param node - The collection node containing enum items.
 * @param valueType - The type of the enum values.
 * @returns An EnumMember element representing the converted flags.
 */
function convertFlags(state, node, valueType) {
    // Alternative is to provide conversion diagnostics
    const enums = node.items.filter((item) => item.type === cds_annotation_parser_1.ENUM_TYPE);
    const segments = [];
    const fragmentRanges = [];
    let invalidRanges = false;
    for (const enumNode of enums) {
        const enumValue = (0, exports.toEnumValue)(valueType, enumNode.path.value);
        segments.push(enumValue);
        if (enumNode.range) {
            fragmentRanges.push((0, cds_annotation_parser_1.copyRange)(enumNode.range));
        }
        else {
            invalidRanges = true;
        }
    }
    const value = segments.join(exports.ENUM_VALUE_DELIMITER);
    return (0, odata_annotation_core_types_1.createElementNode)({
        name: "EnumMember" /* Edm.EnumMember */,
        range: (0, cds_annotation_parser_1.nodeRange)(node, true),
        contentRange: (0, cds_annotation_parser_1.nodeRange)(node, false),
        content: [(0, odata_annotation_core_types_1.createTextNode)(value, (0, cds_annotation_parser_1.nodeRange)(node, false), invalidRanges ? undefined : fragmentRanges)]
    });
}
exports.convertFlags = convertFlags;
//# sourceMappingURL=enum.js.map