"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitor = exports.Visitor = void 0;
const handlers_1 = require("./handlers");
const handler_1 = require("./handler");
/**
 *
 */
class Visitor {
    /**
     *
     * @param state - The visitor state.
     * @param node - The annotation node to be visited.
     * @returns The converted element or undefined if no conversion is performed.
     */
    visit(state, node) {
        const handler = handlers_1.nodeHandlerConfig[node.type];
        if (!handler) {
            return undefined;
        }
        const contextDepth = state.contextDepth;
        const conversionResult = handler.convert(state, node);
        const children = handler.getChildren ? handler.getChildren(state, node) : [];
        if (!conversionResult && children.length === 0 && state.elementStack.length === 0) {
            return undefined;
        }
        const [root, leaf] = processConversionResult(state.elementStack[state.elementStack.length - 1], conversionResult);
        if (conversionResult) {
            state.elementStack.push(leaf);
        }
        for (const child of children) {
            const childElement = this.visit(state, child);
            if (childElement) {
                leaf.content.push(childElement);
            }
        }
        if (conversionResult) {
            state.elementStack.pop();
        }
        while (state.contextDepth > contextDepth) {
            state.popContext();
        }
        return root;
    }
}
exports.Visitor = Visitor;
/**
 * Process the conversion result and return a tuple of elements.
 *
 * @param leaf - The leaf element.
 * @param result - The conversion result.
 * @returns A tuple containing the root and leaf elements.
 *            - If the result is undefined, returns [undefined, leaf].
 *            - If the result is a subtree, returns [result.root, result.leaf].
 *            - Otherwise, returns [result, result].
 */
function processConversionResult(leaf, result) {
    if (result === undefined) {
        // Use element from previous call, when current node is not converted
        return [undefined, leaf];
    }
    if ((0, handler_1.isSubtree)(result)) {
        return [result.root, result.leaf];
    }
    return [result, result];
}
exports.visitor = new Visitor();
//# sourceMappingURL=visitor.js.map