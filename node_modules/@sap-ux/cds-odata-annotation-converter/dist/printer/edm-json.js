"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printEdmJson = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const indent_1 = require("./indent");
const primitives_1 = require("./primitives");
/**
 *
 * @param node - The node to be serialized.
 * @param options - The options for EDM JSON serialization.
 * @returns The serialized string based on the type of the node.
 */
function printEdmJson(node, options) {
    const value = internalPrint(node, options, true);
    const valueWithoutIndentation = options.includeEdmJson && !options.removeRootElementContainer ? wrapWithEdmJson(value, options) : value;
    if (options.skipIndent) {
        return valueWithoutIndentation;
    }
    return (0, indent_1.indent)(valueWithoutIndentation);
}
exports.printEdmJson = printEdmJson;
/**
 * Prefixes a property name based on EDM JSON options.
 *
 * @param text - The property name to be prefixed.
 * @param options - The options for EDM JSON serialization.
 * @returns The prefixed property name.
 */
function wrapWithEdmJson(text, options) {
    const edmJson = (0, primitives_1.valuePair)(prefixPropertyName('edmJson', options), text);
    return (0, primitives_1.struct)([edmJson]);
}
/**
 * Prefixes a property name with a dollar sign and an optional backslash.
 *
 * @param text - The original property name.
 * @param options - Options for customizing the prefixing.
 * @returns - The prefixed property name.
 */
function prefixPropertyName(text, options) {
    return `${options.useSnippetSyntax ? '\\' : ''}$${text}`;
}
/**
 * Converts an element or text node to a serialized string based on its type.
 *
 * @param node - The node to be serialized.
 * @param options - The options for EDM JSON serialization.
 * @param [isRoot] - Indicates whether the node is the root element.
 * @returns The serialized string based on the type of the node.
 */
function internalPrint(node, options, isRoot = false) {
    switch (node.type) {
        case odata_annotation_core_1.ELEMENT_TYPE: {
            return printElement(node, options, isRoot);
        }
        case odata_annotation_core_1.TEXT_TYPE: {
            return node.text;
        }
        default:
            return '';
    }
}
/**
 * Converts the content of an element to a serialized string based on its type.
 *
 * @param node - The element to be serialized.
 * @param options - The options for EDM JSON serialization.
 * @param isRoot - Indicates whether the element is the root element.
 * @returns The serialized string based on the type of the element.
 */
function printElement(node, options, isRoot) {
    if (node.name === "String" /* Edm.String */) {
        return printString(node);
    }
    let stringValLiteral = '';
    if (node?.content?.[0]?.type === odata_annotation_core_1.TEXT_TYPE) {
        stringValLiteral = node.content[0].text.trim();
    }
    const content = printContent(node.content, options);
    const contentText = primitives_1.PRIMITIVE_VALUE_ATTRIBUTE_NAMES.has(node.name)
        ? (0, primitives_1.stringLiteral)(stringValLiteral)
        : (0, primitives_1.collection)(content);
    const name = (0, primitives_1.valuePair)(prefixPropertyName(node.name, options), contentText);
    const attributes = printAttributes(node.attributes, options);
    const properties = [name, ...attributes];
    if (isRoot && options.removeRootElementContainer) {
        return (0, primitives_1.list)(properties, false).join('\n');
    }
    return (0, primitives_1.struct)(properties);
}
/**
 * Converts the content of a string element to a serialized string literal.
 *
 * @param node - The string element.
 * @returns The serialized string literal.
 */
function printString(node) {
    if (node.content && node.content[0]?.type === odata_annotation_core_1.TEXT_TYPE) {
        return (0, primitives_1.stringLiteral)(node.content[0].text);
    }
    return (0, primitives_1.stringLiteral)('');
}
/**
 * @param attributes - The content of the attribute.
 * @param options - The options for EDM JSON serialization.
 * @returns The serialized array of ContainerItemType.
 */
function printAttributes(attributes, options) {
    return Object.keys(attributes ?? {}).map((attributeName) => {
        if (attributeName.startsWith('$')) {
            // placeholders need different handling
            return { value: (0, primitives_1.keyAlone)(attributeName), placeholder: true };
        }
        const attributeNameValue = attributes ? attributes[attributeName].value : '';
        return (0, primitives_1.valuePair)(prefixPropertyName(attributeName, options), (0, primitives_1.stringLiteral)(attributeNameValue));
    });
}
/**
 * Converts the content of an element to a serialized array of ContainerItemType.
 *
 * @param content - The content of the element.
 * @param options - The options for EDM JSON serialization.
 * @returns The serialized array of ContainerItemType.
 */
function printContent(content, options) {
    return (content ?? [])
        .filter((item) => item.type !== 'text' || item.text.trim() !== '')
        .map((item) => {
        if (item.type === odata_annotation_core_1.TEXT_TYPE && item.text.startsWith('$')) {
            return {
                value: item.text,
                placeholder: true
            };
        }
        return internalPrint(item, options);
    });
}
//# sourceMappingURL=edm-json.js.map