"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAnnotationPathQualifiers = exports.getAnnotationTermAlias = exports.getEntitySets = exports.getMergedMetadata = exports.getAnnotationService = exports.getMappedServiceName = void 0;
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const fiori_annotation_api_1 = require("@sap-ux/fiori-annotation-api");
const project_access_1 = require("@sap-ux/project-access");
/**
 * Method returns service name for passed CAP project service.
 *
 * @param project - project
 * @param serviceName - service name to lookup
 * @param appName  - app name in CAP project
 * @returns resolved service name
 */
async function getMappedServiceName(project, serviceName, appName) {
    let mappedServiceName = serviceName;
    if (['CAPJava', 'CAPNodejs'].includes(project.projectType)) {
        // Fetch the CDS service name by mapping it to the URI if the app's service is not the same
        const appServiceName = getMainService(project, appName);
        if (appServiceName) {
            mappedServiceName = await (0, project_access_1.getCapServiceName)(project.root, project.apps[appName]?.services?.[appServiceName].uri ?? '');
        }
    }
    return mappedServiceName;
}
exports.getMappedServiceName = getMappedServiceName;
/**
 * Method returns service object for passed service name.
 *
 * @param project - project
 * @param serviceName - service name to lookup
 * @param appName - app name in CAP project
 * @param sync - option to refresh file content from the file system
 * @returns resolved Annotation service
 */
async function getAnnotationService(project, serviceName, appName, sync = true) {
    const mappedServiceName = await getMappedServiceName(project, serviceName, appName);
    const service = await fiori_annotation_api_1.FioriAnnotationService.createService(project, mappedServiceName, appName);
    if (sync) {
        await service.sync();
    }
    return service;
}
exports.getAnnotationService = getAnnotationService;
/**
 * Method to get and convert metadata.
 *
 * @param annotationService - Fiori Annotation service
 * @returns coverted metadata object
 */
function getMergedMetadata(annotationService) {
    const rawMetadata = annotationService.getSchema();
    return (0, annotation_converter_1.convert)(rawMetadata);
}
exports.getMergedMetadata = getMergedMetadata;
/**
 * Method returns converted metadata object.
 *
 * @param project - project
 * @param serviceName - project service name
 * @param appName - application id
 * @returns resolved converted metadata object
 */
const getServiceMetadata = async (project, serviceName, appName) => {
    const annotationService = await getAnnotationService(project, serviceName, appName);
    return getMergedMetadata(annotationService);
};
/**
 * Method returns main service of the application.
 *
 * @param project = project
 * @param appId - application id
 * @returns main service name
 */
function getMainService(project, appId) {
    let mainService;
    if (appId === undefined) {
        const appIds = Object.keys(project.apps);
        mainService = project.apps[appIds[0]].mainService;
    }
    else {
        const app = project.apps[appId];
        if (!app) {
            throw new Error('ERROR_INVALID_APP_ID');
        }
        mainService = app.mainService;
    }
    return mainService ?? 'mainService';
}
/**
 * Method gets available entity sets in project.
 *
 * @param project = project
 * @param appId = app id
 * @returns an array of entity sets
 */
async function getEntitySets(project, appId) {
    const metadata = await getServiceMetadata(project, getMainService(project, appId), appId);
    return Array.from(metadata.entitySets);
}
exports.getEntitySets = getEntitySets;
/**
 * Method to get the annotation term alias.
 *
 * @param annotationTerm - annotation term
 * @returns an array of entity type annotations with annotation term name
 */
function getAnnotationTermAlias(annotationTerm) {
    const [, , , vocabularyName, , annotationTermName] = annotationTerm.split('.');
    return [vocabularyName, annotationTermName];
}
exports.getAnnotationTermAlias = getAnnotationTermAlias;
/**
 * Method to get the annotation path qualifiers for entity.
 *
 * @param project - project
 * @param appId app id in CAP project
 * @param entity - entity or entity type name
 * @param annotationTerm - annotation term names to search
 * @param bindingContext - binding context to filter the annotations
 * @param useNamespace - indicates to use namespace or namespace alias
 * @returns a record of annotation path qualifier terms
 */
async function getAnnotationPathQualifiers(project, appId, entity, annotationTerm, bindingContext, useNamespace = false) {
    const result = {};
    try {
        const annotationService = await getAnnotationService(project, getMainService(project, appId), appId);
        const mergedMetadata = getMergedMetadata(annotationService);
        const entitySet = mergedMetadata.entitySets.by_name(entity);
        const entityType = entitySet?.entityType;
        if (entityType) {
            getAnnotationPathQualifiersForEntityType(entityType, annotationTerm, result, useNamespace, bindingContext);
        }
    }
    catch (error) {
        throw new Error(`An error occurred while reading the annotation path qualifiers. Details: ${error}`);
    }
    return result;
}
exports.getAnnotationPathQualifiers = getAnnotationPathQualifiers;
/**
 * Method to get annotation path qualifiers and add to result.
 *
 * @param entityType - entity type name
 * @param annotationTerms - annotation term names to search
 * @param result - a record of annotation path qualifier terms
 * @param useNamespace - indicates to use namespace or namespace alias
 * @param bindingContext - binding context to filter the annotations
 */
function getAnnotationPathQualifiersForEntityType(entityType, annotationTerms, result, useNamespace, bindingContext) {
    if (bindingContext.type === 'absolute') {
        addAnnotationPathQualifierToResult(entityType, '', annotationTerms, result, useNamespace);
    }
    else if (bindingContext.type === 'relative') {
        entityType.navigationProperties.forEach((navigationProperty) => {
            if (navigationProperty.targetType &&
                navigationProperty.targetType._type === 'EntityType' &&
                navigationProperty.name !== 'SiblingEntity') {
                if (!bindingContext.isCollection || (bindingContext.isCollection && navigationProperty.isCollection)) {
                    addAnnotationPathQualifierToResult(navigationProperty.targetType, navigationProperty.name, annotationTerms, result, useNamespace);
                }
            }
        });
    }
}
/**
 *  Method to add found annotation paths to result.
 *
 * @param entityType - entity type name
 * @param navigationPropertyName - navigation property name to include in the annotation path
 * @param annotationTerms - annotation term names to search
 * @param result - a record of annotation path qualifier terms
 * @param useNamespace - indicates to use namespace or namespace alias
 */
function addAnnotationPathQualifierToResult(entityType, navigationPropertyName, annotationTerms, result, useNamespace = false) {
    annotationTerms.forEach((uiAnnotationTerm) => {
        const [namespaceAlias, annotationTerm] = getAnnotationTermAlias(uiAnnotationTerm);
        const namespace = uiAnnotationTerm.substring(0, uiAnnotationTerm.lastIndexOf('.'));
        const annotations = entityType.annotations[namespaceAlias];
        if (!annotations) {
            return;
        }
        Object.entries(annotations).forEach(([key, value]) => {
            if (key.startsWith(annotationTerm)) {
                const qualifier = value.qualifier ? '#' + value.qualifier : '';
                const navPropertyPath = `${navigationPropertyName ? navigationPropertyName + '/' : ''}`;
                result[`${navPropertyPath}@${namespaceAlias}.${annotationTerm}` + qualifier] =
                    `${navPropertyPath}@${useNamespace ? namespace : namespaceAlias}.${annotationTerm}` + qualifier;
            }
        });
    });
}
//# sourceMappingURL=service.js.map