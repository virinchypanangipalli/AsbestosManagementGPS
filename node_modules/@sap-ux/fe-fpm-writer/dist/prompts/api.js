"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromptsAPI = void 0;
const mem_fs_editor_1 = require("mem-fs-editor");
const mem_fs_1 = require("mem-fs");
const project_access_1 = require("@sap-ux/project-access");
const utils_1 = require("./utils");
const i18n_1 = require("../i18n");
const path_1 = require("path");
const map_1 = require("./map");
const unsupportedPrompts = () => ({
    questions: []
});
/**
 * API class to request and handle prompts for fpm-writer features.
 */
class PromptsAPI {
    // Prompts context containing information about project and other reusable properties
    context;
    // Cached questions
    cache = {};
    /**
     * Contructore of prompt API.
     *
     * @param fs the file system object for reading files
     * @param project
     * @param appId app id in CAP project
     */
    constructor(fs, project, appId = '') {
        this.context = {
            fs,
            project: project,
            appId: appId,
            appPath: project ? (0, path_1.join)(project.root, appId) : ''
        };
    }
    /**
     * Static method to initialize prompt api.
     *
     * @param projectPath project path
     * @param appId app id in CAP project
     * @param fs the file system object for reading files
     * @returns Instance of prompt api.
     */
    static async init(projectPath, appId, fs) {
        if (!fs) {
            fs = (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
        }
        await (0, i18n_1.initI18n)();
        const project = projectPath ? await (0, project_access_1.getProject)(projectPath) : undefined;
        return new PromptsAPI(fs, project, appId);
    }
    /**
     * Returns a list of prompts for passed type.
     *
     * @param type Prompt type
     * @returns List of prompts for passed type.
     */
    async getPrompts(type) {
        const method = type in map_1.PromptsQuestionsMap ? map_1.PromptsQuestionsMap[type] : unsupportedPrompts;
        const prompt = await method(this.context);
        // Update cache
        this.cache = {
            ...this.cache,
            [type]: prompt
        };
        return prompt;
    }
    /**
     * Gets prompt choices.
     *
     * @param type - The prompt type
     * @param fieldName - The field name
     * @param answers - The answers object
     * @returns
     */
    async getChoices(type, fieldName, answers) {
        try {
            const prompt = this.cache[type] ?? (await this.getPrompts(type));
            const question = prompt.questions.find((question) => question.name === fieldName);
            if (question && question.type === 'list') {
                const choices = typeof question.choices === 'function' ? await question.choices(answers) : question.choices;
                return choices ?? [];
            }
        }
        catch (error) {
            // In case of issues, fall back to the defaults
        }
        return [];
    }
    /**
     * Validates answers: checks if required prompts have values and runs validate() if exists on prompt.
     *
     * @param type The prompt type
     * @param answers The answers object
     * @param questions Questions to validate - If param is not passed, then all question will be validated
     * @returns Object with question names and answer validation results
     */
    async validateAnswers(type, answers, questions) {
        const originalPrompts = this.cache[type] ?? (await this.getPrompts(type));
        const result = {};
        if (!questions) {
            questions = originalPrompts.questions;
        }
        for (const q of questions) {
            const question = originalPrompts.questions.find((blockQuestion) => q.name === blockQuestion.name);
            if (!question) {
                continue;
            }
            const t = (0, i18n_1.translate)(i18n_1.i18nNamespaces.buildingBlock, 'prompts.common.');
            const { name, guiOptions = {}, type, validate } = question;
            const { mandatory } = guiOptions;
            result[name] = { isValid: true };
            const answer = (0, utils_1.getAnswer)(answers, name);
            if (mandatory && !answer) {
                result[name] = {
                    isValid: false,
                    errorMessage: type === 'input' ? t('validation.errorMessage.input') : t('validation.errorMessage.select')
                };
            }
            else if (typeof validate === 'function') {
                const validationResult = await validate(answer, answers);
                if (typeof validationResult === 'string') {
                    result[name] = { isValid: false, errorMessage: validationResult };
                }
            }
        }
        return result;
    }
    /**
     * Method submits answers by generating content in project for passed prompt type.
     *
     * @param type The prompt type
     * @param answers The answers object
     * @returns The updated memfs editor instance
     */
    submitAnswers(type, answers) {
        const config = { type, answers };
        if (!this.isGenerationSupported(config)) {
            return this.context.fs;
        }
        const generator = map_1.PromptsGeneratorsMap.hasOwnProperty(config.type)
            ? map_1.PromptsGeneratorsMap[config.type]
            : undefined;
        return generator?.(this.context.appPath, config.answers, this.context.fs) ?? this.context.fs;
    }
    /**
     * Method returns code snippet for passed answers and prompt type.
     *
     * @param type The prompt type
     * @param answers The answers object
     * @returns Code snippet content.
     */
    getCodeSnippets(type, answers) {
        const config = { type, answers };
        if (!this.isGenerationSupported(config)) {
            return {};
        }
        const codePreviewGenerator = map_1.PromptsCodePreviewMap.hasOwnProperty(config.type)
            ? map_1.PromptsCodePreviewMap[config.type]
            : undefined;
        return codePreviewGenerator?.(this.context.appPath, config.answers) ?? {};
    }
    /**
     * Method checks if passed type of prompt supports generation and code preview.
     *
     * @param config Prompt configuration
     * @param config.type
     * @param config.answers
     * @returns true if code generation is supported.
     */
    isGenerationSupported(config) {
        return config.type in map_1.PromptsCodePreviewMap;
    }
}
exports.PromptsAPI = PromptsAPI;
//# sourceMappingURL=api.js.map