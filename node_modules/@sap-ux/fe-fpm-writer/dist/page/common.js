"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendPageJSON = exports.validatePageConfig = exports.initializeTargetSettings = exports.getLibraryDependencies = exports.getFclConfig = exports.getManifestJsonExtensionHelper = exports.generateRouteTarget = exports.generateRoutePattern = exports.PATTERN_SUFFIX = void 0;
const mem_fs_1 = require("mem-fs");
const mem_fs_editor_1 = require("mem-fs-editor");
const path_1 = require("path");
const ejs_1 = require("ejs");
const validate_1 = require("../common/validate");
const types_1 = require("./types");
const defaults_1 = require("../common/defaults");
const file_1 = require("../common/file");
const templates_1 = require("../templates");
const semver_1 = require("semver");
/**
 * Suffix for patterns to support arbitrary paramters
 */
exports.PATTERN_SUFFIX = ':?query:';
/**
 * Generates the pattern for a new route based on the input.
 *
 * @param routes existing routes
 * @param targetEntity entity of the target
 * @param nav navigation object
 * @returns the generated pattern as string
 */
function generateRoutePattern(routes, targetEntity, nav) {
    const parts = [];
    if (nav?.sourcePage && nav.navEntity) {
        const sourceRoute = routes.find((route) => route.name === nav.sourcePage);
        if (sourceRoute?.pattern) {
            const basePattern = sourceRoute.pattern.replace(exports.PATTERN_SUFFIX, '');
            if (basePattern) {
                parts.push(basePattern);
                parts.push('/');
                parts.push(nav.navEntity);
            }
            else {
                parts.push(targetEntity);
            }
        }
        else {
            throw new Error('Navigation source invalid');
        }
    }
    else if (routes.length > 0) {
        parts.push(targetEntity);
    }
    if (nav?.navKey) {
        parts.push(`({${nav?.navEntity ?? targetEntity}Key})`);
    }
    parts.push(exports.PATTERN_SUFFIX);
    return parts.join('');
}
exports.generateRoutePattern = generateRoutePattern;
/**
 * Generates the target property for a route based on exiting routes, configurations and the target's name.
 *
 * @param routes existing routes
 * @param name name of the target page
 * @param fcl optional flag if FCL is enabled
 * @param nav navigation object
 * @returns the target property of a route
 */
function generateRouteTarget(routes, name, fcl, nav) {
    if (nav?.sourcePage) {
        const sourceRoute = routes.find((route) => route.name === nav.sourcePage);
        // FCL only supports 3 columns, therefore, show the page in fullscreen if it is the 4th level of navigation
        if (fcl && sourceRoute?.target?.constructor === Array && sourceRoute.target.length < 3) {
            return [...sourceRoute.target, name];
        }
    }
    return fcl ? [name] : name;
}
exports.generateRouteTarget = generateRouteTarget;
/**
 * Create a function that can be used as JsonReplace when calling extendJson.
 *
 * @param config page configuration
 * @returns a JsonReplacer function for the usage in ejs
 */
function getManifestJsonExtensionHelper(config) {
    return (key, value) => {
        switch (key) {
            case 'routing':
                value.routes = value.routes ?? [];
                break;
            case 'routes':
                const routes = value;
                routes.push({
                    name: config.id ?? `${config.entity}${config.name}`,
                    pattern: generateRoutePattern(routes, config.entity, config.navigation),
                    target: generateRouteTarget(routes, config.id ?? `${config.entity}${config.name}`, config.fcl, config.navigation)
                });
                break;
            default:
                break;
        }
        return value;
    };
}
exports.getManifestJsonExtensionHelper = getManifestJsonExtensionHelper;
/**
 * Get the configuration parameters for the flexible column layout based on the given manifest and navigation config.
 *
 * @param manifest existing manifest
 * @param navigation navigation configuration that is to be added
 * @returns fcl configuration
 */
function getFclConfig(manifest, navigation) {
    const config = {};
    if (manifest['sap.ui5']?.routing?.config?.routerClass === defaults_1.FCL_ROUTER) {
        config.fcl = true;
        if (navigation) {
            const sourceRoute = (manifest['sap.ui5']?.routing?.routes || []).find((route) => route.name === navigation?.sourcePage);
            config.controlAggregation =
                (sourceRoute?.target ?? []).length > 1 ? 'endColumnPages' : 'midColumnPages';
        }
        else {
            config.controlAggregation = 'beginColumnPages';
        }
    }
    return config;
}
exports.getFclConfig = getFclConfig;
/**
 * Get the library dependencies for a given page type.
 *
 * @param pageType - Page type for which the dependencies are to be added
 * @returns Library dependencies
 */
function getLibraryDependencies(pageType) {
    const libraries = {};
    switch (pageType) {
        case types_1.PageType.CustomPage: {
            libraries['sap.fe.core'] = {};
            break;
        }
        case types_1.PageType.ListReport:
        case types_1.PageType.ObjectPage: {
            libraries['sap.fe.templates'] = {};
            break;
        }
    }
    return libraries;
}
exports.getLibraryDependencies = getLibraryDependencies;
/**
 * Create target settings for a Fiori elements page.
 *
 * @param data - incoming configuration
 * @param addSettings - optional arbitrary settings
 * @returns version aware settings object
 */
function initializeTargetSettings(data, addSettings) {
    const settings = addSettings ? { ...addSettings } : {};
    settings.navigation ??= {};
    // starting with UI5 v1.94.0, contextPath is the preferred setting
    const minVersion = (0, semver_1.coerce)(data.minUI5Version);
    if (!minVersion || (0, semver_1.gte)(minVersion, '1.94.0')) {
        settings.contextPath = data.contextPath ?? `/${data.entity}`;
    }
    else {
        settings.entitySet = data.entity;
    }
    return settings;
}
exports.initializeTargetSettings = initializeTargetSettings;
/**
 * Validate the input parameters for the generation of a custom or an object page.
 *
 * @param basePath - the base path
 * @param config - the custom page configuration
 * @param fs - the memfs editor instance
 * @param dependencies - expected dependencies
 * @returns the updated memfs editor instance
 */
function validatePageConfig(basePath, config, fs, dependencies = []) {
    // common validators
    (0, validate_1.validateBasePath)(basePath, fs, dependencies);
    // validate config against the manifest
    if (config.navigation?.sourcePage) {
        const manifest = fs.readJSON((0, path_1.join)(basePath, 'webapp/manifest.json'));
        if (!manifest['sap.ui5']?.routing?.targets?.[config.navigation.sourcePage]) {
            throw new Error(`Could not find navigation source ${config.navigation.sourcePage}!`);
        }
        const routes = {};
        if (manifest['sap.ui5']?.routing?.routes?.constructor === Array) {
            manifest['sap.ui5'].routing.routes.forEach((routeWithName) => {
                routes[routeWithName.name] = routeWithName;
            });
        }
        else {
            Object.assign(routes, manifest['sap.ui5']?.routing?.routes ?? {});
        }
        const route = routes[config.navigation.sourcePage];
        if (!route?.pattern || !route.target) {
            throw new Error(`Invalid routing configuration for navigation source ${config.navigation.sourcePage}!`);
        }
    }
    return fs;
}
exports.validatePageConfig = validatePageConfig;
/**
 * Add an generic page to an existing UI5 application.
 * Supported pages - ListReport or ObjectPage.
 *
 * @param basePath - the base path
 * @param data - the page configuration
 * @param enhanceDataFn - Callback function for data enhancement
 * @param templatePath - path to 'manifest.json' template
 * @param fs - the memfs editor instance
 * @returns the updated memfs editor instance
 */
function extendPageJSON(basePath, data, enhanceDataFn, templatePath, fs) {
    if (!fs) {
        fs = (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
    }
    validatePageConfig(basePath, data, fs);
    const manifestPath = (0, path_1.join)(basePath, 'webapp/manifest.json');
    const manifest = fs.readJSON(manifestPath);
    const config = enhanceDataFn(data, manifest);
    // enhance manifest.json
    (0, file_1.extendJSON)(fs, {
        filepath: manifestPath,
        content: (0, ejs_1.render)(fs.read((0, templates_1.getTemplatePath)(templatePath)), config, {}),
        replacer: getManifestJsonExtensionHelper(config),
        tabInfo: data.tabInfo
    });
    return fs;
}
exports.extendPageJSON = extendPageJSON;
//# sourceMappingURL=common.js.map