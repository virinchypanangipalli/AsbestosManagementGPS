"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAstNodes = exports.getNode = exports.findAnnotationNode = void 0;
const transformer_1 = require("./transformer");
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const LEAF_NODE_TYPES = new Set([
    transformer_1.IDENTIFIER_TYPE,
    transformer_1.ENUM_TYPE,
    transformer_1.BOOLEAN_TYPE,
    transformer_1.NUMBER_LITERAL_TYPE,
    transformer_1.STRING_LITERAL_TYPE,
    transformer_1.PATH_TYPE,
    transformer_1.EMPTY_VALUE_TYPE,
    transformer_1.OPERATOR_TYPE
]);
/**
 * Visitor which visits all the nodes for which the specified position is in range.
 *
 */
class PositionVisitor {
    constructor() {
        this.createNodeHandler(transformer_1.ANNOTATION_GROUP_TYPE, ['name', 'items'], []);
        this.createNodeHandler(transformer_1.ANNOTATION_GROUP_ITEMS_TYPE, [], ['items']);
        this.createNodeHandler(transformer_1.ANNOTATION_TYPE, ['term', 'value'], []);
        this.createNodeHandler(transformer_1.RECORD_TYPE, [], ['properties', 'annotations']);
        this.createNodeHandler(transformer_1.RECORD_PROPERTY_TYPE, ['name', 'value'], []);
        this.createNodeHandler(transformer_1.COLLECTION_TYPE, [], ['items']);
        this.createNodeHandler(transformer_1.CORRECT_EXPRESSION_TYPE, [], ['operators', 'operands']);
        this.createNodeHandler(transformer_1.INCORRECT_EXPRESSION_TYPE, [], ['operators', 'operands']);
        this.createNodeHandler(transformer_1.UNSUPPORTED_OPERATOR_EXPRESSION_TYPE, [], ['operators', 'operands']);
    }
    /**
     * Visits all nodes (including children) which have the provided position in their ranges.
     *
     * @param node Node to be visited
     * @param options Visitor options
     * @param segment Name of the segment which should be added to path if the position is in the nodes range
     * @returns Visitor result value
     */
    visit(node, options, segment) {
        const { position } = options;
        if ((0, odata_annotation_core_1.positionContained)((0, transformer_1.nodeRange)(node, options.includeDelimiterCharacters), position)) {
            if (LEAF_NODE_TYPES.has(node.type)) {
                return segment !== undefined ? [segment] : [];
            }
            if (this[node.type]) {
                return this[node.type](node, options, segment);
            }
            else {
                throw new Error(`No visitor function found for type ${node.type}`);
            }
        }
        return [];
    }
    /**
     *
     * @param nodeType Type of an annotation node
     * @param scalarProperties Array with names of scalar properties of an annotation node
     * @param collectionProperties Array with names of collection valued properties of an annotation node
     */
    createNodeHandler(nodeType, scalarProperties, collectionProperties) {
        this[nodeType] = (node, options, segment = '') => {
            for (const propertyName of scalarProperties) {
                const children = this.visit(node[propertyName], options, propertyName);
                if (children.length) {
                    return [segment, ...children];
                }
            }
            for (const propertyName of collectionProperties) {
                let i = 0;
                for (const item of node[propertyName] || []) {
                    const children = this.visit(item, options, i);
                    if (children.length) {
                        return [segment, propertyName, ...children];
                    }
                    i++;
                }
            }
            return [segment];
        };
    }
}
const visitor = new PositionVisitor();
/**
 * Searches for an AST node in the given AST tree based on provided search options.
 *
 * @param assignment AST root element
 * @param options Search options (element position, flag whether delimiter characters should be considered)
 * @returns Path to the found AST node or empty string
 */
const findAnnotationNode = (assignment, options) => assignment ? visitor.visit(assignment, options).join('/') : '';
exports.findAnnotationNode = findAnnotationNode;
/**
 * Traverses the nodes using path and returns last matching node.
 *
 * @param root Node from which to start the traversal.
 * @param path Path used to traverse.
 * @returns Node matching path
 */
const getNode = (root, path) => {
    const segments = path.split('/');
    let node = root;
    for (let i = 1; i < segments.length; i++) {
        const segment = segments[i];
        node = node[segment];
        if (!Array.isArray(node) && !node?.type) {
            return undefined;
        }
    }
    return node;
};
exports.getNode = getNode;
/**
 * Converts path to an array of nodes matching each segment of the path.
 *
 * @param root Node from which to start the traversal
 * @param path Path to a node
 * @returns Array containing all the matched nodes
 */
function getAstNodes(root, path) {
    const segments = path.split('/');
    let node = root;
    const nodes = [];
    for (let i = 1; i < segments.length; i++) {
        const segment = segments[i];
        node = node[segment];
        if (!Array.isArray(node) && !node?.type) {
            return undefined;
        }
        nodes.push(node);
    }
    return nodes;
}
exports.getAstNodes = getAstNodes;
//# sourceMappingURL=find-annotation-node.js.map