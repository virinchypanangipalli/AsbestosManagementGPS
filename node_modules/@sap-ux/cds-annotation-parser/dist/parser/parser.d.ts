import type { IOrAlt, CstNode, TokenType, IToken, SubruleMethodOpts } from 'chevrotain';
import { CstParser } from 'chevrotain';
import type { PATH_SEGMENT_SEPARATOR_TOKEN_TYPE, COLON_TOKEN_TYPE, COMMA_TOKEN_TYPE, NUMBER_SIGN_TOKEN_TYPE, DELIMITED_IDENTIFIER_EXIT_TOKEN_TYPE, IDENTIFIER_START_TOKEN_TYPE, QUOTED_IDENTIFIER_EXIT_TOKEN_TYPE, TRUE_TOKEN_TYPE, FALSE_TOKEN_TYPE, NUMBER_TOKEN_TYPE, SINGLE_QUOTE_TOKEN_TYPE, STRING_TOKEN_TYPE, STRING_EXIT_TOKEN_TYPE, QUOTED_IDENTIFIER_TOKEN_TYPE, DELIMITED_IDENTIFIER_TOKEN_TYPE, L_CURLY_TOKEN_TYPE, L_BRACKET_TOKEN_TYPE, R_BRACKET_TOKEN_TYPE, R_CURLY_TOKEN_TYPE, NULL_TOKEN_TYPE, BINARY_TOKEN_TYPE, DATE_TOKEN_TYPE, TIME_TOKEN_TYPE, TIMESTAMP_TOKEN_TYPE, SPREAD_OPERATOR, UP_TO_KEYWORD, BACKTICK_TOKEN_TYPE, TRIPLE_BACKTICK_TOKEN_TYPE, MULTI_LINE_STRING_TOKEN_TYPE, MULTI_LINE_STRING_EXIT_TOKEN_TYPE, MULTI_LINE_STRING_STRIP_INDENT_EXIT_TOKEN_TYPE, L_PAREN_TOKEN_TYPE, R_PAREN_TOKEN_TYPE, OPERATOR } from './tokens';
import { IDENTIFIER_TOKEN_TYPE } from './tokens';
declare const DECLARATION_TYPE = "declaration";
declare const PATH_TYPE = "path";
declare const PATH_SEGMENT_TYPE = "pathSegment";
declare const ASSIGNMENT_TYPE = "assignment";
declare const STRUCT_TYPE = "struct";
declare const COLLECTION_TYPE = "collection";
declare const ENUM_TYPE = "enum";
declare const STRING_TYPE = "string";
declare const MULTI_LINE_STRING_TYPE = "multiLineString";
declare const MULTI_LINE_STRING_STRIP_INDENT_TYPE = "multiLineStringStripIndent";
declare const QUOTED_IDENTIFIER_TYPE = "quotedIdentifier";
declare const DELIMITED_IDENTIFIER_TYPE = "delimitedIdentifier";
declare const VALUE_TYPE = "value";
declare const COLLECTION_VALUE_TYPE = "collectionValue";
declare const EXTEND_COLLECTION_VALUE_TYPE = "extendCollectionValue";
declare const EXPRESSION_TYPE = "expression";
export interface DeclarationCstNode extends CstNode {
    name: typeof DECLARATION_TYPE;
    children: DeclarationChildren;
}
export type DeclarationChildren = {
    [ASSIGNMENT_TYPE]?: AssignmentCstNode[];
};
export interface PathCstNode extends CstNode {
    name: typeof PATH_TYPE;
    children: PathChildren;
}
export type PathChildren = {
    [PATH_SEGMENT_SEPARATOR_TOKEN_TYPE]?: IToken[];
    [PATH_SEGMENT_TYPE]?: PathSegmentCstNode[];
};
export interface PathSegmentCstNode extends CstNode {
    name: typeof PATH_SEGMENT_TYPE;
    children: PathSegmentChildren;
}
export type PathSegmentChildren = {
    [NUMBER_SIGN_TOKEN_TYPE]?: IToken[];
    [IDENTIFIER_TOKEN_TYPE]?: IToken[];
    [DELIMITED_IDENTIFIER_TYPE]?: DelimitedIdentifierCstNode[];
    [QUOTED_IDENTIFIER_TYPE]?: QuotedIdentifierCstNode[];
};
export type AssignmentChildren = {
    [PATH_TYPE]: PathCstNode[];
    [NUMBER_SIGN_TOKEN_TYPE]?: IToken[];
    [IDENTIFIER_TOKEN_TYPE]?: IToken[];
    [VALUE_TYPE]: ValueCstNode[];
    [COLON_TOKEN_TYPE]: IToken[];
};
export interface AssignmentCstNode extends CstNode {
    name: typeof ASSIGNMENT_TYPE;
    children: AssignmentChildren;
}
export type StructChildren = {
    [L_CURLY_TOKEN_TYPE]?: IToken[];
    [R_CURLY_TOKEN_TYPE]?: IToken[];
    [ASSIGNMENT_TYPE]?: AssignmentCstNode[];
    [COMMA_TOKEN_TYPE]?: IToken[];
};
export interface StructCstNode extends CstNode {
    name: typeof STRUCT_TYPE;
    children: StructChildren;
}
export type CollectionChildren = {
    [COLLECTION_VALUE_TYPE]?: CollectionValueCstNode[];
    [COMMA_TOKEN_TYPE]?: IToken[];
    [L_BRACKET_TOKEN_TYPE]?: IToken[];
    [R_BRACKET_TOKEN_TYPE]?: IToken[];
};
export interface CollectionCstNode extends CstNode {
    name: typeof COLLECTION_TYPE;
    children: CollectionChildren;
}
export type EnumChildren = {
    [PATH_TYPE]?: PathCstNode[];
    [NUMBER_SIGN_TOKEN_TYPE]: IToken[];
};
export interface EnumCstNode extends CstNode {
    name: typeof ENUM_TYPE;
    children: EnumChildren;
}
export type StringChildren = {
    [SINGLE_QUOTE_TOKEN_TYPE]: IToken[];
    [STRING_TOKEN_TYPE]?: IToken[];
    [STRING_EXIT_TOKEN_TYPE]: IToken[];
};
export interface StringCstNode extends CstNode {
    name: typeof STRING_TYPE;
    children: StructChildren;
}
export type MultiLineStringChildren = {
    [BACKTICK_TOKEN_TYPE]: IToken[];
    [MULTI_LINE_STRING_TOKEN_TYPE]?: IToken[];
    [MULTI_LINE_STRING_EXIT_TOKEN_TYPE]: IToken[];
};
export interface MultiLineStringCstNode extends CstNode {
    name: typeof MULTI_LINE_STRING_TYPE;
    children: MultiLineStringChildren;
}
export type MultiLineStringStripIndentChildren = {
    [TRIPLE_BACKTICK_TOKEN_TYPE]: IToken[];
    [MULTI_LINE_STRING_TOKEN_TYPE]?: IToken[];
    [MULTI_LINE_STRING_STRIP_INDENT_EXIT_TOKEN_TYPE]: IToken[];
};
export interface MultiLineStringStripIndentCstNode extends CstNode {
    name: typeof MULTI_LINE_STRING_TYPE;
    children: MultiLineStringStripIndentChildren;
}
export type DelimitedIdentifierChildren = {
    [PATH_SEGMENT_SEPARATOR_TOKEN_TYPE]?: IToken[];
    [DELIMITED_IDENTIFIER_TOKEN_TYPE]: IToken[];
    [DELIMITED_IDENTIFIER_EXIT_TOKEN_TYPE]: IToken[];
    [IDENTIFIER_START_TOKEN_TYPE]: IToken[];
};
export interface DelimitedIdentifierCstNode extends CstNode {
    name: typeof DELIMITED_IDENTIFIER_TYPE;
    children: DelimitedIdentifierChildren;
}
export type QuotedIdentifierChildren = {
    [PATH_SEGMENT_SEPARATOR_TOKEN_TYPE]?: IToken[];
    [QUOTED_IDENTIFIER_TOKEN_TYPE]: IToken[];
    [QUOTED_IDENTIFIER_EXIT_TOKEN_TYPE]: IToken[];
};
export interface QuotedIdentifierCstNode extends CstNode {
    name: typeof QUOTED_IDENTIFIER_TYPE;
    children: QuotedIdentifierChildren;
}
export type ValueChildren = {
    [NULL_TOKEN_TYPE]?: IToken[];
    [TRUE_TOKEN_TYPE]?: IToken[];
    [FALSE_TOKEN_TYPE]?: IToken[];
    [BINARY_TOKEN_TYPE]?: IToken[];
    [DATE_TOKEN_TYPE]?: IToken[];
    [TIME_TOKEN_TYPE]?: IToken[];
    [TIMESTAMP_TOKEN_TYPE]?: IToken[];
    [NUMBER_TOKEN_TYPE]?: IToken[];
    [STRUCT_TYPE]?: StructCstNode[];
    [COLLECTION_TYPE]?: CollectionCstNode[];
    [ENUM_TYPE]?: EnumCstNode[];
    [STRING_TYPE]?: StringCstNode[];
    [MULTI_LINE_STRING_TYPE]?: MultiLineStringCstNode[];
    [MULTI_LINE_STRING_STRIP_INDENT_TYPE]?: MultiLineStringStripIndentCstNode[];
    [PATH_TYPE]?: PathCstNode[];
    [QUOTED_IDENTIFIER_TYPE]?: QuotedIdentifierCstNode[];
    [DELIMITED_IDENTIFIER_TYPE]?: DelimitedIdentifierCstNode[];
    [EXPRESSION_TYPE]?: ExpressionCstNode[];
};
export interface ValueCstNode extends CstNode {
    name: typeof VALUE_TYPE;
    children: ValueChildren;
}
export type ExtendCollectionValueChildren = {
    [SPREAD_OPERATOR]: IToken[];
    [UP_TO_KEYWORD]?: IToken[];
    [VALUE_TYPE]?: ValueCstNode[];
};
export interface ExtendCollectionValueCstNode extends CstNode {
    name: typeof EXTEND_COLLECTION_VALUE_TYPE;
    children: ExtendCollectionValueChildren;
}
export type CollectionValueChildren = ValueChildren & {
    [EXTEND_COLLECTION_VALUE_TYPE]?: ExtendCollectionValueCstNode[];
};
export interface CollectionValueCstNode extends CstNode {
    name: typeof COLLECTION_VALUE_TYPE;
    children: CollectionValueChildren;
}
export interface ExpressionCstNode extends CstNode {
    name: typeof EXPRESSION_TYPE;
    children: ExpressionChildren;
}
export type ExpressionChildren = {
    [L_PAREN_TOKEN_TYPE]: IToken[];
    [R_PAREN_TOKEN_TYPE]?: IToken[];
    [VALUE_TYPE]?: ValueCstNode[];
    [OPERATOR]?: IToken[];
};
/**
 *
 */
export declare class AnnotationParser extends CstParser {
    deletionRecoveryEnabled: boolean;
    /**
     * Array caching optimization for collection values
     * https://chevrotain.io/docs/guide/performance.html#caching-arrays-of-alternatives
     */
    cv?: IOrAlt<void>[];
    /**
     * Array caching optimization for values
     * https://chevrotain.io/docs/guide/performance.html#caching-arrays-of-alternatives
     */
    v?: IOrAlt<void>[];
    private CST_STACK;
    text: string;
    constructor();
    createOrSubruleEntry: (rule: (idx: number) => CstNode, options?: SubruleMethodOpts) => IOrAlt<void>;
    createOrConsumeEntry: (token: TokenType, gate?: () => boolean) => IOrAlt<void>;
    /**
     * Checks if recovery could be done for the given expected token type.
     *
     * @param expectedTokType expected token type
     * @returns boolean result
     */
    canRecoverWithSingleTokenDeletion(expectedTokType: TokenType): boolean;
    /**
     *
     * @param endToken Ending CST token type
     * @param repetitionRule Repetition rule function
     */
    CUSTOM_MANY(endToken: TokenType, repetitionRule: (idxInCallingRule?: number, ...args: any[]) => CstNode): void;
    /**
     *
     * @param previousToken Previous CST token
     */
    private adjustAssignmentRange;
    [DECLARATION_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [ASSIGNMENT_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [PATH_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [PATH_SEGMENT_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [VALUE_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [COLLECTION_VALUE_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [EXTEND_COLLECTION_VALUE_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [STRUCT_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [COLLECTION_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [ENUM_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [QUOTED_IDENTIFIER_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [DELIMITED_IDENTIFIER_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [STRING_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [MULTI_LINE_STRING_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [MULTI_LINE_STRING_STRIP_INDENT_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    [EXPRESSION_TYPE]: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode;
    /**
     *
     * @param error Mismatched token error object
     */
    private recoverFromMissingKey;
}
export {};
//# sourceMappingURL=parser.d.ts.map