"use strict";
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnnotationParser = void 0;
const chevrotain_1 = require("chevrotain");
const utils_1 = require("../utils");
const tokens_1 = require("./tokens");
const allTokens = Object.values(tokens_1.tokenMap);
const DECLARATION_TYPE = 'declaration';
const PATH_TYPE = 'path';
const PATH_SEGMENT_TYPE = 'pathSegment';
const ASSIGNMENT_TYPE = 'assignment';
const STRUCT_TYPE = 'struct';
const COLLECTION_TYPE = 'collection';
const ENUM_TYPE = 'enum';
const STRING_TYPE = 'string';
const MULTI_LINE_STRING_TYPE = 'multiLineString';
const MULTI_LINE_STRING_STRIP_INDENT_TYPE = 'multiLineStringStripIndent';
const QUOTED_IDENTIFIER_TYPE = 'quotedIdentifier';
const DELIMITED_IDENTIFIER_TYPE = 'delimitedIdentifier';
const VALUE_TYPE = 'value';
const COLLECTION_VALUE_TYPE = 'collectionValue';
const EXTEND_COLLECTION_VALUE_TYPE = 'extendCollectionValue';
const EXPRESSION_TYPE = 'expression';
const LINE_BREAK_PATTERN = /\r\n|\r|\n/g;
/**
 *
 */
class AnnotationParser extends chevrotain_1.CstParser {
    constructor() {
        super(allTokens, {
            maxLookahead: 1,
            recoveryEnabled: true,
            nodeLocationTracking: 'full',
            // This could reduce 30-50% of the initialization time
            // Enable validation for debugging
            skipValidations: true
        });
        this.deletionRecoveryEnabled = true;
        this.text = '';
        this.createOrSubruleEntry = (rule, options) => ({
            ALT: () => {
                this.SUBRULE(rule, options);
            }
        });
        this.createOrConsumeEntry = (token, gate) => ({
            ALT: () => {
                this.CONSUME(token);
            },
            GATE: gate
        });
        this[_a] = this.RULE(DECLARATION_TYPE, () => {
            this.SUBRULE(this[ASSIGNMENT_TYPE]);
        });
        this[_b] = this.RULE(ASSIGNMENT_TYPE, () => {
            this.OR([
                {
                    GATE: () => this.LA(1).tokenType === tokens_1.tokenMap.Colon,
                    ALT: () => {
                        // key is missing, but there is colon
                        const previousToken = this.LA(0);
                        this.CONSUME(tokens_1.tokenMap.Colon);
                        this.SUBRULE(this[VALUE_TYPE]);
                        this.adjustAssignmentRange(previousToken);
                    }
                },
                {
                    GATE: () => this.LA(1).tokenType === tokens_1.tokenMap.NumberSign,
                    ALT: () => {
                        // Avoid removing number sign if path is missing e.g '#q: 1'
                        const previousToken = this.LA(0);
                        this.CONSUME(tokens_1.tokenMap.NumberSign);
                        this.CONSUME(tokens_1.tokenMap.Identifier);
                        this.OPTION(() => {
                            this.CONSUME1(tokens_1.tokenMap.Colon);
                            this.SUBRULE1(this[VALUE_TYPE]);
                        });
                        this.adjustAssignmentRange(previousToken);
                    }
                },
                {
                    ALT: () => {
                        try {
                            this.deletionRecoveryEnabled = false;
                            this.SUBRULE(this[PATH_TYPE]);
                        }
                        finally {
                            this.deletionRecoveryEnabled = true;
                        }
                        this.OPTION1(() => {
                            this.CONSUME1(tokens_1.tokenMap.NumberSign);
                            this.CONSUME1(tokens_1.tokenMap.Identifier);
                        });
                        this.OPTION2(() => {
                            this.CONSUME2(tokens_1.tokenMap.Colon);
                            try {
                                this.SUBRULE2(this[VALUE_TYPE]);
                            }
                            catch (error) {
                                const isMismatchedTokenException = (err) => {
                                    return (err?.name === 'NoViableAltException' &&
                                        err?.previousToken?.tokenType === tokens_1.tokenMap.Colon &&
                                        err?.token?.tokenType === chevrotain_1.EOF);
                                };
                                if (isMismatchedTokenException(error)) {
                                    this.recoverFromMissingKey(error);
                                }
                                else {
                                    // we have to rethrow error if we do not handle, so chevrotain error recovery can try to handle it
                                    throw error;
                                }
                            }
                        });
                    }
                }
            ]);
        });
        this[_c] = this.RULE(PATH_TYPE, (valuePath) => {
            this.SUBRULE(this[PATH_SEGMENT_TYPE], { ARGS: [valuePath] });
            this.MANY(() => {
                this.CONSUME(tokens_1.tokenMap.PathSegmentSeparator);
                try {
                    // Avoid removing trailing dots e.g 'aaa.' would be parsed as 'aaa'
                    this.deletionRecoveryEnabled = false;
                    this.SUBRULE2(this[PATH_SEGMENT_TYPE], { ARGS: [valuePath] });
                }
                finally {
                    this.deletionRecoveryEnabled = true;
                }
            });
        });
        this[_d] = this.RULE(PATH_SEGMENT_TYPE, (valuePath) => {
            this.OR({
                DEF: [
                    this.createOrSubruleEntry(this[DELIMITED_IDENTIFIER_TYPE]),
                    this.createOrSubruleEntry(this[QUOTED_IDENTIFIER_TYPE]),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Identifier),
                    {
                        ALT: () => {
                            this.CONSUME(tokens_1.tokenMap.TermCastIdentifier, { LABEL: tokens_1.IDENTIFIER_TOKEN_TYPE });
                        },
                        GATE: () => valuePath
                    }
                ]
            });
            this.OPTION({
                GATE: () => valuePath,
                DEF: () => {
                    this.CONSUME2(tokens_1.tokenMap.TermCastIdentifier, { LABEL: tokens_1.IDENTIFIER_TOKEN_TYPE });
                }
            });
            this.OPTION2({
                GATE: () => valuePath,
                DEF: () => {
                    this.CONSUME(tokens_1.tokenMap.NumberSign);
                    this.CONSUME2(tokens_1.tokenMap.Identifier);
                }
            });
        });
        this[_e] = this.RULE(VALUE_TYPE, () => {
            this.OR(this.v ??
                (this.v = [
                    this.createOrConsumeEntry(tokens_1.tokenMap.Null),
                    this.createOrConsumeEntry(tokens_1.tokenMap.True),
                    this.createOrConsumeEntry(tokens_1.tokenMap.False),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Binary),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Date),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Time),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Timestamp),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Number),
                    this.createOrSubruleEntry(this[PATH_TYPE], { ARGS: [true] }),
                    this.createOrSubruleEntry(this[STRUCT_TYPE]),
                    this.createOrSubruleEntry(this[COLLECTION_TYPE]),
                    this.createOrSubruleEntry(this[ENUM_TYPE]),
                    this.createOrSubruleEntry(this[STRING_TYPE]),
                    this.createOrSubruleEntry(this[MULTI_LINE_STRING_STRIP_INDENT_TYPE]),
                    this.createOrSubruleEntry(this[MULTI_LINE_STRING_TYPE]),
                    this.createOrSubruleEntry(this[EXPRESSION_TYPE])
                ]));
        });
        this[_f] = this.RULE(COLLECTION_VALUE_TYPE, () => {
            this.OR(this.cv ??
                (this.cv = [
                    this.createOrConsumeEntry(tokens_1.tokenMap.Null),
                    this.createOrConsumeEntry(tokens_1.tokenMap.True),
                    this.createOrConsumeEntry(tokens_1.tokenMap.False),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Binary),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Date),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Time),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Timestamp),
                    this.createOrConsumeEntry(tokens_1.tokenMap.Number),
                    this.createOrSubruleEntry(this[EXTEND_COLLECTION_VALUE_TYPE]),
                    this.createOrSubruleEntry(this[PATH_TYPE], { ARGS: [true] }),
                    this.createOrSubruleEntry(this[STRUCT_TYPE]),
                    this.createOrSubruleEntry(this[COLLECTION_TYPE]),
                    this.createOrSubruleEntry(this[ENUM_TYPE]),
                    this.createOrSubruleEntry(this[STRING_TYPE]),
                    this.createOrSubruleEntry(this[MULTI_LINE_STRING_STRIP_INDENT_TYPE]),
                    this.createOrSubruleEntry(this[MULTI_LINE_STRING_TYPE]),
                    this.createOrSubruleEntry(this[EXPRESSION_TYPE])
                ]));
        });
        this[_g] = this.RULE(EXTEND_COLLECTION_VALUE_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.SpreadOperator);
            this.OPTION(() => {
                this.CONSUME(tokens_1.tokenMap.UpToKeyword);
                this.SUBRULE(this[VALUE_TYPE]);
            });
        });
        this[_h] = this.RULE(STRUCT_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.LCurly);
            this.OPTION(() => {
                this.CUSTOM_MANY(tokens_1.tokenMap.RCurly, this[ASSIGNMENT_TYPE]);
            });
            this.CONSUME(tokens_1.tokenMap.RCurly);
        });
        this[_j] = this.RULE(COLLECTION_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.LBracket);
            this.OPTION(() => {
                this.CUSTOM_MANY(tokens_1.tokenMap.RBracket, this[COLLECTION_VALUE_TYPE]);
            });
            this.CONSUME(tokens_1.tokenMap.RBracket);
        });
        this[_k] = this.RULE(ENUM_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.NumberSign);
            this.OPTION(() => {
                this.SUBRULE(this[PATH_TYPE]);
            });
        });
        this[_l] = this.RULE(QUOTED_IDENTIFIER_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.DoubleQuote);
            this.OPTION(() => {
                this.CONSUME(tokens_1.tokenMap.QuotedIdentifier);
                this.MANY(() => {
                    this.CONSUME(tokens_1.tokenMap.PathSegmentSeparator);
                    this.CONSUME2(tokens_1.tokenMap.QuotedIdentifier);
                });
            });
            this.CONSUME2(tokens_1.tokenMap.QuotedIdentifierExit);
        });
        this[_m] = this.RULE(DELIMITED_IDENTIFIER_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.IdentifierStart);
            this.OPTION(() => {
                this.CONSUME(tokens_1.tokenMap.DelimitedIdentifier);
                this.MANY(() => {
                    this.CONSUME(tokens_1.tokenMap.PathSegmentSeparator);
                    this.CONSUME2(tokens_1.tokenMap.DelimitedIdentifier);
                });
            });
            this.CONSUME(tokens_1.tokenMap.DelimitedIdentifierExit);
        });
        this[_o] = this.RULE(STRING_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.SingleQuote);
            this.OPTION(() => {
                this.CONSUME(tokens_1.tokenMap.String);
            });
            this.CONSUME(tokens_1.tokenMap.StringExit);
        });
        this[_p] = this.RULE(MULTI_LINE_STRING_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.Backtick);
            this.OPTION(() => {
                this.CONSUME(tokens_1.tokenMap.MultiLineString);
            });
            this.CONSUME(tokens_1.tokenMap.MultiLineStringExit);
        });
        this[_q] = this.RULE(MULTI_LINE_STRING_STRIP_INDENT_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.TripleBacktick);
            this.OPTION(() => {
                this.CONSUME(tokens_1.tokenMap.MultiLineString);
            });
            this.CONSUME(tokens_1.tokenMap.MultiLineStringStripIndentExit);
        });
        this[_r] = this.RULE(EXPRESSION_TYPE, () => {
            this.CONSUME(tokens_1.tokenMap.LParen);
            this.MANY(() => {
                this.OR([
                    {
                        ALT: () => this.SUBRULE(this[VALUE_TYPE])
                    },
                    {
                        ALT: () => this.CONSUME1(tokens_1.tokenMap.Operator)
                    }
                ]);
            });
            this.CONSUME(tokens_1.tokenMap.RParen);
        });
        this.performSelfAnalysis();
    }
    /**
     * Checks if recovery could be done for the given expected token type.
     *
     * @param expectedTokType expected token type
     * @returns boolean result
     */
    canRecoverWithSingleTokenDeletion(expectedTokType) {
        if (this.deletionRecoveryEnabled === false) {
            return false;
        }
        // We need to override the default logic for recovery with single token deletion.
        // Sometimes we need to completely disable it to produce better CST
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        return super['canRecoverWithSingleTokenDeletion'](expectedTokType);
    }
    /**
     *
     * @param endToken Ending CST token type
     * @param repetitionRule Repetition rule function
     */
    CUSTOM_MANY(endToken, repetitionRule) {
        this.MANY(() => {
            // workaround for https://github.com/SAP/chevrotain/issues/1200 once it is fixed we can use empty alternative
            this.OR([
                {
                    GATE: () => this.LA(1).tokenType === tokens_1.tokenMap.Comma &&
                        (this.LA(2).tokenType === endToken || this.LA(2).tokenType === tokens_1.tokenMap.Comma),
                    ALT: () => this.CONSUME2(tokens_1.tokenMap.Comma)
                },
                {
                    GATE: () => this.LA(1).tokenType === tokens_1.tokenMap.Comma && this.LA(2).tokenType !== endToken,
                    ALT: () => {
                        this.CONSUME3(tokens_1.tokenMap.Comma);
                        this.SUBRULE(repetitionRule);
                    }
                },
                {
                    ALT: () => this.SUBRULE1(repetitionRule)
                }
            ]);
        });
    }
    /**
     *
     * @param previousToken Previous CST token
     */
    adjustAssignmentRange(previousToken) {
        // adjust location since value is missing
        const node = this['CST_STACK'][this['CST_STACK'].length - 1];
        if (node && previousToken && node.location) {
            // token length is not taken into account for position information
            const length = previousToken.image.length;
            node.location.startOffset = (previousToken.endOffset ?? 0) + length;
            node.location.startLine = previousToken.endLine ?? 0;
            node.location.startColumn = (previousToken.endColumn ?? 0) + length;
        }
    }
    /**
     *
     * @param error Mismatched token error object
     */
    recoverFromMissingKey(error) {
        // insert empty value till the end of document.
        const previousToken = error.previousToken;
        const remainingText = this.text.substring((previousToken.endOffset ?? 0) + 1);
        const lines = remainingText.split(LINE_BREAK_PATTERN);
        if (lines.length) {
            // ignore subsequent lines, in the future we may consider also remaining lines
            const line = lines[0];
            const assignmentCstNode = this['CST_STACK'][this['CST_STACK'].length - 1];
            if ((0, utils_1.hasItems)(assignmentCstNode.children[VALUE_TYPE])) {
                const valueNode = assignmentCstNode.children[VALUE_TYPE][0];
                if ((0, utils_1.isDefined)(valueNode.location)) {
                    valueNode.location.startLine = previousToken.endLine ?? 0;
                    valueNode.location.startColumn = (previousToken.endColumn ?? 0) + 1;
                    valueNode.location.startOffset = (previousToken.endOffset ?? 0) + 1;
                    valueNode.location.endOffset = valueNode.location.startOffset + line.length;
                    valueNode.location.endColumn = valueNode.location.startOffset + line.length;
                    valueNode.location.endLine = previousToken.endLine;
                }
                // Update assignment end position
                if ((0, utils_1.isDefined)(assignmentCstNode.location) && (0, utils_1.isDefined)(valueNode.location)) {
                    assignmentCstNode.location.endOffset = valueNode.location.endOffset;
                    assignmentCstNode.location.endColumn = valueNode.location.endColumn;
                    assignmentCstNode.location.endLine = valueNode.location.endLine;
                }
            }
        }
    }
}
exports.AnnotationParser = AnnotationParser;
_a = DECLARATION_TYPE, _b = ASSIGNMENT_TYPE, _c = PATH_TYPE, _d = PATH_SEGMENT_TYPE, _e = VALUE_TYPE, _f = COLLECTION_VALUE_TYPE, _g = EXTEND_COLLECTION_VALUE_TYPE, _h = STRUCT_TYPE, _j = COLLECTION_TYPE, _k = ENUM_TYPE, _l = QUOTED_IDENTIFIER_TYPE, _m = DELIMITED_IDENTIFIER_TYPE, _o = STRING_TYPE, _p = MULTI_LINE_STRING_TYPE, _q = MULTI_LINE_STRING_STRIP_INDENT_TYPE, _r = EXPRESSION_TYPE;
//# sourceMappingURL=parser.js.map