"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileSequence = void 0;
/**
 * get CDS file sequence
 * @param compileModel
 *  - each source has the property "_layerRepresentative" which is (another or the same) source representing a "layer"
 *  - a source which represents a layer has the property "_layerExtends" a dictionary of directly or indirectly dependent layer representatives
 */
function getFileSequence(compileModel) {
    // find sequence of layer representatives using topological sort (based on _layerExtends - 'edges')
    const fileSequenceOrig = Object.keys(compileModel.sources ?? {});
    const { incomingEdges, layerRepFiles, outgoingEdges } = calculateEdges(compileModel);
    const layerRepSequence = [];
    while (getNextFileNameWithNoIncomingEdge(fileSequenceOrig, incomingEdges)) {
        // next filename with no incoming edge: insert it at start
        const fileName = getNextFileNameWithNoIncomingEdge(fileSequenceOrig, incomingEdges, true);
        if (fileName) {
            layerRepSequence.unshift(fileName);
            // remove all outgoing edges for that file
            const outGoingEdge = outgoingEdges?.get(fileName);
            if (outGoingEdge) {
                for (const targetFileName of outGoingEdge) {
                    incomingEdges?.get(targetFileName)?.delete(fileName);
                }
            }
        }
    }
    // if there are still nodes with incomingEdges then graph has at least one cycle
    if (incomingEdges.size > 0) {
        return fileSequenceOrig;
    } // return old sequence
    // replace layer representative with all files of that layer
    const fileSequence = [];
    for (const layerRepFileName of layerRepSequence) {
        const layerRepFile = layerRepFiles?.get(layerRepFileName);
        if (layerRepFile) {
            fileSequence.push(...layerRepFile);
        }
    }
    return fileSequence;
}
exports.getFileSequence = getFileSequence;
function calculateEdges(compileModel) {
    const outgoingEdges = new Map();
    const incomingEdges = new Map();
    const layerRepFiles = new Map();
    for (const fileName of Object.keys(compileModel.sources || {})) {
        const layerRep = compileModel.sources[fileName]._layerRepresentative;
        const layerRepFileName = layerRep?.realname;
        if (!layerRepFileName) {
            continue;
        }
        if (!layerRepFiles.has(layerRepFileName)) {
            layerRepFiles.set(layerRepFileName, new Set());
        }
        layerRepFiles?.get(layerRepFileName)?.add(fileName);
        if (!outgoingEdges.has(layerRepFileName)) {
            outgoingEdges.set(layerRepFileName, new Set());
        }
        if (!incomingEdges.has(layerRepFileName)) {
            incomingEdges.set(layerRepFileName, new Set());
        }
        const targets = Object.keys(layerRep._layerExtends || {});
        targets.forEach((target) => {
            outgoingEdges?.get(layerRepFileName)?.add(target);
            if (!incomingEdges.has(target)) {
                incomingEdges.set(target, new Set());
            }
            incomingEdges?.get(target)?.add(layerRepFileName);
        });
    }
    return { outgoingEdges, incomingEdges, layerRepFiles };
}
function getNextFileNameWithNoIncomingEdge(fileSequenceOrig, incomingEdges, remove = false) {
    // try to follow the original file sequence
    for (let i = fileSequenceOrig.length - 1; i >= 0; i--) {
        const fileName = fileSequenceOrig[i];
        if (incomingEdges.get(fileName)?.size === 0) {
            if (remove) {
                incomingEdges.delete(fileName);
            }
            return fileName;
        }
    }
    return null; // not found
}
//# sourceMappingURL=fileSequence.js.map