"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildGhostFiles = exports.toPropagatedTargetMap = void 0;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const url_1 = require("url");
const utils_1 = require("../utils");
const metadata_1 = require("../metadata");
const kindsForPropagation = ['element', 'entity', 'type', 'view', 'action', 'function'];
// cache results of findSourceTargetName()
const sourceTargetNameForLocation = new Map();
const getNamespace = (fullyQualifiedName) => {
    const parts = fullyQualifiedName.split('.');
    parts.pop();
    return parts.join('.');
};
/**
 * Function generates a map of propagated targets (per file), i.e.
 * original target => list of targets to which original annotations are propagated
 * The map is used to build ghost files with propagated annotations
 * @param ast - XSN compile model
 * @param serviceName - name of service for which API was instantiated (API use case)
 *      used to limit propagation data by the scope which is relevant for API consumers
 * @param files - array of source files in generic format (LSP use case)
 */
const toPropagatedTargetMap = (ast, serviceName, files) => {
    const targetMaps = {
        propTargetMap: {},
        existingTargetMap: undefined,
        visitedTargetMap: {},
        sourceUris: new Set()
    };
    sourceTargetNameForLocation.clear();
    if (files && files.length > 0) {
        // LSP use case, existing targets are taken from generic files
        targetMaps.existingTargetMap = new Set();
        getTargetsFromGenericFiles(ast, files, targetMaps);
    }
    else {
        processTargetsFromService(ast, targetMaps, serviceName);
    }
    return { propagationMap: targetMaps.propTargetMap, sourceUris: targetMaps.sourceUris };
};
exports.toPropagatedTargetMap = toPropagatedTargetMap;
function processTargetsFromService(ast, targetMaps, serviceName) {
    const targetArtifacts = getTargetFromServiceDef(serviceName, ast);
    for (const artifact of targetArtifacts) {
        // entities, (unbound) actions/functions
        const artifactName = (0, utils_1.getNameObj)(artifact, ast.compiler).absolute + (['action', 'function'].includes(artifact.kind) ? '()' : '');
        buildMapForTarget(targetMaps, ast, artifactName, [], artifact, false);
        // entity elements
        processEntityElements(artifact, targetMaps, artifactName, ast);
        // bound actions/functions
        processTargetsOfBoundActionAndFunction(artifact, targetMaps, artifactName, ast);
        // parameters (of unbound actions functions)
        for (const name of Object.keys(artifact.params || {})) {
            const param = artifact?.params?.[name];
            if (param) {
                const paramName = (0, utils_1.getNameObj)(param, ast.compiler).param;
                buildMapForTarget(targetMaps, ast, artifactName, [paramName], param);
            }
        }
    }
}
function processEntityElements(artifact, targetMaps, artifactName, ast) {
    const names = Object.keys(artifact.elements ?? {});
    for (const name of names) {
        const element = artifact?.elements?.[name];
        if (element) {
            buildMapForTarget(targetMaps, ast, artifactName, [(0, utils_1.getNameObj)(element, ast.compiler).element], element);
        }
    }
}
function processTargetsOfBoundActionAndFunction(artifact, targetMaps, artifactName, ast) {
    const actions = Object.keys(artifact.actions ?? {});
    for (const name of actions) {
        const action = artifact?.actions?.[name];
        const namespace = getNamespace(artifactName);
        if (action) {
            const actionName = (0, utils_1.getNameObj)(action, ast.compiler).action;
            const actionFQName = `${namespace}.${actionName}(${artifactName})`;
            buildMapForTarget(targetMaps, ast, actionFQName, [], action);
            //  parameter of bound actions functions
            const parameters = Object.keys(action.params ?? {});
            for (const parameterName of parameters) {
                const param = action?.params?.[parameterName];
                if (param) {
                    buildMapForTarget(targetMaps, ast, actionFQName, [(0, utils_1.getNameObj)(param, ast.compiler).param], param);
                }
            }
        }
    }
}
function buildMapForTarget(targetMaps, ast, targetName, targetPathSegments, targetDefinition, isPropagatedElement = false) {
    const fullTargetName = [targetName, ...targetPathSegments].join('/');
    // No need to process each specific target multiple times
    // because we are replicating all annotations propagated to this target at once.
    // In LSP use case propagation is taking place for existing targets only
    const needProcessing = !targetMaps.visitedTargetMap[fullTargetName] &&
        (!targetMaps.existingTargetMap || targetMaps.existingTargetMap.has(fullTargetName));
    if (!needProcessing) {
        return;
    }
    targetMaps.visitedTargetMap[fullTargetName] = true;
    const propagatedAnnotationRefs = getPropagatedAnnoRefs(targetDefinition, isPropagatedElement);
    prepareMapWithTargets(ast, propagatedAnnotationRefs, fullTargetName, targetMaps);
    // propagation of annotations applied to navigation property target
    const finalType = targetDefinition._effectiveType;
    if (finalType) {
        const targetArtifact = finalType.kind === 'element' && finalType.target && finalType.target._artifact;
        if (targetArtifact && ['entity', 'view'].includes(targetArtifact.kind) && targetArtifact.name) {
            buildMapForTarget(targetMaps, ast, (0, utils_1.getNameObj)(targetArtifact, ast.compiler).absolute, [], targetArtifact, true);
        }
    }
    // propagation of annotations applied to nested elements of target
    const keys = Object.keys(finalType?.elements ?? {});
    for (const key of keys) {
        if (finalType?.elements?.[key]) {
            buildMapForTarget(targetMaps, ast, targetName, [...targetPathSegments, key], finalType.elements[key], isPropagatedElement);
        }
    }
}
function getTargetsFromGenericFile(ast, targetMaps, currentTarget) {
    const path = currentTarget.name.split('/');
    const targetBaseName = path.shift();
    const intermediateTargetPath = [];
    const rootDefinition = ast.definitions[targetBaseName];
    if (!rootDefinition) {
        return;
    }
    let doPropagation = false;
    // find target subelement by element path
    let definition = rootDefinition;
    let isPropagatedElement = false;
    while (definition && path.length) {
        // starting propagation at the outermost entity type or complex type
        doPropagation = doPropagation || kindsForPropagation.includes(definition.kind);
        if (doPropagation) {
            buildMapForTarget(targetMaps, ast, targetBaseName, intermediateTargetPath, definition, isPropagatedElement);
        }
        const elementName = path.shift();
        definition = (definition._effectiveType?.elements ?? {})[elementName];
        if (definition) {
            // element considered as propagated when it has $inferred in its type definition
            // all nested elements considered as propagated as well
            isPropagatedElement =
                isPropagatedElement ||
                    (definition._effectiveType !== definition && definition.type?.$inferred === 'prop');
        }
        intermediateTargetPath.push(elementName);
    }
    if (definition) {
        buildMapForTarget(targetMaps, ast, targetBaseName, intermediateTargetPath, definition, isPropagatedElement);
    }
}
function getTargetsFromGenericFiles(ast, files, targetMaps) {
    const existingTargets = [];
    for (const file of files) {
        for (const target of file.content.targets ?? []) {
            existingTargets.push(target);
            targetMaps?.existingTargetMap?.add(target.name);
        }
    }
    for (const currentTarget of existingTargets) {
        getTargetsFromGenericFile(ast, targetMaps, currentTarget);
    }
}
function getPropagatedAnnoRefs(targetDefinition, isPropagatedElement) {
    const result = [];
    for (const key of Object.keys(targetDefinition)) {
        if (!key.startsWith('@')) {
            continue;
        }
        const annotation = targetDefinition[key];
        if (annotation.$inferred === 'prop' || isPropagatedElement) {
            if (Array.isArray(annotation)) {
                result.push(...annotation);
            }
            result.push(annotation);
        }
    }
    return result;
}
function prepareMapWithTargets(ast, propagatedAnnotationRefs, fullTargetName, maps) {
    for (const ref of propagatedAnnotationRefs) {
        // look up for original annotation instance
        const location = ref.location || ref.name?.location;
        if (location) {
            const sourceTargetName = findSourceTargetName(ast, location);
            if (sourceTargetName && sourceTargetName !== fullTargetName) {
                if (location.file) {
                    maps.sourceUris.add(location.file);
                }
                const sourceTargetNameCorrected = (0, metadata_1.convertNameToEdmxInternal)(sourceTargetName, ast);
                const fullTargetNameCorrected = (0, metadata_1.convertNameToEdmxInternal)(fullTargetName, ast);
                maps.propTargetMap[sourceTargetNameCorrected] = maps.propTargetMap[sourceTargetNameCorrected] ?? {};
                maps.propTargetMap[sourceTargetNameCorrected][fullTargetNameCorrected] = true;
            }
        }
    }
}
function getTargetFromServiceDef(serviceName, ast) {
    const targetArtifacts = [];
    if (serviceName) {
        if (ast.definitions[serviceName]?.kind === 'service') {
            const serviceArtifacts = Object.keys(ast.definitions[serviceName].artifacts ?? {}).map((name) => ast?.definitions?.[serviceName]?.artifacts?.[name]);
            targetArtifacts.push(...serviceArtifacts.filter((artifact) => kindsForPropagation.includes(artifact.kind)));
        }
    }
    else {
        const allArtifacts = getArtifactsRecursively(Object.keys(ast.definitions ?? {}).map((name) => ast.definitions[name]));
        targetArtifacts.push(...allArtifacts.filter((artifact) => kindsForPropagation.includes(artifact.kind)));
    }
    return targetArtifacts;
}
function getArtifactsRecursively(artifacts) {
    const newArtifacts = [];
    for (const artifact of artifacts) {
        newArtifacts.push(...Object.keys(artifact.artifacts || {}).map((name) => artifact?.artifacts?.[name]));
    }
    if (newArtifacts.length) {
        return [...newArtifacts, ...getArtifactsRecursively(newArtifacts)];
    }
    else {
        return newArtifacts;
    }
}
function isLocationBefore(aLine, aColumn, bLine, bColumn) {
    if (aLine < bLine) {
        return true;
    }
    if (aLine > bLine) {
        return false;
    }
    return aColumn <= bColumn;
}
function isLocationContainedIn(a, b) {
    return isLocationBefore(a.line, a.col, b.line, b.col) && isLocationBefore(b.endLine, b.endCol, a.endLine, a.endCol);
}
const processAssignmentAnnotations = (element, name) => {
    if (!element.location) {
        return;
    }
    for (const key of Object.keys(element)) {
        if (!key.startsWith('@')) {
            continue;
        }
        const annotation = element[key];
        const annotationLocation = annotation.location || annotation.name?.location;
        if (annotationLocation &&
            annotationLocation.file === element.location.file &&
            isLocationContainedIn(element.location, annotationLocation)) {
            sourceTargetNameForLocation.set(getCacheKey(annotationLocation), name);
        }
    }
};
function getCachedResult(location) {
    const key = getCacheKey(location);
    if (sourceTargetNameForLocation.has(key)) {
        return sourceTargetNameForLocation.get(key);
    }
    return undefined;
}
function getCacheKey(location) {
    const { line, col, endLine, endCol } = location || {};
    return `${location?.file} ${line}:${col}-${endLine}:${endCol}`;
}
const processArtifact = (annotatedObject, compiler, buildName) => {
    let name = '';
    const carrierArtifact = annotatedObject?.name?._artifact || annotatedObject;
    const carrierArtifactName = (0, utils_1.getNameObj)(carrierArtifact, compiler);
    if (carrierArtifactName?.absolute) {
        name = buildName(carrierArtifact);
    }
    processAssignmentAnnotations(annotatedObject, name);
};
function getArtifacts(ast, location) {
    let artifacts = [];
    const sourceFileName = Object.keys(ast.sources).find((fileName) => ast.sources[fileName].location?.file === location.file);
    if (sourceFileName) {
        const source = ast.sources[sourceFileName];
        artifacts = Object.keys(source.artifacts || {}).map((name) => source.artifacts[name]);
        artifacts.push(...getArtifactsRecursively(artifacts));
        if (source.extensions && source.extensions.length) {
            artifacts.push(...source.extensions);
        }
    }
    artifacts = artifacts.filter((item) => item.kind !== 'using');
    return artifacts;
}
function processArtifactElements(ast, artifact) {
    for (const name of Object.keys(artifact.elements || {})) {
        const element = artifact?.elements?.[name];
        if (element) {
            processArtifact(element, ast.compiler, (elementNamed) => [(0, utils_1.getNameObj)(elementNamed, ast.compiler).absolute, (0, utils_1.getNameObj)(elementNamed, ast.compiler).element].join('/'));
        }
    }
}
function processUnboundActionsFunctions(ast, artifact) {
    const buildArtifactName = (artifactNamed) => (0, utils_1.getNameObj)(artifactNamed, ast.compiler).absolute + (['action', 'function'].includes(artifact.kind) ? '()' : '');
    for (const name of Object.keys(artifact.params || {})) {
        const param = artifact?.params?.[name];
        const buildParamName = (actionName) => (paramNamed) => {
            return [actionName, (0, utils_1.getNameObj)(paramNamed, ast.compiler).param].join('/');
        };
        const actionName = buildArtifactName(artifact);
        processArtifact(param, ast.compiler, buildParamName(actionName));
    }
}
// Helper function to extract the action name
function getActionName(action, compiler) {
    return (0, utils_1.getNameObj)(action, compiler).action;
}
function processBoundActionsAndFunctions(name, ast, artifact) {
    const action = artifact?.actions?.[name];
    const actionName = getActionName(action, ast.compiler);
    if (actionName) {
        const buildArtifactName = (artifactNamed) => (0, utils_1.getNameObj)(artifactNamed, ast.compiler).absolute +
            (['action', 'function'].includes(artifact.kind) ? '()' : '');
        processArtifact(action, ast.compiler, buildArtifactName);
        for (const pname of Object.keys(action.params || {})) {
            const param = action?.params?.[pname];
            processArtifact(param, ast.compiler, buildArtifactName);
        }
    }
}
function processEntityElement(ast, artifact) {
    processArtifactElements(ast, artifact);
    const entityName = (0, utils_1.getNameObj)(artifact, ast.compiler).absolute;
    if (entityName) {
        for (const name of Object.keys(artifact.actions || {})) {
            processBoundActionsAndFunctions(name, ast, artifact);
        }
    }
    processUnboundActionsFunctions(ast, artifact);
}
function findSourceTargetName(ast, location) {
    // try to get cached result
    let result = getCachedResult(location) || '';
    if (result) {
        return result;
    }
    const artifacts = getArtifacts(ast, location);
    for (const artifact of artifacts) {
        // entities, (unbound) actions/functions
        const buildArtifactName = (artifactNamed) => (0, utils_1.getNameObj)(artifactNamed, ast.compiler).absolute +
            (['action', 'function'].includes(artifact.kind) ? '()' : '');
        processArtifact(artifact, ast.compiler, buildArtifactName);
        processEntityElement(ast, artifact);
    }
    result = getCachedResult(location) || '';
    return result;
}
function buildGhostFiles(ast, files) {
    const ghostFiles = {};
    const { propagationMap, sourceUris } = (0, exports.toPropagatedTargetMap)(ast, '', files);
    for (const relativeUri of sourceUris.values()) {
        const nodeModulesIndex = relativeUri.indexOf('node_modules');
        const relativeName = nodeModulesIndex > -1 ? relativeUri.slice(nodeModulesIndex) : relativeUri;
        const filesMatchingRelativePath = files.filter((f) => {
            const fullName = (0, url_1.fileURLToPath)(f.uri);
            return !(nodeModulesIndex === -1 && fullName.includes('node_modules')) && fullName.endsWith(relativeName);
        });
        // required file has shortest uri
        const sourceFile = filesMatchingRelativePath.sort((a, b) => a.uri.length - b.uri.length)[0];
        if (!sourceFile) {
            continue;
        }
        const sourceTargets = sourceFile.content.targets;
        const ghostTargets = [];
        for (const target of sourceTargets) {
            const propagatedTargets = propagationMap[target.name] ?? {};
            for (const propagatedTargetName of Object.keys(propagatedTargets)) {
                const ghostTarget = Object.assign({}, target);
                ghostTarget.name = propagatedTargetName;
                ghostTargets.push(ghostTarget);
            }
        }
        ghostFiles[sourceFile.uri] = Object.assign({}, sourceFile.content);
        ghostFiles[sourceFile.uri].targets = ghostTargets;
    }
    const result = files
        .filter((file) => !!ghostFiles[file.uri])
        .map((file) => ({
        uri: odata_annotation_core_1.GHOST_FILENAME_PREFIX + file.uri,
        content: ghostFiles[file.uri],
        serviceName: 'default'
    }));
    return result;
}
exports.buildGhostFiles = buildGhostFiles;
//# sourceMappingURL=ghostFiles.js.map