"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStartLineColFromLocation = exports.getTextForLocationRange = exports.locationToRange = void 0;
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
function locationToRange(location) {
    let { line, col, endLine, endCol } = location || {};
    line = line || 1;
    col = col || 1;
    endLine = endLine || line || 1;
    endCol = endCol || col || 1;
    return odata_annotation_core_types_1.Range.create(line - 1, col - 1, endLine - 1, endCol - 1);
}
exports.locationToRange = locationToRange;
const newLineCharacter = '\n';
/**
 * Get text for range covered in the provided XsnLocation
 * @param xsnLocation
 * @param content
 */
const getTextForLocationRange = (xsnLocation, contentLines) => {
    // return text from location start to location end
    if (!xsnLocation || !xsnLocation.col || !xsnLocation.line || !xsnLocation.endCol) {
        return '';
    }
    if (xsnLocation.line > xsnLocation.endLine) {
        return '';
    }
    if (!xsnLocation.endLine || xsnLocation.line === xsnLocation.endLine) {
        const line = contentLines[xsnLocation.line - 1];
        if (line.length < xsnLocation.endCol) {
            // workaround for issue when compiler does not update end line properly
            return getSubstringUsingColumnAsOffset(xsnLocation, line, contentLines);
        }
        return line.substring(xsnLocation.col - 1, xsnLocation.endCol - 1);
    }
    else {
        let result = contentLines[xsnLocation.line - 1].substring(xsnLocation.col - 1) + '\n';
        for (let i = xsnLocation.line + 1; i < xsnLocation.endLine; i++) {
            result += contentLines[i - 1] + '\n';
        }
        result += contentLines[xsnLocation.endLine - 1].substring(0, xsnLocation.endCol - 1);
        return result;
    }
};
exports.getTextForLocationRange = getTextForLocationRange;
/**
 * Performs workaround where end column is used as an offset from the start position and end line is ignored.
 * @param xsnLocation Location with incorrect end position
 * @param line
 * @param contentLines
 */
function getSubstringUsingColumnAsOffset(xsnLocation, line, contentLines) {
    let result = line.substring(xsnLocation.col - 1, xsnLocation.endCol - 1);
    const totalLength = xsnLocation.endCol - xsnLocation.col;
    let lineOffset = 1;
    while (result.length < totalLength) {
        const currentLine = contentLines[xsnLocation.line - 1 + lineOffset];
        result += newLineCharacter;
        if (currentLine) {
            const remainingLength = totalLength - result.length;
            if (remainingLength < currentLine.length) {
                result += currentLine.substring(0, remainingLength);
            }
            else {
                result += currentLine.substring(0);
            }
        }
        lineOffset++;
    }
    return result;
}
/**
 * Get start line and column from location
 * - supports cds compiler location v1 and v2
 * - needed for finding antr token
 *
 * @param location
 */
const getStartLineColFromLocation = (location) => {
    const line = location?.line || 0;
    const col = location?.col ? location.col - 1 : -1;
    return { line, col };
};
exports.getStartLineColFromLocation = getStartLineColFromLocation;
//# sourceMappingURL=rangeConverters.js.map