"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCdsCompilerFacade = void 0;
const blitzIndex_1 = require("./blitzIndex");
const ghostFiles_1 = require("./transform/ghostFiles");
const cds_1 = require("./cds");
const url_1 = require("url");
const metadata_1 = require("./metadata");
const cdsDocument_1 = require("./cdsDocument");
const fileSequence_1 = require("./fileSequence");
const compilerMessages_1 = require("./compilerMessages");
const cdsSource_1 = require("./cdsSource");
const edmxNameConverter_1 = require("./metadata/edmxNameConverter");
/**
 * Creates a facade that calls to undocumented functionalities of @sap/cds-compiler module.
 *
 * @param XsnCompileModel
 * @returns
 */
function createCdsCompilerFacade(compileModel) {
    let blitzIndex;
    const nameConverter = new edmxNameConverter_1.EdmxNameConverter(compileModel);
    return {
        get blitzIndex() {
            if (!blitzIndex) {
                blitzIndex = (0, blitzIndex_1.createIndex)(compileModel);
            }
            return blitzIndex;
        },
        getTokensForUri(uri) {
            const source = (0, cdsSource_1.getSourceByUri)((0, url_1.pathToFileURL)(uri).toString(), compileModel);
            const tokens = [];
            if (source?.tokenStream?.tokens) {
                tokens.push(...source?.tokenStream?.tokens);
            }
            return tokens;
        },
        getCdsDocument(uri) {
            return (0, cdsDocument_1.getCdsDocument)(uri, compileModel);
        },
        getMetadata(serviceName) {
            return (0, metadata_1.generateMetadata)(compileModel, this, serviceName);
        },
        getGhostFiles(files) {
            return (0, ghostFiles_1.buildGhostFiles)(compileModel, files);
        },
        getCompilerErrors(projectRoot) {
            return (0, compilerMessages_1.getCompilerErrorMessages)(projectRoot, compileModel);
        },
        getUriMap() {
            return (0, cds_1.getFileUriMap)(compileModel);
        },
        getFileSequence() {
            return (0, fileSequence_1.getFileSequence)(compileModel);
        },
        getPropagatedTargetMap(serviceName, files) {
            return (0, ghostFiles_1.toPropagatedTargetMap)(compileModel, serviceName, files);
        },
        getFileName(serviceName) {
            return compileModel.definitions[serviceName]?.location?.file;
        },
        getNamespaceAndReference(fileUri) {
            const source = (0, cdsSource_1.getSourceByUri)(fileUri, compileModel);
            const converter = new metadata_1.Converter(compileModel.compiler, this);
            const references = [];
            let namespace;
            if (source) {
                references.push(...converter.convertUsingsToNamespaces(source.usings, source.dependencies));
                if (source.namespace) {
                    namespace = converter.convertNamespaceToNamespaces(source.namespace);
                }
            }
            return { references, namespace };
        },
        getAllSourceUris() {
            return Object.keys(compileModel?.sources) || [];
        },
        getServiceKind(serviceName) {
            return compileModel?.definitions[serviceName]?.kind;
        },
        collectMetadataForAbsolutePath(cdsPath, cdsKind, metadataCollector) {
            return (0, metadata_1.collectMetadataForAbsolutePath)(cdsPath, cdsKind, metadataCollector, compileModel);
        },
        collectMetadataForRelativePath(relativePath, baseKey, serviceName, metadataCollector) {
            (0, metadata_1.collectMetadataForRelativePath)(relativePath, baseKey, serviceName, metadataCollector, compileModel);
        },
        convertNameToEdmx(name) {
            return nameConverter.convertNameToEdmx(name);
        },
        convertNameFromEdmx(name) {
            return nameConverter.convertNameFromEdmx(name);
        }
    };
}
exports.createCdsCompilerFacade = createCdsCompilerFacade;
//# sourceMappingURL=facade.js.map