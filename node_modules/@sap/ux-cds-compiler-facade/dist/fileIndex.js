"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFileIndexFromSource = void 0;
const url_1 = require("url");
const transform_1 = require("./transform");
const annotationAssignmentToken_1 = require("./annotationAssignmentToken");
const genericDefinition_1 = require("./genericDefinition");
const identifierToken_1 = require("./identifierToken");
const utils_1 = require("./utils");
const tokenStream_1 = require("./tokenStream");
const getDependencies = (source) => {
    const directDependentUris = [];
    const dependencies = source.dependencies ?? [];
    for (const dependency of dependencies) {
        if (dependency.realname) {
            const dependencyUri = (0, url_1.pathToFileURL)(dependency.realname).toString();
            directDependentUris.push(dependencyUri);
        }
    }
    return directDependentUris;
};
const processElement = (artifact, collector, sourceUri, source, lines, compiler) => {
    const elements = [];
    Object.keys(artifact.elements || artifact.columns || {}).forEach((name) => {
        const el = artifact.elements || artifact.columns;
        if (el?.[name]) {
            elements.push(el[name]);
        }
    });
    for (const element of elements) {
        const buildElementName = (artifact) => {
            const namedObj = (0, utils_1.getNameObj)(artifact, compiler);
            return [namedObj.absolute, namedObj.element].join('.');
        };
        processArtifact(element, collector, sourceUri, source, lines, compiler, buildElementName);
    }
};
const processBoundActionFun = (artifact, collector, sourceUri, source, lines, compiler) => {
    const actions = [];
    Object.keys(artifact.actions || {}).forEach((name) => {
        if (artifact.actions?.[name]) {
            actions.push(artifact.actions[name]);
        }
    });
    for (const action of actions) {
        const buildActionName = (artifact) => {
            const namedObj = (0, utils_1.getNameObj)(artifact, compiler);
            return [namedObj.absolute, namedObj.action].join('.');
        };
        processArtifact(action, collector, sourceUri, source, lines, compiler, buildActionName);
        //  parameter of bound actions functions
        const params = [];
        Object.keys(action.params || {}).forEach((name) => {
            if (action.params?.[name]) {
                params.push(action.params[name]);
            }
        });
        for (const param of params) {
            const buildParamName = (artifact) => {
                const namedObj = (0, utils_1.getNameObj)(artifact, compiler);
                return [namedObj.absolute, namedObj.action, namedObj.param].join('.');
            };
            processArtifact(param, collector, sourceUri, source, lines, compiler, buildParamName);
        }
    }
};
const processBoundActionFunParam = (artifact, collector, sourceUri, source, lines, compiler) => {
    const params = [];
    Object.keys(artifact.params || {}).forEach((name) => {
        if (artifact.params?.[name]) {
            params.push(artifact.params[name]);
        }
    });
    for (const param of params) {
        const buildParamName = (artifact) => {
            const namedObj = (0, utils_1.getNameObj)(artifact, compiler);
            return [namedObj.absolute, namedObj.param].join('.');
        };
        processArtifact(param, collector, sourceUri, source, lines, compiler, buildParamName);
    }
};
function createFileIndexFromSource(sourceUri, source, compiler) {
    const directDependentUris = [];
    const annotationAssignments = new Map();
    const collector = {
        idTokens: [],
        annotationAssignments
    };
    directDependentUris.push(...getDependencies(source));
    if (!source.tokenStream) {
        return Object.freeze({
            directDependentUris,
            idTokens: collector.idTokens,
            compilerMessages: [],
            i18nTokens: [],
            stringTokens: [],
            tokens: [],
            get annotationAssignments() {
                return annotationAssignments.values();
            }
        });
    }
    const text = source.tokenStream.tokenSource?.inputStream.strdata ?? '';
    const artifacts = Object.keys(source.artifacts || {}).map((name) => source.artifacts[name]);
    artifacts.push(...getArtifactsRecursively(artifacts));
    if (source.extensions && source.extensions.length) {
        artifacts.push(...source.extensions);
    }
    // splitting text into lines is expensive for large files, we should only do it once per file
    const lines = text.split('\n');
    for (const artifact of artifacts) {
        // entities, (unbound) actions/functions
        const buildEntityName = (artifact) => {
            const namedObj = (0, utils_1.getNameObj)(artifact, compiler);
            return namedObj.absolute;
        };
        processArtifact(artifact, collector, sourceUri, source, lines, compiler, buildEntityName);
        // entity elements
        processElement(artifact, collector, sourceUri, source, lines, compiler);
        // bound actions/functions
        processBoundActionFun(artifact, collector, sourceUri, source, lines, compiler);
        //  parameters (of unbound actions functions)
        processBoundActionFunParam(artifact, collector, sourceUri, source, lines, compiler);
    }
    return Object.freeze({
        idTokens: collector.idTokens,
        directDependentUris,
        compilerMessages: [],
        i18nTokens: [],
        stringTokens: [],
        tokens: [],
        get annotationAssignments() {
            return annotationAssignments.values();
        }
    });
}
exports.createFileIndexFromSource = createFileIndexFromSource;
const isDifferentLocation = (location, source) => {
    if (location && source && location.file && source.location?.file) {
        return location.file !== source.location.file;
    }
    return false; // keep logic as it was before
};
const processAnnotationAssignment = (annotationAssignments, collector, sourceUri, source, lines, carrierName, carrierToken, buildName) => {
    // add annotation assignments
    for (const assignment of annotationAssignments) {
        if (isDifferentLocation(assignment.location, source)) {
            continue;
        }
        let annotationText = (0, transform_1.getTextForLocationRange)(assignment.location, lines);
        if (annotationText.length && annotationText[0] === '@') {
            // Sometimes assignment location includes @ symbol
            annotationText = annotationText.substr(1);
        }
        // starting with cds-compiler 3.0, 'name' property sometimes appears as property of 'value'
        const name = assignment.name ?? assignment['value'].name;
        const location = name.path?.slice(0, 1)[0].location;
        const { line, col } = (0, transform_1.getStartLineColFromLocation)(location);
        const assignmentNativeToken = (0, tokenStream_1.findTokenByPosition)(source.tokenStream.tokens, line, col);
        if (assignmentNativeToken) {
            const idToken = createIdentifierFromToken(sourceUri, assignmentNativeToken, undefined, buildName);
            collector.idTokens.push(idToken);
            const key = `${idToken.range.start.line}:${idToken.range.start.character}`;
            if (!collector.annotationAssignments.has(key)) {
                const annotationToken = new annotationAssignmentToken_1.AnnotationAssignmentTokenImpl(sourceUri, idToken.tokenIndex, annotationText, idToken.line, idToken.character, carrierName, carrierToken);
                collector.annotationAssignments.set(key, annotationToken);
            }
        }
    }
};
function processArtifact(artifact, collector, sourceUri, source, lines, compiler, buildName) {
    const annotationAssignments = artifact.$annotations;
    if (isDifferentLocation(artifact.location, source)) {
        return;
    }
    if (annotationAssignments && annotationAssignments.length) {
        // build tokens
        const locatable = artifact.name.path ? artifact.name.path.slice(-1)[0] : artifact.name;
        // find line/col for location
        const { line, col } = (0, transform_1.getStartLineColFromLocation)(locatable.location);
        const carrierNativeToken = (0, tokenStream_1.findTokenByPosition)(source.tokenStream.tokens, line, col);
        let carrierToken;
        if (carrierNativeToken) {
            carrierToken = createIdentifierFromToken(sourceUri, carrierNativeToken, artifact, buildName);
            collector.idTokens.push(carrierToken);
        }
        // add annotation assignments
        const carrierName = getCarrierName(artifact?.name?._artifact ?? artifact, compiler);
        processAnnotationAssignment(annotationAssignments, collector, sourceUri, source, lines, carrierName, carrierToken, buildName);
    }
}
function getArtifactsRecursively(artifacts) {
    const newArtifacts = [];
    for (const artifact of artifacts) {
        Object.keys(artifact.artifacts || {}).forEach((name) => {
            if (artifact.artifacts?.[name]) {
                newArtifacts.push(artifact.artifacts[name]);
            }
        });
        newArtifacts.push(...(artifact.extensions || []));
    }
    if (newArtifacts.length) {
        return [...newArtifacts, ...getArtifactsRecursively(newArtifacts)];
    }
    else {
        return newArtifacts;
    }
}
function getName(carrier, compiler) {
    if (carrier.kind === 'annotate') {
        return carrier.name?._artifact?.name || carrier.name;
    }
    return (0, utils_1.getNameObj)(carrier, compiler);
}
function getCarrierName(carrier, compiler) {
    let namedObj = getName(carrier, compiler);
    const segments = [];
    if (!namedObj?.absolute) {
        namedObj = (0, utils_1.getNameObj)(carrier, compiler);
    }
    segments.push(namedObj.absolute);
    if (namedObj.element) {
        segments.push(namedObj.element);
    }
    if (namedObj.action) {
        segments.push(namedObj.action);
    }
    if (namedObj.param) {
        segments.push(namedObj.param);
    }
    return segments.join('.');
}
function createIdentifierFromToken(uri, { tokenIndex, text, line, column }, artifact, buildName) {
    const carrierArtifact = artifact?.name?._artifact ?? artifact;
    const definition = artifact?.name && carrierArtifact
        ? new genericDefinition_1.GenericDefinitionImpl(buildName(carrierArtifact), carrierArtifact.kind)
        : undefined;
    return new identifierToken_1.IdentifierTokenImpl(uri, tokenIndex, text, line - 1, column, definition);
}
//# sourceMappingURL=fileIndex.js.map