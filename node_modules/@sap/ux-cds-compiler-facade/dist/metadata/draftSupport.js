"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDraftNodesForService = void 0;
const utils_1 = require("../utils");
const utils_2 = require("./utils");
const types_1 = require("./types");
const ODATA_DRAFT_ENABLED = '@odata.draft.enabled';
function collectDraftNodes(entity, compileModel, draftNodes, converter, asRoot) {
    if (['view', 'entity'].includes(entity.kind)) {
        const namedObj = (0, utils_1.getNameObj)(entity, compileModel?.compiler);
        const entityName = converter.convertNameToEdmx(namedObj.absolute) ?? '';
        const draftEnabled = isDraftEnabled(entity, entityName, !!asRoot);
        if (draftEnabled) {
            draftNodes.add(entityName);
            // recursively collect draft nodes for compositions
            Object.keys(entity?.elements || {}).forEach((elementName) => {
                const element = entity?.elements?.[elementName];
                const result = (0, utils_2.getAssociation)(element, compileModel?.compiler);
                if (result && result.isComposition && compileModel?.definitions[result.target]) {
                    collectDraftNodes(compileModel.definitions[result.target], compileModel, draftNodes, converter);
                }
            });
        }
    }
}
function isDraftEnabled(entity, entityName, asRoot) {
    let draftEnabled = false;
    if (asRoot) {
        draftEnabled = entity[ODATA_DRAFT_ENABLED] && entity[ODATA_DRAFT_ENABLED].val !== false;
    }
    else {
        if (entityName.endsWith('_texts')) {
            // generated text node - draft enablement requires "@fiori.draft.enabled" to be annotated
            // if present, CDS compiler generates key 'ID_texts' which is only generated when draft enabled
            // --> reuse compiler logic and check for key 'ID_texts' being present
            draftEnabled =
                Object.keys(entity.elements || {}).findIndex((name) => name === 'ID_texts' && entity?.elements?.[name].key?.val) >= 0;
        }
        else {
            draftEnabled = !entity[ODATA_DRAFT_ENABLED] || entity[ODATA_DRAFT_ENABLED].val !== false;
        }
    }
    return draftEnabled;
}
function getDraftNodesForService(serviceName, converter, compileModel) {
    const draftNodes = new Set();
    Object.keys(compileModel.definitions || {})
        .filter((name) => {
        const serviceArtifact = compileModel.definitions[name]._service;
        const namedObj = serviceArtifact ? (0, utils_1.getNameObj)(serviceArtifact, compileModel.compiler) : undefined;
        return namedObj?.absolute === serviceName && !name.startsWith(types_1.ENTITY_PREFIX_LOCALIZED);
    })
        .forEach((name) => {
        const draftRootEntity = compileModel.definitions[name];
        if (draftRootEntity) {
            collectDraftNodes(draftRootEntity, compileModel, draftNodes, converter, true);
        }
    });
    return draftNodes;
}
exports.getDraftNodesForService = getDraftNodesForService;
//# sourceMappingURL=draftSupport.js.map