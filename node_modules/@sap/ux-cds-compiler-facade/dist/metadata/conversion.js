"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = void 0;
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const transform_1 = require("../transform");
const utils_1 = require("../utils");
const types_1 = require("./types");
const utils_2 = require("./utils");
const ODATA_TYPE = '@odata.Type';
const ODATA_SINGLETON = '@odata.singleton';
const CORE_MEDIA_TYPE = '@Core.MediaType';
const BINDING_PARAMETER_SINGLE = '@cds.odata.bindingparameter.name';
const BINDING_PARAMETER_MULTIPLE = '@cds.odata.bindingparameter.collection';
const edmBinary = 'Edm.Binary';
const edmString = 'Edm.String';
const edmDecimal = 'Edm.Decimal';
const typeMap = {
    // artificial types representing associations
    'cds.Association': '',
    'cds.Composition': '',
    // taken from https://cap.cloud.sap/docs/cds/cdl
    'cds.Binary': edmBinary,
    'cds.Boolean': 'Edm.Boolean',
    'cds.Date': 'Edm.Date',
    'cds.DateTime': 'Edm.DateTimeOffset',
    'cds.Decimal': edmDecimal,
    'cds.DecimalFloat': edmDecimal,
    'cds.Double': 'Edm.Double',
    'cds.Integer': 'Edm.Int32',
    'cds.Integer64': 'Edm.Int64',
    'cds.Int64': 'Edm.Int64',
    'cds.Int32': 'Edm.Int32',
    'cds.Int16': 'Edm.Int16',
    'cds.UInt8': 'Edm.Byte',
    'cds.LargeBinary': edmBinary,
    'cds.LargeString': edmString,
    'cds.String': edmString,
    'cds.Time': 'Edm.TimeOfDay',
    'cds.Timestamp': 'Edm.DateTimeOffset',
    'cds.UUID': 'Edm.Guid',
    // taken from 'cds-compiler/lib/edm/edmUtils.js mapCdsToEdmType()'
    'cds.hana.BINARY': edmBinary,
    'cds.hana.CHAR': edmString,
    'cds.hana.CLOB': edmString,
    'cds.hana.NCHAR': edmString,
    'cds.hana.REAL': 'Edm.Single',
    'cds.hana.SMALLDECIMAL': edmDecimal,
    'cds.hana.SMALLINT': 'Edm.Int16',
    'cds.hana.ST_GEOMETRY': 'Edm.Geometry',
    'cds.hana.ST_POINT': 'Edm.GeometryPoint',
    'cds.hana.TINYINT': 'Edm.Byte',
    'cds.hana.VARCHAR': edmString,
    // misc
    'cds.hana.Object': edmBinary
};
// OData conform target kinds for CDS kinds
const targetKindsCds = {
    service: ["EntityContainer" /* Edm.EntityContainer */, "Schema" /* Edm.Schema */],
    entitySet: ["EntitySet" /* Edm.EntitySet */],
    entity: ["EntityType" /* Edm.EntityType */, "EntitySet" /* Edm.EntitySet */],
    view: ["EntityType" /* Edm.EntityType */, "EntitySet" /* Edm.EntitySet */],
    aspect: ["ComplexType" /* Edm.ComplexType */, "EntityType" /* Edm.EntityType */, "EntitySet" /* Edm.EntitySet */],
    element: ["Property" /* Edm.Property */],
    action: ["Action" /* Edm.Action */, "ActionImport" /* Edm.ActionImport */],
    function: ["Function" /* Edm.Function */, "FunctionImport" /* Edm.FunctionImport */],
    actionImport: ["Action" /* Edm.Action */],
    functionImport: ["FunctionImport" /* Edm.FunctionImport */],
    param: ["Parameter" /* Edm.Parameter */],
    type: ["TypeDefinition" /* Edm.TypeDefinition */, "Property" /* Edm.Property */, "Parameter" /* Edm.Parameter */]
};
const targetKindsMapCds = new Map(Object.entries(targetKindsCds));
class Converter {
    constructor(compiler, facade) {
        this.facade = facade;
        this.convertArtifact = (artifact) => {
            let result;
            if (artifact?.kind === 'service') {
                // build up node for service representing EDMX entity container
                const entityContainerNodeName = this.getNameObj(artifact).absolute + '.EntityContainer';
                const entityContainerNode = this.buildNode(artifact.kind, entityContainerNodeName, '', this.getOrigin(artifact));
                entityContainerNode.content = [];
                result = entityContainerNode;
            }
            else if (artifact?.kind === 'entity' || artifact?.kind === 'view') {
                // build up node for entity
                const entity = artifact;
                const keys = this.getElementName(entity);
                const entityName = this.convertNameToEdmx(this.getNameObj(artifact).absolute) ?? '';
                const entityNode = this.buildNode('entity', entityName, '', this.getOrigin(entity));
                entityNode.isEntityType = true;
                entityNode.isCollectionValued = true;
                entityNode.content = [];
                if (keys.length) {
                    keys.sort();
                    entityNode.keys = keys;
                }
                result = entityNode;
            }
            else if (artifact?.kind === 'action' || artifact?.kind === 'function') {
                // build node for unbound action or function (i.e. outside entity)
                const actionOrFunction = artifact;
                const actionNodeName = this.getNameObj(actionOrFunction).absolute + this.getActionNodeSignature(actionOrFunction);
                const actionNode = this.buildNode(actionOrFunction.kind, actionNodeName, '', this.getOrigin(actionOrFunction));
                actionNode.content = [];
                result = actionNode;
            }
            else if (artifact?.kind === 'type' || artifact?.kind === 'aspect') {
                // build node for type (also CDS 'aspect', which are artifacts with kind 'type' but have elements)
                const type = artifact;
                const kind = artifact?.elements ? 'aspect' : 'type';
                const typeNode = this.buildNode(kind, this.getNameObj(type).absolute, '', artifact.builtin ? undefined : this.getOrigin(type), this.getPrimitiveType(artifact));
                if (kind === 'aspect') {
                    typeNode.isComplexType = true;
                }
                typeNode.content = [];
                result = typeNode;
            }
            if (result) {
                result.targetKinds = this.getEdmTargetKinds(result);
            }
            return result;
        };
        this.convertElement = (elementName, parentPath, element) => {
            // build up node for element
            const elements = [];
            if (element) {
                const elementNode = this.buildNode(element.kind, elementName, parentPath, this.getOrigin(element), this.getPrimitiveType(element));
                const association = (0, utils_2.getAssociation)(element, this.compiler);
                if (association) {
                    if (elementName === types_1.ASSOCIATION_NAME_LOCALIZED) {
                        return []; // ignore internal associations for localized text
                    }
                    elementNode.structuredType = this.convertNameToEdmx(association.target);
                    elementNode.isCollectionValued = association.isToMany;
                    elementNode.isEntityType = true;
                }
                const typeArtifact = element.type?._artifact || element.items?.type?._artifact || element._effectiveType;
                if (element.items || typeArtifact?.items) {
                    elementNode.isCollectionValued = true;
                }
                elementNode.targetKinds = this.getEdmTargetKinds(elementNode);
                elements.push(...this.collectElementsFromStructuredType(typeArtifact, elementNode, elementName, parentPath));
                elements.push(elementNode);
                elements.push(...this.getAssociationKeyFieldElements(element, elementName, parentPath));
            }
            return elements;
        };
        this.convertBoundAction = (entityName, actionName, action) => {
            const boundActionName = this.getNamespace(entityName) + '.' + actionName + this.getActionNodeSignature(action, entityName);
            const actionNode = this.buildNode(action.kind, boundActionName, undefined, this.getOrigin(action));
            actionNode.targetKinds = this.getEdmTargetKinds(actionNode);
            return actionNode;
        };
        this.convertParameter = (paramName, parentPath, parameter) => {
            let paramNode;
            if (parameter) {
                paramNode = this.buildNode(parameter.kind, paramName, parentPath, this.getOrigin(parameter), this.getPrimitiveType(parameter));
                this.setStructuredType(paramNode, parameter);
                if (parameter.items) {
                    paramNode.isCollectionValued = true;
                }
            }
            paramNode.targetKinds = this.getEdmTargetKinds(paramNode);
            return paramNode;
        };
        this.convertBindingParameter = (action, bindingEntity, parentPath) => {
            const getNameFromAnnotation = (action, term) => {
                const value = action?.[term]?.val;
                return value && typeof value === 'string' ? value : undefined;
            };
            let bindingParamName = Object.keys(action?.params || {}).find((param) => {
                const paramXsn = action?.params?.[param];
                const path = (paramXsn?.items || paramXsn)?.type?.path;
                return path?.length === 1 && path[0]?.id === types_1.TYPE_NAME_OF_BINDING_PARAMETER;
            });
            const bindingParameter = bindingParamName ? action?.params?.[bindingParamName] : undefined;
            const bindingParamOrigin = bindingParameter ? this.getOrigin(bindingParameter) : undefined;
            if (!bindingParamName) {
                bindingParamName = getNameFromAnnotation(action, BINDING_PARAMETER_SINGLE);
            }
            if (!bindingParamName) {
                bindingParamName = getNameFromAnnotation(action, BINDING_PARAMETER_MULTIPLE);
            }
            bindingParamName = bindingParamName || 'in';
            let origin;
            if (action) {
                origin = this.getOrigin(action);
                origin.name += '.' + bindingParamName;
                if (origin.location && bindingParamOrigin?.location) {
                    origin.location.range = bindingParamOrigin.location.range;
                }
            }
            const bindingParamNode = this.buildNode('param', bindingParamName, parentPath, origin);
            bindingParamNode.isAnnotatable = false;
            bindingParamNode.isCollectionValued = !!(action?.params?.[bindingParamName]?.items || action?.[BINDING_PARAMETER_MULTIPLE]?.val);
            bindingParamNode.isEntityType = true;
            const namedObj = this.getNameObj(bindingEntity);
            bindingParamNode.structuredType = this.convertNameToEdmx(namedObj.absolute);
            bindingParamNode.targetKinds = this.getEdmTargetKinds(bindingParamNode);
            return bindingParamNode;
        };
        this.convertReturnParameter = (action, parentPath) => {
            const returnParam = action?.returns;
            let origin;
            if (action) {
                origin = this.getOrigin(action);
                origin.name += '.' + types_1.RETURN_PARAM_NAME;
            }
            const returnParamNode = this.buildNode('param', types_1.RETURN_PARAM_NAME, parentPath, origin, this.getPrimitiveType(returnParam));
            this.setStructuredType(returnParamNode, returnParam);
            if (returnParam?.items) {
                returnParamNode.isCollectionValued = true;
            }
            returnParamNode.targetKinds = this.getEdmTargetKinds(returnParamNode);
            return returnParamNode;
        };
        this.convertDraftPropertyNode = (xsnObject, propName, parentPath) => {
            const origin = this.getOrigin(xsnObject);
            origin.name += '.' + propName;
            const draftPropNode = this.buildNode('element', propName, parentPath, origin, 'Edm.Boolean');
            draftPropNode.targetKinds = this.getEdmTargetKinds(draftPropNode);
            return draftPropNode;
        };
        this.convertEntitySetNode = (entitySetName, parentPath, entity) => {
            const origin = entity ? this.getOrigin(entity) : undefined;
            const entitySetNode = this.buildNode('entitySet', entitySetName, parentPath, origin);
            const isSingleton = entity?.[ODATA_SINGLETON] && entity?.[ODATA_SINGLETON].val !== false;
            entitySetNode.isEntityType = true;
            entitySetNode.isCollectionValued = !isSingleton;
            const namedObj = this.getNameObj(entity);
            entitySetNode.structuredType = this.convertNameToEdmx(namedObj.absolute);
            entitySetNode.targetKinds = this.getEdmTargetKinds(entitySetNode);
            return entitySetNode;
        };
        this.convertActionFunctionImportNode = (actionFunctionName, parentPath, actionOrFunctionFqName, actionOrFunction) => {
            const kind = actionOrFunction.kind === 'action' ? 'actionImport' : 'functionImport';
            const actionFunctionImportNode = this.buildNode(kind, actionFunctionName, parentPath, this.getOrigin(actionOrFunction));
            actionFunctionImportNode.structuredType = actionOrFunctionFqName;
            actionFunctionImportNode.targetKinds = this.getEdmTargetKinds(actionFunctionImportNode);
            return actionFunctionImportNode;
        };
        this.compiler = compiler;
    }
    convertNamespaceToNamespaces(namespace) {
        const paths = [];
        (namespace.name?.path || namespace.path || []).forEach((path) => {
            paths.push(path.id);
        });
        const ns = paths.join('.');
        return {
            type: 'namespace',
            name: ns
        };
    }
    convertUsingsToNamespaces(usings, dependencies) {
        const namespaces = [];
        (dependencies || []).forEach((dependency) => {
            const using = (0, transform_1.findUsing)(usings, dependency);
            if (using) {
                // build namespace from using -fileUri should be absolute (also for referenced node packages)
                const fileUri = using.fileDep?.realname || using.fileDep?.val;
                const fileUriRange = using.fileDep?.location ? (0, transform_1.locationToRange)(using.fileDep?.location) : undefined;
                if (!using.usings) {
                    namespaces.push(this.convertUsingToNamespace(using, fileUri, fileUriRange));
                }
                else {
                    (using.usings || []).forEach((embeddedUsing) => namespaces.push(this.convertUsingToNamespace(embeddedUsing, fileUri, fileUriRange)));
                }
            }
            else if (dependency.realname) {
                // build namespace from dependency
                namespaces.push(this.convertDependencyToNamespace(dependency));
            }
        });
        return namespaces;
    }
    getNameObj(artifact) {
        return (0, utils_1.getNameObj)(artifact, this.compiler);
    }
    convertNameToEdmx(name) {
        return name && this.facade ? this.facade.convertNameToEdmx(name) : name;
    }
    convertNameFromEdmx(name) {
        return name && this.facade ? this.facade.convertNameFromEdmx(name) : name;
    }
    collectElementsFromStructuredType(typeArtifact, elementNode, elementName, parentPath) {
        const elements = [];
        if (typeArtifact &&
            ['type', 'element'].includes(typeArtifact.kind) &&
            typeArtifact.name &&
            typeArtifact['elements']) {
            // element has structured type
            elementNode.structuredType = this.getNameObj(typeArtifact).absolute;
            const typeArtifactEle = this.getNameObj(typeArtifact).element;
            if (typeArtifact.kind === 'element' && typeArtifactEle) {
                // anonymous complex types cannot be annotated as EDMX will not contain definition of ComplexType
                // (its properties will be visible as primitive properties named <complexPropName>_<elementName>)
                elementNode.isAnnotatable = elementNode.path !== `${elementNode.structuredType}/${typeArtifactEle}`;
                elementNode.structuredType += '.' + typeArtifactEle;
            }
            elementNode.isComplexType = true;
            if (!elementNode.isCollectionValued) {
                // for collections: ComplexType is generated into EDMX service (e.g. when defined on db layer "IncidentService.scp_cloud_MyMessageType")
                // else: complex type is resolved into generated properties (of primitive type)
                Object.keys(typeArtifact['elements']).forEach((typeElementName) => {
                    // build element nodes
                    const typeElement = typeArtifact['elements'][typeElementName];
                    elements.push(...this.convertElement(elementName + '_' + typeElementName, parentPath, typeElement));
                });
            }
        }
        return elements;
    }
    getPrimitiveType(typed) {
        function considerAnnotations(edmType) {
            if (typed?.[CORE_MEDIA_TYPE]) {
                // @UI.MediaType annotation makes cds-compiler convert the type to `Edm.Stream`
                return 'Edm.Stream';
            }
            else if (typeof typed?.[ODATA_TYPE]?.val === 'string') {
                // @odata.Type annotation explicitly sets the type
                return typed[ODATA_TYPE].val;
            }
            return edmType;
        }
        const effectiveType = typed?._effectiveType?.items?._effectiveType || typed?._effectiveType;
        if (effectiveType?.kind === 'type' && effectiveType.builtin && effectiveType.name) {
            return considerAnnotations(typeMap[this.getNameObj(effectiveType).absolute]);
        }
        let typeArtifact = effectiveType?.type?._artifact || effectiveType?.['_origin']?.type?._artifact;
        if (!typeArtifact && typed?.items) {
            typeArtifact = typed.items._effectiveType?.type?._artifact;
        }
        if (!typeArtifact?.builtin && typeArtifact?._effectiveType?.type?._artifact) {
            typeArtifact = typeArtifact?._effectiveType?.type?._artifact;
        }
        if (typeArtifact?.kind === 'type' && typeArtifact.builtin && typeArtifact.name) {
            return considerAnnotations(typeMap[this.getNameObj(typeArtifact).absolute]);
        }
        else {
            return '';
        }
    }
    setStructuredType(node, typed) {
        if (node.edmPrimitiveType) {
            return;
        }
        const path = (typed?.items || typed)?.type?.path || [];
        let artifact = typed?.type?._artifact || typed?._effectiveType?.type?._artifact;
        if (!artifact && typed?.items) {
            artifact = typed.items.type?._artifact || typed.items?._effectiveType?.type?._artifact;
        }
        if (path?.length === 1 && path[0]?.id === types_1.TYPE_NAME_OF_BINDING_PARAMETER) {
            node.structuredType = types_1.TYPE_NAME_OF_BINDING_PARAMETER;
            node.isEntityType = true;
        }
        else if (artifact?.name) {
            node.structuredType = this.convertNameToEdmx(this.getNameObj(artifact).absolute);
            const kind = artifact.kind;
            if (['entity', 'view'].includes(kind)) {
                node.isEntityType = true;
            }
            else if (['type'].includes(kind)) {
                node.isComplexType = true;
            }
        }
    }
    /**
     * Get OData target kinds for a metadata element.
     *
     * @param metadata element.
     * @returns OData target kinds.
     */
    getEdmTargetKinds(element) {
        if (!element) {
            return [];
        }
        const targetKinds = [];
        targetKinds.push(...(targetKindsMapCds.get(element.kind) ?? []));
        if (element.kind === 'element' && element.structuredType && element.isEntityType) {
            // CDS elements pointing to an entity type can be annotated like a EDMX navigation property
            targetKinds.unshift("NavigationProperty" /* Edm.NavigationProperty */);
        }
        if (targetKinds.includes("EntitySet" /* Edm.EntitySet */) || element.isCollectionValued) {
            targetKinds.push("Collection" /* Edm.Collection */);
        }
        return targetKinds;
    }
    buildNode(kind, name, parentPath, origin, edmPrimitiveType) {
        const node = {
            name,
            path: parentPath ? `${parentPath}/${name}` : name,
            content: [],
            kind: kind,
            isEntityType: false,
            isCollectionValued: false,
            isComplexType: false,
            isAnnotatable: true,
            targetKinds: []
        };
        if (origin) {
            // fileUri should be relative to project root, also for referenced node modules
            node.originalName = origin.name;
            node.location = origin.location;
            node.importUri = origin.importUri;
        }
        if (edmPrimitiveType) {
            node.edmPrimitiveType = edmPrimitiveType;
        }
        return node;
    }
    getNamespace(fullyQualifiedName) {
        const parts = fullyQualifiedName.split('.');
        parts.pop();
        return parts.join('.');
    }
    getOrigin(originated) {
        const definitionOrigin = this.getRecursiveOrigin(originated);
        const named = originated._origin && originated.kind !== 'entity' ? originated._origin : originated;
        let result;
        if (named) {
            const namedObj = this.getNameObj(named);
            result = {
                importUri: named.location.file,
                name: namedObj.absolute +
                    (namedObj.element ? '.' + namedObj.element : '') +
                    (namedObj.action ? '.' + namedObj.action : '') +
                    (namedObj.param ? '.' + namedObj.param : '')
            };
            const nameLocation = this.getNameObj(definitionOrigin)?.location || definitionOrigin.location;
            const range = (0, transform_1.locationToRange)(nameLocation);
            if (nameLocation && range) {
                result.location = odata_annotation_core_types_1.Location.create(this.adaptFilePath(nameLocation), range);
            }
        }
        return result;
    }
    getRecursiveOrigin(originated) {
        if (originated._origin && originated.kind !== 'entity') {
            // cds-compiler v2*
            return this.getRecursiveOrigin(originated._origin);
        }
        else {
            return originated;
        }
    }
    /**
     * Adapt file path for node module path
     *
     * Cut file path at first node_module
     * filePath "..\..\..\Users\my_user\AppData\Roaming\npm\node_modules\@sap\cds-dk\node_modules\@sap\cds\common.cds"
     *
     * @param location - generic location
     *
     * @returns filePath
     */
    adaptFilePath(location) {
        let file = location.file;
        const nodeModuleSegmentIndex = file.indexOf('node_modules');
        if (nodeModuleSegmentIndex > -1) {
            file = file.substring(nodeModuleSegmentIndex);
        }
        return file;
    }
    getStructuredType(typed) {
        let artifact = typed?.type?._artifact || typed?._effectiveType?.type?._artifact;
        if (!artifact && typed?.items) {
            artifact = typed.items.type?._artifact || typed.items._effectiveType?.type?._artifact;
        }
        let namedObj;
        if (artifact) {
            namedObj = this.getNameObj(artifact);
        }
        return artifact?.name && namedObj ? this.convertNameToEdmx(namedObj.absolute) ?? '' : '';
    }
    getActionNodeSignature(actionOrFunction, bindingEntityName) {
        if (actionOrFunction.kind === 'action') {
            if (bindingEntityName) {
                // bound action - add single binding parameter type
                return '(' + bindingEntityName + ')';
            }
            else {
                // unbound action - no overloads supported, just add ()
                return '()';
            }
        }
        else {
            const parameterTypes = this.getActionOrFunctionParams(actionOrFunction);
            if (bindingEntityName) {
                // bound function - add binding type first followed by all parameters
                const types = [bindingEntityName, ...parameterTypes];
                return '(' + types.join(',') + ')';
            }
            else {
                // unbound function - just add all parameter types
                return '(' + parameterTypes.join(',') + ')';
            }
        }
    }
    getKeyNamesAndTypes(foreignKeys) {
        const result = [];
        if (foreignKeys) {
            const keyNames = Object.keys(foreignKeys);
            for (const name of keyNames) {
                const key = foreignKeys[name];
                if (key.kind !== 'key') {
                    continue;
                }
                const embeddedForeignKeys = key.targetElement?._artifact?.foreignKeys;
                if (embeddedForeignKeys) {
                    const embeddedResult = this.getKeyNamesAndTypes(embeddedForeignKeys);
                    for (const { name: embeddedName, type } of embeddedResult) {
                        result.push({ name: `${name}_${embeddedName}`, type });
                    }
                }
                else {
                    result.push({ name, type: this.getPrimitiveType(key.targetElement?._artifact || key) });
                }
            }
        }
        return result;
    }
    getElementName(entity) {
        const keys = [];
        Object.keys(entity.elements || {}).forEach((elementName) => {
            const element = entity?.elements?.[elementName];
            if (element?.kind === 'element' && element.key && element.key.val && element.key.val === true) {
                keys.push(elementName);
            }
        });
        return keys;
    }
    getActionOrFunctionParams(actionOrFunction) {
        const parameterTypes = [];
        const params = sortBySequenceNumber(actionOrFunction.params);
        params.forEach((parName) => {
            // add type of parameter (primitive or complex; parameter sequence seems to be reflected in Object.keys()
            const parameter = actionOrFunction?.params?.[parName];
            let typeName = this.getPrimitiveType(parameter) || this.getStructuredType(parameter);
            if (parameter?.items) {
                typeName = `Collection(${typeName})`;
            }
            if (typeName) {
                parameterTypes.push(typeName);
            }
        });
        return parameterTypes;
    }
    getAssociationKeyFieldElements(element, elementName, parentPath) {
        const elements = [];
        // for associations: build up key fields
        const keyNamesAndTypes = this.getKeyNamesAndTypes(element.foreignKeys);
        for (const { name, type } of keyNamesAndTypes) {
            const node = this.buildNode(element.kind, [elementName, name].join('_'), parentPath, this.getOrigin(element), type);
            node.targetKinds = this.getEdmTargetKinds(node);
            elements.push(node);
        }
        return elements;
    }
    convertUsingToNamespace(using, fileUri, fileUriRange) {
        return {
            type: 'reference',
            alias: using.name.id,
            aliasRange: (0, transform_1.locationToRange)(using.name.location),
            name: (0, utils_1.getNameObj)(using, this.compiler).absolute,
            uri: fileUri,
            uriRange: fileUriRange
        };
    }
    convertDependencyToNamespace(dependency) {
        // pure 'dependency' has no name or alias (otherwise we rely on 'using')
        const reference = {
            type: 'reference',
            alias: '',
            name: '',
            uri: dependency.realname
        };
        if (dependency.location) {
            reference.uriRange = (0, transform_1.locationToRange)(dependency.location);
        }
        return reference;
    }
}
exports.Converter = Converter;
function sortBySequenceNumber(entries) {
    if (!entries || typeof entries !== 'object') {
        return [];
    }
    const keys = Object.keys(entries || {});
    if (keys.some((key) => !entries[key]?.$effectiveSeqNo)) {
        return keys; // not all entries have non initial sequence number -> no sorting
    }
    return keys.sort((k1, k2) => (entries[k1]?.$effectiveSeqNo || 0) - (entries[k2]?.$effectiveSeqNo || 0));
}
//# sourceMappingURL=conversion.js.map