"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdmxNameConverter = exports.convertNameToEdmxInternal = void 0;
const rootNodeKinds = ['namespace', 'service', 'context'];
/**
 * converts name to edmx name (converting '.text' to '_text')
 *  - reason: generated EDMX will contain name with '_text'
 * @param name - name to convert
 * @param compileModel - cds compiled model
 */
function convertNameToEdmxInternal(name, compileModel) {
    let result = name;
    const isRootElement = (artifact) => {
        return rootNodeKinds.includes(artifact.kind);
    };
    const pathSegments = name.split('/');
    let currentArtifactName = pathSegments.shift(); // only path base (root segment) is converted, the rest remains as it is
    let currentArtifact = compileModel.definitions[currentArtifactName];
    const subSegments = [];
    // traverse parent elements util top element representing namespace or service is reached
    // while looping all checked name's last segments are collected in subSegments array
    while (currentArtifact && !isRootElement(currentArtifact)) {
        const segments = currentArtifactName.split('.');
        const lastSegment = segments.pop();
        subSegments.unshift(lastSegment);
        currentArtifactName = segments.join('.');
        currentArtifact = compileModel.definitions[currentArtifactName];
        if (currentArtifactName === '') {
            // in some cases when there are errors in XSN model there can be a definition with name ''
            // which is not root element and would cause infinite loop
            return result;
        }
    }
    // if root element was found then concatenate its name with collected subsegments separated by edmx valid delimiter "_"
    // and append path tale segments
    if (currentArtifact) {
        result = currentArtifactName + (subSegments.length ? '.' + subSegments.join('_') : '');
        result = [result, ...pathSegments].join('/');
    }
    return result;
}
exports.convertNameToEdmxInternal = convertNameToEdmxInternal;
class EdmxNameConverter {
    constructor(compileModel) {
        this.compileModel = compileModel;
        this.edmxNamesMap = new Map();
        this.reverseNamesMap = new Map();
    }
    convertNameToEdmx(name) {
        // return cached converted value if exists
        const existingValue = this.edmxNamesMap.get(name);
        if (existingValue !== undefined) {
            return existingValue;
        }
        const result = convertNameToEdmxInternal(name, this.compileModel);
        this.edmxNamesMap.set(name, result);
        this.reverseNamesMap.set(result.toUpperCase(), name);
        return result;
    }
    convertNameFromEdmx(name) {
        return this.reverseNamesMap.get(name.toUpperCase());
    }
}
exports.EdmxNameConverter = EdmxNameConverter;
//# sourceMappingURL=edmxNameConverter.js.map