"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMetadata = void 0;
const types_1 = require("./types");
const utils_1 = require("./utils");
const draftSupport_1 = require("./draftSupport");
const conversion_1 = require("./conversion");
const generateMetadata = (compileModel, facade, serviceName) => {
    const converter = new conversion_1.Converter(compileModel.compiler, facade);
    const draftNodesMap = new Map();
    let artifacts = {};
    if (serviceName) {
        // if service name is provided, just return data for this service (check via '_service' link)
        if (compileModel.definitions[serviceName]) {
            artifacts[serviceName] = compileModel.definitions[serviceName];
            Object.keys(compileModel.definitions)
                .filter((key) => {
                const serviceArtifact = compileModel.definitions[key]._service;
                const namedObj = serviceArtifact ? converter.getNameObj(serviceArtifact) : undefined;
                return namedObj?.absolute === serviceName && !key.startsWith(types_1.ENTITY_PREFIX_LOCALIZED);
            })
                .forEach((key) => (artifacts[key] = compileModel.definitions[key]));
        }
        draftNodesMap.set(serviceName, (0, draftSupport_1.getDraftNodesForService)(serviceName, converter, compileModel));
    }
    else {
        artifacts = compileModel.definitions;
        // collect draft nodes for all services upfront (since order of artifact keys is unclear)
        Object.keys(artifacts)
            .filter((name) => artifacts[name].kind === 'service')
            .forEach((serviceName) => {
            draftNodesMap.set(serviceName, (0, draftSupport_1.getDraftNodesForService)(serviceName, converter, compileModel));
        });
    }
    const context = { metadataElementMap: new Map(), converter };
    Object.keys(artifacts)
        .filter((name) => !name.startsWith(types_1.ENTITY_PREFIX_LOCALIZED)) // ignore internal artifacts generated for for localized text
        .filter((name) => ['service', 'entity', 'view', 'action', 'function', 'aspect', 'type'].includes(artifacts[name]?.kind) &&
        !(artifacts[name].kind === 'type' && artifacts[name].builtin) // builtin types cannot be annotated
    )
        .forEach((name) => generateMetadataElementFromArtifacts(context, name, artifacts, draftNodesMap, compileModel));
    return context.metadataElementMap;
};
exports.generateMetadata = generateMetadata;
function generateMetadataElementFromArtifacts(context, name, artifacts, draftNodesMap, compileModel) {
    const { metadataElementMap, converter } = context;
    const topLevelArtifact = artifacts[name];
    const topLevelArtifactNode = converter.convertArtifact(topLevelArtifact);
    const topLevelArtifactName = topLevelArtifact.kind === 'service' ? name : topLevelArtifactNode.name;
    if (topLevelArtifact.kind === 'service') {
        // build entity sets, action imports, function imports
        Object.keys(artifacts || {})
            .filter((name) => {
            const serviceArtifact = artifacts[name]._service;
            const namedObj = serviceArtifact ? converter.getNameObj(serviceArtifact) : undefined;
            return (!name.startsWith(types_1.ENTITY_PREFIX_LOCALIZED) &&
                namedObj?.absolute === topLevelArtifactName &&
                ['entity', 'view', 'action', 'function'].includes(artifacts[name].kind));
        })
            .forEach((containerChildName) => {
            addEntityContainerChild(context, artifacts[containerChildName], topLevelArtifactNode, topLevelArtifactName);
        });
    }
    generateBoundActionFunctionMdElements(context, topLevelArtifact);
    generateEntityMdElements(context, topLevelArtifact, topLevelArtifactName, topLevelArtifactNode);
    // for entites in a service: when "@odata.draft.enabled": add special (boolean) element 'IsActiveEntity'
    if (['entity', 'view'].includes(topLevelArtifact.kind) &&
        draftNodesMap.get((0, utils_1.getServiceNameForEntity)(topLevelArtifact, compileModel))?.has(topLevelArtifactName)) {
        const isActiveEntityNode = converter.convertDraftPropertyNode(topLevelArtifact, types_1.IS_ACTIVE_ENTITY_ELEM_NAME, topLevelArtifactName);
        if (isActiveEntityNode) {
            topLevelArtifactNode.content.push(isActiveEntityNode);
            metadataElementMap.set(topLevelArtifactName + '/' + types_1.IS_ACTIVE_ENTITY_ELEM_NAME, {
                parentKey: topLevelArtifactName,
                node: isActiveEntityNode
            });
        }
        const hasActiveEntityNode = converter.convertDraftPropertyNode(topLevelArtifact, types_1.HAS_ACTIVE_ENTITY_ELEM_NAME, topLevelArtifactName);
        if (hasActiveEntityNode) {
            topLevelArtifactNode.content.push(hasActiveEntityNode);
            metadataElementMap.set(topLevelArtifactName + '/' + types_1.HAS_ACTIVE_ENTITY_ELEM_NAME, {
                parentKey: topLevelArtifactName,
                node: hasActiveEntityNode
            });
        }
    }
    // (unbound) action/function parameters
    generateUnBoundActionFunctionMdElements(context, topLevelArtifact, topLevelArtifactName, topLevelArtifactNode);
    metadataElementMap.set(topLevelArtifactName, { node: topLevelArtifactNode });
}
function addEntityContainerChild(context, containerChild, topLevelArtifactNode, topLevelArtifactName) {
    const { metadataElementMap, converter } = context;
    const containerChildFqName = context.converter.convertNameToEdmx(converter.getNameObj(containerChild).absolute) ?? '';
    // build name in container by removing service name from fully qualified name
    const nameInEntityContainer = containerChildFqName.slice(topLevelArtifactName.length + 1);
    let node;
    if (['entity', 'view'].includes(containerChild.kind)) {
        node = converter.convertEntitySetNode(nameInEntityContainer, topLevelArtifactNode.name, containerChild);
    }
    else {
        node = converter.convertActionFunctionImportNode(nameInEntityContainer, topLevelArtifactNode.name, containerChildFqName, containerChild);
    }
    topLevelArtifactNode.content.push(node);
    metadataElementMap.set(topLevelArtifactNode.name + '/' + nameInEntityContainer, {
        parentKey: topLevelArtifactNode.name,
        node: node
    });
}
function generateEntityMdElements(context, topLevelArtifact, topLevelArtifactName, topLevelArtifactNode) {
    // entity elements
    const { metadataElementMap, converter } = context;
    Object.keys(topLevelArtifact.elements || {}).forEach((elementName) => {
        const element = topLevelArtifact?.elements?.[elementName];
        const elementNodes = converter.convertElement(elementName, topLevelArtifactName, element);
        topLevelArtifactNode.content.push(...elementNodes);
        for (const elementNode of elementNodes) {
            metadataElementMap.set(topLevelArtifactName + '/' + elementNode.name, {
                parentKey: topLevelArtifactName,
                node: elementNode
            });
        }
    });
}
function generateBoundActionFunctionMdElements(context, topLevelArtifact) {
    // entity actions/functions (bound)
    const { metadataElementMap, converter } = context;
    Object.keys(topLevelArtifact.actions || {})
        .sort()
        .forEach((actionName) => {
        const action = topLevelArtifact?.actions?.[actionName];
        if (action && ['action', 'function'].includes(action.kind)) {
            // embedded action or function
            const actionNode = converter.convertBoundAction(converter.getNameObj(topLevelArtifact).absolute, actionName, action);
            const actionNodeName = actionNode.name;
            actionNode.content = [];
            // generate binding parameter (should go first)
            const bindingParamNode = converter.convertBindingParameter(action, topLevelArtifact, actionNodeName);
            if (bindingParamNode) {
                actionNode.content.push(bindingParamNode);
                metadataElementMap.set(actionNodeName + '/' + bindingParamNode.name, {
                    parentKey: actionNodeName,
                    node: bindingParamNode
                });
            }
            // parameters
            generateActionFunctionParams(context, action, actionNodeName);
            // return type
            generateActionFunctionReturns(context, action, actionNodeName, actionNode);
            // bound actions/functions don't have a parent node
            metadataElementMap.set(actionNodeName, { node: actionNode });
        }
    });
}
function generateActionFunctionParams(context, action, actionNodeName) {
    const { metadataElementMap, converter } = context;
    Object.keys(action.params || {}).forEach((paramName) => {
        const param = action?.params?.[paramName];
        if (param && ['param'].includes(param.kind)) {
            const paramNode = converter.convertParameter(paramName, actionNodeName, param);
            if (paramNode && paramNode.structuredType !== types_1.TYPE_NAME_OF_BINDING_PARAMETER) {
                metadataElementMap.set(actionNodeName + '/' + paramName, {
                    parentKey: actionNodeName,
                    node: paramNode
                });
            }
        }
    });
}
function generateActionFunctionReturns(context, action, actionNodeName, actionNode) {
    if (action.returns) {
        const { metadataElementMap, converter } = context;
        const returnParamNode = converter.convertReturnParameter(action, actionNodeName);
        if (returnParamNode) {
            actionNode.content.push(returnParamNode);
            metadataElementMap.set(actionNodeName + '/' + types_1.RETURN_PARAM_NAME, {
                parentKey: actionNodeName,
                node: returnParamNode
            });
        }
    }
}
function generateUnBoundActionFunctionMdElements(context, topLevelArtifact, topLevelArtifactName, topLevelArtifactNode) {
    const { metadataElementMap, converter } = context;
    Object.keys(topLevelArtifact.params || {})
        .sort()
        .forEach((paramName) => {
        const param = topLevelArtifact?.params?.[paramName];
        const paramNode = converter.convertParameter(paramName, topLevelArtifactName, param);
        if (paramNode) {
            topLevelArtifactNode.content.push(paramNode);
            metadataElementMap.set(topLevelArtifactName + '/' + paramName, {
                parentKey: topLevelArtifactName,
                node: paramNode
            });
        }
    });
    if (topLevelArtifact.returns) {
        const returnParamNode = converter.convertReturnParameter(topLevelArtifact, topLevelArtifactName);
        if (returnParamNode) {
            topLevelArtifactNode.content.push(returnParamNode);
            metadataElementMap.set(topLevelArtifactName + '/' + types_1.RETURN_PARAM_NAME, {
                parentKey: topLevelArtifactName,
                node: returnParamNode
            });
        }
    }
}
//# sourceMappingURL=generation.js.map