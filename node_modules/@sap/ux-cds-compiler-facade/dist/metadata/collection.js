"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectMetadataForRelativePath = exports.collectMetadataForAbsolutePath = void 0;
const utils_1 = require("../utils");
const types_1 = require("./types");
const utils_2 = require("./utils");
const conversion_1 = require("./conversion");
const draftSupport_1 = require("./draftSupport");
const SERVICE_NAME_PLACEHOLDER = '<ServiceName>';
/**
 * Collects metadata elements for absolute path (cds syntax), returns path in EDMX syntax
 *
 * @param cdsPath - path extracted from carrier e.g. AdminService.Books.title or AdminService.Books.addRating
 * @param cdsKind - cds kind, e.g. 'entity', 'element', 'action', 'function', 'param'
 * @param metadataCollector
 * @param compileModel
 * @returns path in EDMX format and key for corresponding entry in MetadataCollector
 */
function collectMetadataForAbsolutePath(cdsPath, cdsKind, metadataCollector, compileModel) {
    let edmxPath = '';
    const context = {
        compileModel,
        metadataCollector,
        converter: new conversion_1.Converter(compileModel.compiler, metadataCollector.facade)
    };
    const segments = cdsPath.split('.');
    // as metadata collector keys, segments representing action or function names have appended '()' (to avoid name clashes with element names)
    if (segments.length > 1 && ['action', 'function'].includes(cdsKind)) {
        segments[segments.length - 1] += '()';
    }
    else if (segments.length > 2 && cdsKind === 'param') {
        segments[segments.length - 2] += '()';
    }
    const { collectorEntry, key: collectorKey } = collectMdNodesForPath(context, segments);
    if (collectorEntry) {
        // build EDMX name
        edmxPath = collectorEntry.node.name;
        let currentKey = collectorEntry.parentKey;
        while (currentKey) {
            const entry = metadataCollector.metadataElementMap.get(currentKey);
            const separator = entry?.node.isComplexType && !entry?.node.isAnnotatable ? '_' : '/';
            edmxPath = entry?.node.name + separator + edmxPath;
            currentKey = entry?.parentKey;
        }
    }
    if (!edmxPath && cdsKind === 'element') {
        // workaround for unknown element (sometimes really named '$unknownElement')
        edmxPath = segments.slice(0, segments.length - 1).join('.') + '/' + segments[segments.length - 1];
    }
    return { edmxPath: edmxPath || cdsPath, collectorKey }; // also allow target names which are not found in metadata elements
}
exports.collectMetadataForAbsolutePath = collectMetadataForAbsolutePath;
/**
 * Collects metadata elements for relative path
 *
 * @param relativePath
 * @param baseCollectorKey - key for collector entry representing base for relative path
 * @param serviceName
 * @param metadataCollector
 */
function collectMetadataForRelativePath(relativePath, baseCollectorKey, serviceName, metadataCollector, compileModel) {
    const context = {
        compileModel,
        metadataCollector,
        converter: new conversion_1.Converter(compileModel.compiler, metadataCollector.facade)
    };
    if (relativePath.startsWith('/')) {
        // action/function(Import) name from UI.DataFieldForAction/Action e.g. "/SpecificationService.TransferToSpecification"
        if (relativePath.slice(1).indexOf('/') > 0 && relativePath.includes('EntityContainer')) {
            // name of actionImport or functionImport (only unbound actions allowed!) as children of entity container
            const [entityContainerName, actionFunctionName] = relativePath.slice(1).split('/');
            const segments = [
                entityContainerName
                    .split('.')
                    .filter((seg) => seg !== 'EntityContainer')
                    .join('.'),
                actionFunctionName
            ];
            collectMdNodesForPath(context, segments, 1);
        }
        else {
            // name of action/function
            collectActionFunction(context, relativePath, baseCollectorKey, serviceName);
        }
    }
    else {
        if (relativePath.includes(SERVICE_NAME_PLACEHOLDER)) {
            // special handling for path string expressions used in Common.ValueList annotations
            let collectorEntry = undefined;
            if (serviceName) {
                const pathSegments = relativePath.replace(SERVICE_NAME_PLACEHOLDER, serviceName).split('/');
                ({ collectorEntry } = collectMdNodesForPath(context, pathSegments, 1));
            }
            if (!collectorEntry) {
                // @Common.ValueList defined on base layer no service name is present ?
                collectCommonValueListOnDbLayer(context, baseCollectorKey, relativePath);
            }
        }
        else {
            // build segments for absolute path and collect metadata for it
            const baseSegments = baseCollectorKey.split(/[./]+/);
            const segments = [...baseSegments, ...relativePath.split('/')];
            collectMdNodesForPath(context, segments, baseSegments.length);
        }
    }
}
exports.collectMetadataForRelativePath = collectMetadataForRelativePath;
/**
 * Collect all metadata elements along segments of a path, return entry of metadata collector for path
 * if compileModel is provided, metadata elements will be collected
 * @param segments - mixture of name and path segments (i.e. [namespace, name, complexPropName, propName])
 *           - why? CDS LSP carrier names have '.' also as path segment separator
 *           - this introduces ambiguities - e.g. entity set "serviceName/entityTypeName" vs entity type "serviceName.entityTypeName"
 *           - to make sure entity set is collected, specify number of segments representing serviceName as baseSegmentCount
 * @param metadataCollector
 * @param baseSegmentCount - number of base segments (if segments were build by base path and relative path)
 */
function collectMdNodesForPath(context, segments, baseSegmentsCount) {
    const { facade, metadataElementMap } = context.metadataCollector;
    // try to resolve path based on metadata elements already in collector
    // the following names are tested in that order (initial baseSegmentsCount):
    //   "namespace.name.complexPropName.propName"
    //   "namespace.name.complexPropName/propName"
    //   "namespace.name/complexPropName/propName"
    //   "namespace/name/complexPropName/propName"
    // the following names are tested in that order (baseSegmentsCount = 2):
    //   "namespace.name/complexPropName/propName"
    //   "namespace/name/complexPropName/propName"
    // the following names are tested in that order (baseSegmentsCount = 1):
    //   "namespace/name/complexPropName/propName"
    let mdEntry = undefined;
    let mdElementName = '';
    for (let i = (baseSegmentsCount || segments.length) - 1; i >= 0 && !mdEntry; i--) {
        const nameSegments = segments.slice(0, i + 1);
        const propSegments = segments.slice(i + 1);
        mdElementName = nameSegments.join('.') + (propSegments.length ? '/' + propSegments.join('/') : '');
        mdEntry = metadataElementMap.get(mdElementName);
    }
    if (mdEntry || !facade) {
        return { collectorEntry: mdEntry, key: mdElementName };
    }
    // lookup in compileModel and add missing md elements to collector
    mdElementName = '';
    for (let i = (baseSegmentsCount || segments.length) - 1; i >= 0 && !mdEntry; i--) {
        const nameSegments = segments.slice(0, i + 1);
        const propSegments = segments.slice(i + 1);
        // find and collect top level artifact with most detailed name (search sequence is same as described above)
        const { topLevelMdElementName, topLevelArtifact } = collectTopLevelMdNode(context, nameSegments);
        if (!topLevelArtifact) {
            continue;
        }
        // recursively build child md nodes and collect them to metadata element map
        ({ mdElementName, mdEntry } = collectRelativeSegmentsMdNodes(context, propSegments, topLevelMdElementName, topLevelArtifact));
    }
    return { collectorEntry: mdEntry, key: mdElementName };
}
function collectTopLevelMdNode(context, nameSegments) {
    const { metadataCollector, compileModel, converter } = context;
    const { metadataElementMap } = metadataCollector;
    const topLevelMdElementNameAnyCase = nameSegments.join('.');
    let topLevelArtifactNameAnyCase = topLevelMdElementNameAnyCase.split('()').join('');
    topLevelArtifactNameAnyCase =
        context.converter.convertNameFromEdmx(topLevelArtifactNameAnyCase) ?? topLevelArtifactNameAnyCase;
    const topLevelArtifactName = getPropName(compileModel?.definitions, topLevelArtifactNameAnyCase);
    let topLevelMdElementName = (topLevelArtifactName || '')
        .split('.')
        .map((segment, index) => (nameSegments[index]?.endsWith('()') ? segment + '()' : segment))
        .join('.');
    const topLevelArtifact = topLevelArtifactName ? compileModel?.definitions[topLevelArtifactName] : undefined;
    topLevelMdElementName = context.converter.convertNameToEdmx(topLevelMdElementName);
    // if it doesn't exist: build md node for top level artifact and add it to the metadata element map
    if (topLevelArtifact && !metadataElementMap.has(topLevelMdElementName)) {
        const artifactNode = converter.convertArtifact(topLevelArtifact);
        if (artifactNode) {
            metadataElementMap.set(topLevelMdElementName, { node: artifactNode });
        }
    }
    return { topLevelMdElementName, topLevelArtifact };
}
function collectRelativeSegmentsMdNodes(context, propSegments, topLevelMdElementName, topLevelArtifact) {
    const { metadataCollector, compileModel } = context;
    const { metadataElementMap } = metadataCollector;
    let parentNode = metadataElementMap.get(topLevelMdElementName)?.node;
    let parentKey = topLevelMdElementName;
    let parentXsnNode = topLevelArtifact;
    let mdElementName = topLevelMdElementName; // build name for which md element can be found in metadata element map
    for (const propSegment of propSegments) {
        if (!parentNode) {
            continue; // could not resolve previous segment
        }
        if (isStructuredNode(context, parentNode)) {
            // (CDS targets do not support this, but paths in annotation values do)
            // current element/parameter is referencing structured type (which needs to be another top level artifact in cds model)
            // e.g. association or complex element; switch to this artifact for metadata collection
            const { collectorEntry: assocTargetEntry } = collectMdNodesForPath(context, parentNode?.structuredType?.split('.') || []);
            parentKey = parentNode.structuredType || parentKey;
            parentNode = assocTargetEntry?.node;
            parentXsnNode = compileModel?.definitions?.[parentKey];
            if (!assocTargetEntry || !parentNode || !parentXsnNode) {
                // error following association/finding complex type definition
                parentNode = undefined;
                continue;
            }
        }
        // resolve segment
        parentNode.content = parentNode.content || [];
        const parentInfo = { parentXsnNode, parentNode, parentKey, topLevelArtifact };
        const result = collectRelativeSegmentMdNode(context, parentInfo, propSegment, propSegments);
        mdElementName = result.mdElementName;
        parentXsnNode = result.xsnObject;
        parentNode = metadataElementMap.get(mdElementName)?.node;
        parentKey = mdElementName;
    }
    return { mdElementName, mdEntry: parentNode ? metadataElementMap.get(mdElementName) : undefined };
}
function collectRelativeSegmentMdNode(context, parentInfo, segment, segments) {
    const { parentNode, parentKey, parentXsnNode } = parentInfo;
    let mdElementName = parentKey + '/' + segment; // default, must be corrected for correct case in each if branch
    let xsnObject;
    if (parentNode.kind === 'service') {
        // entity sets, actionImports, functionImports: find them by searching over all definitions and verify via '_service' link
        const result = collectServiceChildren(context, parentInfo, segment);
        if (result) {
            ({ mdElementName, xsnObject } = result);
        }
    }
    else if (segment.endsWith('()') && parentXsnNode?.['actions']) {
        // bound action/function ?
        const result = collectBoundActionFunction(context, parentInfo, segment);
        if (result) {
            ({ mdElementName, xsnObject } = result);
        }
    }
    else if (parentKey?.endsWith('()')) {
        // params of bound or unbound action/function ?
        const result = collectActionFunctionParams(context, parentInfo, segment, segments);
        if (result) {
            ({ mdElementName, xsnObject } = result);
        }
    }
    else if (isDraftEnabledProperty(context, segment, parentXsnNode)) {
        // special (boolean) element 'IsActiveEntity' or 'HasActiveEntity' (entities in a service with "@odata.draft.enabled")
        mdElementName = collectDraftEnabledProperty(context, parentInfo, segment);
    }
    else if (parentXsnNode?.['elements']) {
        // regular element
        const result = collectElement(context, parentInfo, segment, segments);
        if (result) {
            ({ mdElementName, xsnObject } = result);
        }
    }
    return { xsnObject, mdElementName };
}
function collectDraftEnabledProperty(context, parentInfo, propSegment) {
    const { metadataCollector, converter } = context;
    const { metadataElementMap } = metadataCollector;
    const { parentKey, parentNode, parentXsnNode } = parentInfo;
    const propSegmentUc = propSegment.toUpperCase();
    const elementName = types_1.IS_ACTIVE_ENTITY_ELEM_NAME.toUpperCase() === propSegmentUc
        ? types_1.IS_ACTIVE_ENTITY_ELEM_NAME
        : types_1.HAS_ACTIVE_ENTITY_ELEM_NAME;
    const mdElementName = parentKey + '/' + elementName;
    if (parentXsnNode) {
        const draftPropertyNode = converter.convertDraftPropertyNode(parentXsnNode, elementName, parentInfo.parentKey);
        parentNode.content.push(draftPropertyNode);
        metadataElementMap.set(parentKey + '/' + elementName, { node: draftPropertyNode, parentKey });
    }
    return mdElementName;
}
function collectElement(context, parentInfo, propSegment, propSegments) {
    const { metadataElementMap } = context.metadataCollector;
    let xsnObject;
    let mdElementName = '';
    const parentXsnArtifact = parentInfo.parentXsnNode;
    if (getPropName(parentXsnArtifact.elements, propSegment) || isValidWildcardSegment(propSegments, propSegment)) {
        ({ mdElementName, xsnObject } = collectRegularElement(context, parentInfo, propSegment));
    }
    else if (propSegment.lastIndexOf('_') > 0 &&
        !mdElementName &&
        !metadataElementMap.has(mdElementName + '/' + propSegment)) {
        const result = collectCombinedElement(context, parentInfo, propSegment);
        if (result) {
            ({ mdElementName, xsnObject } = result);
        }
    }
    if (mdElementName) {
        return { xsnObject, mdElementName };
    }
    else {
        return null;
    }
}
function collectRegularElement(context, parentInfo, propSegment) {
    const { metadataCollector, converter } = context;
    const { metadataElementMap } = metadataCollector;
    const { parentKey, parentNode, parentXsnNode } = parentInfo;
    const parentXsnArtifact = parentXsnNode;
    // for wildcard segment collect the first element only
    const elementName = propSegment === '*' && parentXsnArtifact?.elements
        ? Object.keys(parentXsnArtifact?.elements)[0]
        : getPropName(parentXsnArtifact.elements, propSegment);
    const separator = parentNode.isComplexType && !parentNode.isAnnotatable ? '_' : '/';
    const mdElementName = parentKey + separator + elementName;
    if (!metadataElementMap.has(mdElementName)) {
        // collect md element
        let elementNodes;
        if (elementName && parentKey) {
            elementNodes = converter.convertElement(elementName, parentKey, parentXsnArtifact?.elements?.[elementName]);
        }
        for (const node of elementNodes || []) {
            parentNode.content.push(node);
            metadataElementMap.set(parentKey + '/' + node.name, { node, parentKey });
            collectStructuredTypeOfNode(context, node);
        }
    }
    return { mdElementName, xsnObject: elementName ? parentXsnArtifact?.elements?.[elementName] : undefined };
}
function collectCombinedElement(context, parentInfo, propSegment) {
    const findPropNameForCombinedName = (object, combinedNameAnyCase) => {
        const segments = combinedNameAnyCase.split('_');
        for (let i = segments.length - 1; i > 0; i--) {
            const propName = getPropName(object, segments.slice(0, i).join('_'));
            if (propName) {
                return propName;
            }
        }
        return '';
    };
    const { metadataCollector, converter } = context;
    const { metadataElementMap } = metadataCollector;
    const { parentKey, parentNode, parentXsnNode } = parentInfo;
    const parentXsnArtifact = parentXsnNode;
    const propName = findPropNameForCombinedName(parentXsnArtifact?.elements, propSegment);
    if (!propName) {
        return undefined;
    }
    // collect md elements for association keys
    let elementNodes = [];
    if (parentKey) {
        elementNodes = converter.convertElement(propName, parentKey, parentXsnArtifact?.elements?.[propName]);
    }
    let mdElementName;
    (elementNodes || []).forEach((node) => {
        if (!metadataElementMap.has(parentKey + '/' + node.name)) {
            parentNode.content.push(node);
            metadataElementMap.set(parentKey + '/' + node.name, { node, parentKey });
            collectStructuredTypeOfNode(context, node);
        }
        if (node.name.toUpperCase() === propSegment.toUpperCase()) {
            mdElementName = parentKey + '/' + node.name;
        }
    });
    return mdElementName ? { mdElementName } : undefined;
}
function collectActionFunctionParams(context, parentInfo, propSegment, propSegments) {
    const params = parentInfo?.parentXsnNode?.params;
    const propSegmentUc = propSegment.toUpperCase();
    let xsnObject;
    let mdElementName = '';
    if (params && (getPropName(params, propSegment) || isValidWildcardSegment(propSegments, propSegment))) {
        // for wildcard segment it is enough to collect first parameter only
        ({ mdElementName, xsnObject } = collectParameter(context, parentInfo, propSegment));
    }
    else if (parentInfo?.parentXsnNode?.returns && propSegmentUc === types_1.RETURN_PARAM_NAME.toUpperCase()) {
        ({ mdElementName, xsnObject } = collectReturnParameter(context, parentInfo));
    }
    else {
        const result = collectUnnamedBindingParameter(context, parentInfo, propSegment);
        if (result) {
            ({ mdElementName, xsnObject } = result);
        }
    }
    if (mdElementName) {
        return { xsnObject, mdElementName };
    }
    else {
        return null;
    }
}
function collectReturnParameter(context, parentInfo) {
    const { metadataCollector, converter } = context;
    const { metadataElementMap } = metadataCollector;
    const { parentKey, parentNode, parentXsnNode } = parentInfo;
    const mdElementName = parentKey + '/' + types_1.RETURN_PARAM_NAME;
    if (!metadataElementMap.has(mdElementName)) {
        // collect md element
        const node = converter.convertReturnParameter(parentXsnNode, parentNode.path);
        if (node) {
            parentNode.content.push(node);
            metadataElementMap.set(mdElementName, { node, parentKey });
            collectStructuredTypeOfNode(context, node);
        }
    }
    return { mdElementName, xsnObject: parentXsnNode?.returns };
}
function collectParameter(context, parentInfo, propSegment) {
    const { metadataCollector, compileModel, converter } = context;
    const { metadataElementMap } = metadataCollector;
    const { parentKey, parentNode, parentXsnNode, topLevelArtifact } = parentInfo;
    const paramName = propSegment === '*' && parentXsnNode?.params?.length
        ? Object.keys(parentXsnNode.params)[0]
        : getPropName(parentXsnNode?.params, propSegment);
    const mdElementName = parentKey + '/' + paramName;
    if (!metadataElementMap.has(mdElementName) && paramName) {
        // collect md element
        const node = converter.convertParameter(paramName, parentNode.path, parentXsnNode?.params?.[paramName]);
        if (node?.structuredType === types_1.TYPE_NAME_OF_BINDING_PARAMETER) {
            // md element represents named binding parameter
            node.isAnnotatable = false;
            node.isEntityType = true;
            node.isCollectionValued = !!parentXsnNode?.params?.[paramName].items;
            const namedObj = (0, utils_1.getNameObj)(topLevelArtifact, compileModel.compiler);
            node.structuredType = context.converter.convertNameToEdmx(namedObj.absolute);
        }
        if (node) {
            parentNode.content.push(node);
            metadataElementMap.set(mdElementName, { node, parentKey });
            collectStructuredTypeOfNode(context, node);
        }
    }
    return { mdElementName, xsnObject: paramName ? parentXsnNode?.params?.[paramName] : undefined };
}
function collectUnnamedBindingParameter(context, parentInfo, propSegment) {
    const { metadataCollector, converter } = context;
    const { metadataElementMap } = metadataCollector;
    const { parentKey, parentNode, parentXsnNode, topLevelArtifact } = parentInfo;
    const bindingParameterNamed = Object.keys(parentXsnNode?.params || {}).find((param) => {
        const paramXsn = parentXsnNode?.params?.[param];
        const path = (paramXsn?.items || paramXsn)?.type?.path || [];
        return path?.length === 1 && path[0]?.id === types_1.TYPE_NAME_OF_BINDING_PARAMETER;
    });
    if (bindingParameterNamed) {
        return null; // named binding parameter should be resolved already by resolveParameter()
    }
    const bindingParameterName = parentXsnNode?.['@cds.odata.bindingparameter.name']?.val ||
        parentXsnNode?.['@cds.odata.bindingparameter.collection']?.val ||
        'in';
    if (propSegment.toUpperCase() !== bindingParameterName.toUpperCase()) {
        return null;
    }
    const mdElementName = parentKey + '/' + bindingParameterName;
    if (!metadataElementMap.has(mdElementName)) {
        const node = converter.convertBindingParameter(parentXsnNode, topLevelArtifact, parentNode.path);
        parentNode.content.push(node);
        metadataElementMap.set(mdElementName, { node, parentKey });
        collectStructuredTypeOfNode(context, node);
    }
    return { mdElementName, xsnObject: topLevelArtifact };
}
function collectBoundActionFunction(context, parentInfo, propSegment) {
    const { metadataCollector, converter } = context;
    const { metadataElementMap } = metadataCollector;
    const { parentKey, parentXsnNode } = parentInfo;
    const artifact = parentXsnNode;
    const actionName = getPropName(artifact.actions, propSegment.slice(0, -2));
    if (!actionName) {
        return null;
    }
    const mdElementName = parentKey + '/' + actionName + '()';
    if (!metadataElementMap.has(mdElementName) && parentKey && artifact?.actions?.[actionName]) {
        // collect md element
        const node = converter.convertBoundAction(parentKey, actionName, artifact?.actions?.[actionName]);
        // bound actions and functions are collected at root level (i.e. not as children of containing entity)
        metadataElementMap.set(mdElementName, { node });
    }
    return { mdElementName, xsnObject: artifact?.actions?.[actionName] };
}
function collectServiceChildren(context, parentInfo, propSegment) {
    const { metadataCollector, compileModel } = context;
    const { metadataElementMap } = metadataCollector;
    const { parentKey, parentNode } = parentInfo;
    let propSegmentCds = propSegment;
    if (!compileModel?.definitions || !getPropName(compileModel.definitions, parentKey + '.' + propSegment)) {
        if (parentKey && propSegment.lastIndexOf('_') > 0) {
            propSegmentCds = findEmbeddedEntityCdsName(compileModel.definitions, parentKey, propSegment);
        }
        else {
            propSegmentCds = '';
        }
    }
    if (!propSegmentCds) {
        return null;
    }
    let containerChildFqName = getPropName(compileModel.definitions, parentKey + '.' + propSegmentCds);
    const artifact = containerChildFqName ? compileModel.definitions[containerChildFqName] : undefined;
    const serviceArtifact = artifact?._service;
    const namedObj = serviceArtifact ? (0, utils_1.getNameObj)(serviceArtifact, compileModel.compiler) : undefined;
    if (containerChildFqName?.startsWith(types_1.ENTITY_PREFIX_LOCALIZED) ||
        namedObj.absolute !== parentKey ||
        artifact?.kind === 'event' ||
        artifact?.kind === 'namespace') {
        return null;
    }
    if (containerChildFqName) {
        containerChildFqName = context.converter.convertNameToEdmx(containerChildFqName);
    }
    const containerChildName = parentKey?.length ? containerChildFqName?.slice(parentKey.length + 1) : '';
    const mdElementName = parentKey + '/' + containerChildName;
    if (!metadataElementMap.has(mdElementName)) {
        // collect md element
        let containerChild = parentNode.content.find((entry) => entry.name === containerChildName);
        if (!containerChild) {
            containerChild = getContainerChild(context, artifact, containerChildName, parentNode.path, containerChildFqName);
            parentNode.content.push(containerChild);
        }
        if (containerChild) {
            metadataElementMap.set(mdElementName, { node: containerChild, parentKey });
        }
    }
    return { mdElementName, xsnObject: artifact };
}
function isDraftEnabledProperty(context, propSegment, parentXsnNode) {
    const propSegmentUc = propSegment.toUpperCase();
    return ((types_1.IS_ACTIVE_ENTITY_ELEM_NAME.toUpperCase() === propSegmentUc ||
        types_1.HAS_ACTIVE_ENTITY_ELEM_NAME.toUpperCase() === propSegmentUc) &&
        !!parentXsnNode &&
        ['entity', 'view'].includes(parentXsnNode.kind) &&
        isEntityDraftEnabled(context, parentXsnNode));
}
function isEntityDraftEnabled(context, entity) {
    const { metadataCollector, compileModel } = context;
    const draftNodesPerService = metadataCollector.draftNodesPerService;
    const serviceName = (0, utils_2.getServiceNameForEntity)(entity, compileModel);
    if (serviceName && !draftNodesPerService.has(serviceName)) {
        // collect all draft nodes (including draft roots) for service name
        draftNodesPerService.set(serviceName, (0, draftSupport_1.getDraftNodesForService)(serviceName, context.converter, compileModel));
    }
    const entityName = (0, utils_1.getNameObj)(entity, compileModel?.compiler);
    const edmxName = context.converter.convertNameToEdmx(entityName.absolute) ?? '';
    return !!serviceName && !!draftNodesPerService?.get(serviceName)?.has(edmxName);
}
function collectStructuredTypeOfNode(context, node) {
    const { metadataCollector, compileModel } = context;
    if (node.structuredType &&
        !metadataCollector.metadataElementMap.has(node.structuredType) &&
        compileModel?.definitions[context.converter.convertNameFromEdmx(node.structuredType) || node.structuredType]) {
        // collect md element for target structured type
        const segments = node.structuredType.split('.');
        const result = collectMdNodesForPath(context, segments);
        if (result?.collectorEntry?.node?.keys && result?.collectorEntry?.node?.keys.length) {
            // for associations: add first key element to metadata (type information needed fr checking applicable terms)
            collectMdNodesForPath(context, [...segments, result?.collectorEntry?.node?.keys[0]]);
        }
    }
}
function getPropName(object, propNameAnyCase) {
    return object?.[propNameAnyCase]
        ? propNameAnyCase
        : Object.keys(object || {}).find((propName) => propName.toUpperCase() === propNameAnyCase.toUpperCase());
}
function getContainerChild(context, artifact, containerChildName, parentPath, containerChildFqName) {
    const { compileModel, converter } = context;
    let containerChild;
    if (containerChildName) {
        // build child node
        // build child node
        if (artifact?.kind && ['action', 'function'].includes(artifact.kind)) {
            // imports for unbound actions functions (bound actions/function cannot have imports)
            containerChild = converter.convertActionFunctionImportNode(containerChildName, parentPath, containerChildFqName, artifact);
        }
        else {
            containerChild = converter.convertEntitySetNode(containerChildName, parentPath, artifact);
        }
    }
    const structuredType = containerChild?.structuredType;
    if (structuredType && compileModel.definitions[converter.convertNameFromEdmx(structuredType) || structuredType]) {
        // collect action/function/entity type behind actionImport/functionImport/entitySet   // TODO break circle here ?
        //  (since follow up collections of e.g. entity type would always pick existing entity set,
        //   because the segments are the same)
        collectMdNodesForPath(context, structuredType.split('.'));
    }
    return containerChild;
}
function isStructuredNode(context, parentNode) {
    const structuredTypeCds = context.converter.convertNameFromEdmx(parentNode.structuredType) || parentNode.structuredType || '';
    return (['element', 'entitySet', 'param'].includes(parentNode.kind) &&
        parentNode.structuredType &&
        !!context.compileModel?.definitions[structuredTypeCds]);
}
function isValidWildcardSegment(propSegments, propSegment) {
    return propSegment === '*' && propSegments.indexOf(propSegment) === propSegments.length - 1;
}
function collectCommonValueListOnDbLayer(context, baseKey, relativePath) {
    // we need to guess fully qualified entity name from simple name in 'CollectionRoot' (might be well defined only after propagation to service layer)
    // first try same namespace as target entity
    const { compileModel } = context;
    const segments = baseKey.split('.');
    const namespace = segments.slice(0, segments.length - 1).join('.');
    const relativePathReplaced = relativePath.replace(`${SERVICE_NAME_PLACEHOLDER}/`, `${namespace}.`);
    const pathSegments = relativePathReplaced.split('/');
    const result = collectMdNodesForPath(context, pathSegments, 1);
    if (!result.collectorEntry && compileModel?.definitions && relativePath.includes('/')) {
        // not found: find any entity type having same simple name
        const simpleName = relativePath.split('/')[1];
        const definitions = compileModel?.definitions;
        const fqName = Object.keys(definitions).find((key) => (key === simpleName || key.endsWith(`.${simpleName}`)) && definitions[key].kind === 'entity');
        const relativePathReplaced = relativePath.replace(`${SERVICE_NAME_PLACEHOLDER}/${simpleName}`, fqName || '');
        const pathSegments = relativePathReplaced.split('/');
        collectMdNodesForPath(context, pathSegments, 1);
    }
}
function collectActionFunction(context, relativePath, baseKey, serviceName) {
    const { compileModel } = context;
    const actionName = relativePath.split('.').pop();
    if (actionName && compileModel?.definitions[baseKey]?.actions?.[actionName]) {
        // bound action/function (to base entity)
        const baseSegments = baseKey.split('.');
        collectMdNodesForPath(context, [...baseSegments, actionName + '()'], baseSegments.length);
    }
    else if (compileModel?.definitions[relativePath.slice(1)]) {
        // unbound action/function
        const baseSegments = (relativePath.slice(1) + '()').split('.');
        collectMdNodesForPath(context, baseSegments);
    }
    else {
        // action/function bound to other entity?
        collectActionFunctionOnOtherEntity(context, relativePath, serviceName);
    }
}
function collectActionFunctionOnOtherEntity(context, relativePath, serviceName) {
    const actionName = relativePath.split('.').pop();
    // get service entity names
    const serviceArtifacts = context.compileModel?.definitions[serviceName]?.artifacts;
    const serviceEntityNames = Object.keys(serviceArtifacts || {}).filter((artifactName) => serviceArtifacts?.[artifactName].kind === 'entity');
    // try to find bound action/function
    for (const serviceEntityName of serviceEntityNames) {
        const baseKey = serviceName + '.' + serviceEntityName;
        if (actionName && context.compileModel?.definitions[baseKey]?.actions?.[actionName]) {
            // bound action/function (to none base entity)
            const baseSegments = baseKey.split('.');
            collectMdNodesForPath(context, [...baseSegments, actionName + '()'], baseSegments.length);
            break;
        }
    }
}
function findEmbeddedEntityCdsName(object, namespace, entityEdmxName) {
    const nameAllDots = `${namespace}.${entityEdmxName}`.replaceAll('_', '.');
    // find definition with matching namespace and if all '_' in edmxEntityName are replaced with '.'
    const name = Object.keys(object ?? {}).find((key) => key.startsWith(`${namespace}.`) && key.replaceAll('_', '.') === nameAllDots);
    return name ? name.substring(`${namespace}.`.length) : '';
}
//# sourceMappingURL=collection.js.map