"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIndex = void 0;
const url_1 = require("url");
const fileIndex_1 = require("./fileIndex");
const cdsSource_1 = require("./cdsSource");
const copy = (source) => ({
    into: (target) => {
        for (const t of source) {
            target.add(t);
        }
    }
});
const getUriIndex = (model) => {
    const files = new Map();
    const builtUris = [];
    const sourcePaths = Object.keys(model.sources || {});
    for (const sourcePath of sourcePaths) {
        const source = model.sources[sourcePath];
        const sourceUri = (0, url_1.pathToFileURL)(source.realname).toString();
        const index = (0, fileIndex_1.createFileIndexFromSource)(sourceUri, source, model.compiler);
        files.set(sourceUri, index);
        builtUris.push(sourceUri);
    }
    return [files, builtUris];
};
const forUri = (files) => (uri, create) => {
    let fileIndex = undefined;
    fileIndex = files.get(uri);
    // for windows, some NodeJS methods will output uppercase drive letters, some in lowercase
    if (!fileIndex && process.platform === 'win32') {
        const parsedUri = (0, url_1.fileURLToPath)(uri);
        uri = (0, url_1.pathToFileURL)(parsedUri).toString();
        fileIndex = files.get(uri); // sometimes uri contains escaped characters
        if (!fileIndex) {
            uri = (0, cdsSource_1.toggleCase)(parsedUri.charAt(0)) + parsedUri.slice(1); // sometimes drive letter case differs
            uri = (0, url_1.pathToFileURL)(uri).toString();
            fileIndex = files.get(uri);
        }
    }
    if (fileIndex) {
        return fileIndex;
    }
    if (create !== undefined) {
        throw new Error('Create parameter is not supported.');
    }
    throw new Error('File index not found.');
};
function createIndex(model) {
    const _transitiveDependencies = new Map();
    const builtUris = [];
    const [newFiles, newUris] = getUriIndex(model);
    const files = new Map([...newFiles]);
    builtUris.push(...newUris);
    function getTransitiveDependencies(source) {
        let result = _transitiveDependencies.get(source) ?? calculateTransitiveDependencies([source])[0];
        if (result.isShared) {
            result = new Set(result); // clone - this is a shared hull of a cycle and we must remove the given uri
            result.delete(source);
            _transitiveDependencies.set(source, result);
        }
        return result;
    }
    function calculateTransitiveDependencies(sources) {
        function followAndCollect(ownUri) {
            const alreadyCalculated = _transitiveDependencies.get(ownUri);
            if (alreadyCalculated) {
                return alreadyCalculated;
            }
            let ownHull = new Set();
            _transitiveDependencies.set(ownUri, ownHull);
            const directDependentUris = files.get(ownUri)?.directDependentUris ?? [];
            copy(directDependentUris).into(ownHull); // add all directs first
            for (const dependencyUri of directDependentUris) {
                const foreignHull = followAndCollect(dependencyUri);
                if (foreignHull.has(ownUri)) {
                    // cycle. maybe not complete yet. share hulls
                    copy(ownHull).into(foreignHull);
                    ownHull = foreignHull;
                    _transitiveDependencies.set(ownUri, ownHull);
                    foreignHull.isShared = true;
                }
                else {
                    copy(foreignHull).into(ownHull);
                }
            }
            return ownHull;
        }
        return sources.map((uri) => followAndCollect(uri));
    }
    return Object.freeze({
        builtUris,
        getTransitiveDependencies,
        forUri: forUri(files)
    });
}
exports.createIndex = createIndex;
//# sourceMappingURL=blitzIndex.js.map