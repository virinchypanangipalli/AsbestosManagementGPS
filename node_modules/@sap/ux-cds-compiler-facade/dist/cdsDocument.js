"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCdsDocument = void 0;
const odata_annotation_core_types_1 = require("@sap-ux/odata-annotation-core-types");
const cdsSource_1 = require("./cdsSource");
const transform_1 = require("./transform");
const utils_1 = require("./utils");
function getTokenTypes(source) {
    const tokenNames = source.tokenStream.tokenSource.getTokenNames();
    const mappedNames = new Map([
        ['USING', 'Using'],
        ['FROM', 'From'],
        ["'{'", 'LeftCurly'],
        ["'}'", 'RightCurly'],
        ['String', 'String']
    ]);
    const tokenTypes = {};
    for (let index = 0; index < tokenNames.length; index++) {
        const element = tokenNames[index];
        const key = mappedNames.get(element);
        if (key) {
            tokenTypes[key] = index;
            mappedNames.delete(element);
        }
    }
    if (mappedNames.size !== 0) {
        throw new Error(`Token types for: ${[...mappedNames.values()].join(',')} are not found!`);
    }
    return tokenTypes;
}
function getCdsDocument(uri, compileModel) {
    const source = (0, cdsSource_1.getSourceByUri)(uri, compileModel);
    if (!source) {
        return undefined;
    }
    const tokenTypes = getTokenTypes(source);
    const tokens = source.tokenStream.tokens;
    const lastToken = tokens[tokens.length - 1];
    const documentEnd = convertToken(lastToken)?.range?.end ?? odata_annotation_core_types_1.Position.create(0, 0);
    return {
        type: 'cds-document',
        dependencies: source.dependencies.map(convertDependency(tokenTypes, tokens, source.usings, compileModel.compiler)),
        annotateDirectives: [],
        namespace: undefined,
        range: odata_annotation_core_types_1.Range.create(odata_annotation_core_types_1.Position.create(0, 0), documentEnd)
    };
}
exports.getCdsDocument = getCdsDocument;
function convertDependency(tokenTypes, tokens, usings, compiler) {
    return function (dependency) {
        const using = (0, transform_1.findUsing)(usings, dependency);
        if (!using) {
            throw new Error('Could not find using!');
        }
        const usingToken = convertToken(tokens.find((token) => token.type === tokenTypes.Using &&
            token.line === using.location.line &&
            token.column === using.location.col - 1));
        const fromToken = convertToken(tokens.find((token) => token.type === tokenTypes.From &&
            token.line >= using.location.line &&
            token.column >= using.location.col - 1 &&
            token.line <= dependency.location.line &&
            token.column <= dependency.location.col - 1));
        if (!usingToken) {
            throw new Error(`Could not find "using" token!`);
        }
        if (!fromToken) {
            throw new Error('Could not find "from" token!');
        }
        const node = {
            type: 'dependency',
            from: fromToken,
            using: usingToken,
            module: {
                type: 'string',
                value: dependency.val ?? '',
                range: (0, transform_1.locationToRange)(dependency.location)
            },
            range: (0, transform_1.locationToRange)(using.location)
        };
        if (using.usings) {
            // find left curly inside the range of using node
            const open = convertToken(tokens.find((token) => token.type === tokenTypes.LeftCurly &&
                token.line >= using.location.line &&
                token.column >= using.location.col - 1 &&
                token.line <= dependency.location.line &&
                token.column <= dependency.location.col - 1));
            // find right curly inside the range of using node
            const close = convertToken(tokens.find((token) => token.type === tokenTypes.RightCurly &&
                token.line >= using.location.line &&
                token.column >= using.location.col - 1 &&
                token.line <= dependency.location.line &&
                token.column <= dependency.location.col - 1));
            const names = using.usings.map((using) => {
                return {
                    type: 'named-using',
                    localName: {
                        type: 'token',
                        value: using.name.id,
                        range: (0, transform_1.locationToRange)(using.name.location)
                    },
                    importedName: {
                        type: 'token',
                        value: (0, utils_1.getNameObj)(using, compiler).absolute,
                        range: (0, transform_1.locationToRange)(using.name.location)
                    }
                };
            });
            node.names = {
                type: 'named-usings',
                names,
                range: (0, transform_1.locationToRange)(using.location),
                commas: [],
                open,
                close
            };
        }
        return node;
    };
}
function convertToken(token) {
    if (!token) {
        return undefined;
    }
    return {
        type: 'token',
        value: token.text,
        range: odata_annotation_core_types_1.Range.create(token.line - 1, token.column, token.line - 1, token.column + token.text.length)
    };
}
//# sourceMappingURL=cdsDocument.js.map