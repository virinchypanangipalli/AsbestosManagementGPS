/**
 * Please pay special attention to `$` or `_` as they are probably considered private to CDS compiler
 * and can be deleted without informing consumer.
 *
 * Link to XSN Consumer: https://github.tools.sap/cap/cds-compiler/blob/main/internalDoc/XsnConsumers.md
 */
declare module '@sap/cds-compiler-types' {
    export function version(): string;

    export interface Token {
        readonly type: number;
        /**
         * text is used to identify surrounding context for following situation [there might be more]
         * - start of comment i.e `//` or `/*`
         * - native CDS term. i.e `@title` or fully qualified term or simple OData term [identifier]
         * - extend deletion range so that it includes CDS separator like `,` `:` or comment
         * - start of `[` or `{`
         * - identify embedded annotation
         */
        readonly text: string;
        /**
         * line number, 1-based
         */
        readonly line: number;
        /**
         * column number, 0-based
         */
        readonly column: number;
        /**
         * position of token inside token array
         * @note  not used
         */
        readonly tokenIndex: number;
        /**
         * use to identify 'Element', 'Param', 'BoundAction', 'Annotate'
         */
        readonly isIdentifier?: string;
    }

    export interface TokenStream {
        readonly tokens: ReadonlyArray<Token>;
        readonly tokenSource: {
            readonly inputStream: {
                /**
                 * use to extract annotation. Annotation Modeler has its own parser for annotation domain
                 */
                readonly strdata: string;
            };
            /**
             * Used to get token types when searching for a particular token.
             */
            getTokenNames(): (string | null)[];
        };
    }

    /**
     * XSN- and CSN-style location
     */
    export interface XsnLocation {
        /**
         * map to `XsnLocation.start` along with `col`
         */
        readonly line: number;
        readonly col: number;
        /**
         * map to `XsnLocation.end` along with `endCol`
         */
        readonly endLine: number;
        readonly endCol: number;
        /**
         * relative file i.e "..\\db\\schema.cds"
         * @note map to `fileName` internally. See `XsnLocation.fileName`
         * @note cds compiler 2.*
         */
        readonly file: string;
    }

    export type XsnKind =
        | 'using'
        | 'entity'
        | 'view'
        | 'type'
        | 'aspect'
        | 'element'
        | 'service'
        | 'namespace'
        | 'block'
        | 'action'
        | 'event'
        | 'function'
        | 'context';

    export interface XsnNameBase {
        /**
         * use to get artifact's name i.e entity, action
         * @example "IncidentService.IncidentFlow"
         */
        readonly absolute: string;
        /**
         * use for alias [specifically in case of `using` state when there is not alias]
         * use as part of namespace i.e my.name.space
         */
        readonly id: string;
        readonly location: XsnLocation;
    }

    export interface XsnPathSegment {
        readonly location: XsnLocation;
    }

    export interface XsnName extends XsnNameBase {
        /**
         * use to create name for element or nav element i.e. <absolute>.<element>
         * use to create path for element or nave element i.e <absolute>/<element>
         * @example IncidentService.Incidents.identifier
         * @example IncidentService.Incidents/modifiedAt
         */
        readonly element: string;
        /**
         * use to create name for action i.e. <absolute>.<action>
         * @example IncidentService.Incidents.actionNamePart
         */
        readonly action: string;
        /**
         * use to create name for param of an action i.e <absolute>.<action>.<param> or <absolute>.<param> or <targetName>/<param>
         * @example IncidentService.Incidents.actionNamePart.paramPart
         * @example IncidentService.Incidents/paramPart
         */
        readonly param: string;
        /**
         * use location of path to build line and column
         */
        readonly path?: ReadonlyArray<XsnPathSegment>;
        /**
         * use to create carrier name
         */
        readonly _artifact?: XsnNamedObject;
    }

    export interface XsnNamedObject {
        /**
         * use to identify XSN element kind to build Annotation Modeler internal metadata element node
         * @note when used as XsnTypedObject.type._artifact and kind = 'type': we expect elements: XsnElements
         */
        readonly kind: XsnKind;
        readonly name: XsnName;
        readonly location: XsnLocation;
        /**
         * use to identify CDS build in type and map them to OData type
         * @example 'cds.Double' maps to 'Edm.Double',
         */
        readonly builtin?: boolean;
    }

    export interface XsnOriginatedObject extends XsnNamedObject {
        /**
         * use to get file name
         * use to build artifact name i.e <absolute>.<element> or <absolute>.<action>
         * use to identify cardinality in case of association
         * @note  v2: follow _origin recursively to e.g. @sap.cds.common
         */
        readonly _origin?: XsnOriginatedObject;
    }

    interface XsnFinalEffectiveType {
        readonly kind: XsnKind;
        readonly name?: XsnName;
        readonly target: {
            /**
             * use to build internal Annotation Modeler target map
             */
            readonly _artifact?: XsnObject;
        };
        readonly type?: {
            /**
             * this along with `builtin` is used to identify CDS build in **primitive** type and map them to OData type
             */
            readonly _artifact?: XsnNamedObject;
        };
        /**
         * use to build internal Annotation Modeler target map for propagation of annotations applied to **nested elements of target**
         * use to build Annotation Modeler internal metadata element node
         */
        readonly elements?: XsnElements;
        /**
         * use to identify CDS build in type and map them to OData type
         * @example 'cds.Double' maps to 'Edm.Double',
         */
        readonly builtin?: boolean;
        /**
         * helps [condition checking] to map CDS to OData type
         * helps [condition checking] to identify a node is entity or complex type
         * helps [condition checking] to identify a node is collection valued
         * @note present if "many" clause is used
         */
        readonly items?: XsnTypedObject;
    }

    export interface XsnTypedObject {
        /**
         * helps [condition checking] to map CDS to OData type
         * helps [condition checking] to identify a node is entity or complex type
         * helps [condition checking] to identify a node is collection valued
         * @note present if "many" clause is used
         */
        readonly items?: XsnTypedObject;
        readonly type?: {
            /**
             * use to get structure type i.e "scp.cloud.Category"
             */
            readonly _artifact?: XsnNamedObject | XsnArtifact;
            /**
             * use to check if an element is propagated
             * @description an element is considered as propagated when it has `$inferred` in its type definition
             */
            readonly $inferred?: string;
            /**
             * use to identify binding parameters in bound actions/functions (path with single entry which has id '$self')
             */
            readonly path?: ReadonlyArray<XsnNameBase>;
        };
        /**
         * use to get primitive type or structure type
         * @note cds compiler 2.*
         */
        readonly _effectiveType?: XsnFinalEffectiveType;
    }

    export interface XsnAnnotationAssignment extends XsnNamedObject {
        readonly kind?: 'annotate';
    }

    export interface XsnAnnotation extends XsnNamedObject {
        /**
         * use to get annotation value
         * @example use to identify binding param from `@cds.odata.bindingparameter.name`
         * @example use to identify singleton from `@odata.singleton`
         * @example use to identify draft enabled from `@odata.draft.enabled`
         */
        readonly val: string | boolean;
        /**
         * use to filter out propagated annotations for a target
         */
        readonly $inferred: string;
    }

    export interface XsnAnnotatedObject extends XsnNamedObject {
        /**
         * use to extract annotation text
         * use range info for comparison to identify and get carrier name
         * @note cds compiler 2.*
         */
        readonly $annotations?: ReadonlyArray<XsnAnnotationAssignment>;

        /**
         * '@-properties', representing (maybe propagated) annotations
         * @example  @odata.draft.enabled
         * @note for more details see `XsnAnnotation` type
         */
        readonly [atTermQualifier: string]: XsnAnnotation;
    }

    export interface XsnObject extends XsnAnnotatedObject, XsnTypedObject, XsnOriginatedObject {
        /**
         * use to extract params info of bound or unbound actions or functions
         */
        readonly params?: XsnElements;
        /**
         * use to extract returns info of bound or unbound actions or functions
         */
        readonly returns?: XsnElement;
    }

    interface XsnKeyObject extends XsnTypedObject {
        readonly kind: 'key';
        readonly targetElement?: {
            /**
             * use to generate key element if key is association
             */
            _artifact: XsnElement;
        };
    }

    export interface XsnElement extends XsnObject {
        readonly kind: 'element' | 'action' | 'function';
        readonly foreignKeys?: {
            /**
             * use to build up associations key fields
             */
            readonly [name: string]: XsnKeyObject;
        };
        /**
         * helps [condition checking] to identify element artifact or draft enabled for "@fiori.draft.enabled"
         */
        readonly key: { val: boolean };
        /**
         * effective sequence number (to define order of parameters in the action/function signature)
         */
        readonly $effectiveSeqNo?: number;
    }

    export interface XsnArtifact extends XsnObject {
        /**
         * use to identify `@odata.draft.enabled` node or existing service
         * or to identify entity sets of a service
         */
        readonly _service?: XsnNamedObject;
        /**
         * use to extract artifact names i.e `Incidents`
         */
        readonly artifacts?: XsnArtifacts;
        /**
         * use to build Annotation Modeler internal metadata element node
         * use to build internal Annotation Modeler target map for propagation of annotations
         */
        readonly elements?: XsnElements;
        /**
         * use to extract entity name
         * @description found e.g. here "extend projection TravelService.Travel with { <name> }"
         */
        readonly columns?: XsnElements;
        /**
         * use to extract actions
         * use to build Annotation Modeler internal metadata element node for actions
         */
        readonly actions?: XsnElements;
        readonly cardinality?: {
            /**
             * use to identify too many association
             */
            readonly targetMax: {
                readonly literal: string;
                readonly val: string;
            };
        };
        /**
         * use to extract artifact name
         */
        readonly extensions?: ReadonlyArray<XsnExtension>;
    }

    type Severity = 'Error' | 'Warning' | 'Info' | 'Debug';

    export interface XsnMessage {
        readonly message: string;
        readonly $location: XsnLocation;
        readonly severity: Severity;
    }

    interface XsnArtifacts {
        readonly [localName: string]: XsnArtifact;
    }

    interface XsnElements {
        readonly [localName: string]: XsnElement;
    }

    export interface XsnDependency {
        /**
         * use to collect direct dependencies
         * use to build namespace from dependency
         */
        readonly realname: string;
        readonly val?: string;
        readonly location: XsnLocation;
    }

    export interface XsnExtension extends XsnAnnotatedObject {
        readonly elements?: XsnElements;
    }

    export interface XsnUsing {
        readonly location: XsnLocation;
        readonly name: XsnNameBase;
        readonly usings?: ReadonlyArray<XsnUsing>;
        readonly fileDep?: {
            /**
             * use to build namespace from using
             */
            readonly realname?: any;
            /**
             * use to build namespace from using
             */
            readonly val?: any;
            readonly location?: XsnLocation;
        };
    }

    export interface XsnNamespace {
        /**
         * since @sap/cds-compiler v4.8.1: path is not there anymore - moved to name property
         */
        readonly path?: ReadonlyArray<XsnNameBase>;
        /**
         * since @sap/cds-compiler v4.8.1: path is contained in name property
         */
        readonly name?: {
            readonly path: ReadonlyArray<XsnNameBase>;
        };
    }

    export interface XsnSource {
        readonly kind: 'source';
        /**
         * use along with `_layerExtends` to build CDS file sequence
         */
        readonly _layerRepresentative: XsnSource;
        /**
         * a dictionary of directly or indirectly dependent layer representatives
         * @note present if source is a "layerRepresentative"
         */
        readonly _layerExtends?: { readonly [realname: string]: XsnSource };
        /**
         * use to build blitz index
         * use to build CDS file sequence
         * absolute local path i.e 'app/project-name/annotations.cds'
         */
        readonly realname: string;
        readonly location?: {
            /**
             * use to get relative file path
             * @note cds compiler 2.*
             */
            file: string;
        };
        readonly artifacts: XsnArtifacts;
        readonly dependencies: ReadonlyArray<XsnDependency>;
        readonly extensions: ReadonlyArray<XsnExtension>;
        readonly usings: ReadonlyArray<XsnUsing>;
        readonly tokenStream: TokenStream;
        readonly namespace?: XsnNamespace;
        readonly options?: {
            /**
             * use to get compiler messages
             */
            messages: ReadonlyArray<XsnMessage>;
        };
    }

    export interface XsnCompileModel {
        readonly definitions: XsnArtifacts;
        readonly sources: {
            readonly [absoluteLocalPath: string]: XsnSource;
        };
        compiler: ICdsCompiler;
    }

    type FileContent = string;

    // v2.0 compile function to get XSN model
    declare namespace $lsp {
        export function compile(
            fileNames: string[],
            dir?: string,
            options?: any,
            map?: { readonly [localPath: string]: FileContent }
        ): Promise<XsnCompileModel>;

        export function getArtifactName(thing: any): any;
    }

    export interface ICdsCompiler {
        getArtifactName(thing: any): any;
    }
}
