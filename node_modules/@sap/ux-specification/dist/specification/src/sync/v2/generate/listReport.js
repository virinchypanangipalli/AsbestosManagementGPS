"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateListReportSchemaV2 = exports.addEnumForVariantPaths = void 0;
const utils_1 = require("./utils");
const import_1 = require("../import");
const common_1 = require("../../common");
const i18next_1 = __importDefault(require("i18next"));
const ux_specification_types_1 = require("@sap/ux-specification-types");
const extensionLogger_1 = require("../../../extensionLogger");
const types_1 = require("../types");
const types_2 = require("../../../../../types/src/common/types");
const ROOT_PROPERTIES_ORDER = ['filterBar', 'table', 'footer'];
const UIVOCABULARYDOT = ux_specification_types_1.UIVOCABULARYALPHADOT.substring(1); // reference to the ui vocabluary without leading '@' but with trailing'.'
/**
 * Adds the enum types for QuickVariant and QuickVariantX, based on the entity type annotations
 * @param {EntityType} entityType
 * @param {EntitySet} entitySet - current entity set of the page or view
 * @param {Definition} appSchema - app specific JSON schema
 * @param {ConvertedMetadata} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 */
function addEnumForVariantPaths(entityType, entitySet, appSchema, oDataServiceAVT) {
    (0, common_1.addEnumForSingleTabVariant)(entityType, appSchema, 'QuickVariant');
    (0, common_1.addEnumForMultiTabVariant)(appSchema, 'QuickVariantX', entitySet);
    (0, common_1.addEnumForVariantEntitySet)(oDataServiceAVT, appSchema, 'QuickVariantX');
}
exports.addEnumForVariantPaths = addEnumForVariantPaths;
/**
 * Adds an enum filled with existing UI annotations for annotationPath property in FilterBar
 * @param {EntityType} entityType
 * @param appSchema - app specific JSOn schema
 * @param definitionName - name of the definition in the app schema
 */
function addEnumForFilterBarAnnotationPath(entityType, appSchema, definitionName) {
    const annoPath = appSchema.definitions[definitionName].properties.annotationPath;
    const validAnnotations = [
        "com.sap.vocabularies.UI.v1.SelectionPresentationVariant" /* UIAnnotationTerms.SelectionPresentationVariant */,
        "com.sap.vocabularies.UI.v1.SelectionVariant" /* UIAnnotationTerms.SelectionVariant */,
        "com.sap.vocabularies.UI.v1.PresentationVariant" /* UIAnnotationTerms.PresentationVariant */
    ];
    (0, common_1.addEnumForValidAnnotations)(entityType, validAnnotations, annoPath);
}
// Helper function for getLineItemAnnotation which determines the presentation variant to be used. The parameters of both functions have identical meaning.
function getPresentationVariantForLineItem(uIAnnotations, settings, logger) {
    let presentationVariant; // the presentation variant to be used to determine the LineItem
    const annotationPath = settings?.annotationPath;
    // Note: annotationPath (if it exists) contains the fully qualified annotation name (starting with UIVOCABULARYDOT) which would be a member of enum UIAnnotationTerms.
    // Inside uiAnnotations the unqualified annotation names are used as keys. They can be found in enum FacetBase or obtained from the terms above by removing UIVOCABULARYDOT.
    if (annotationPath) {
        const isSPV = annotationPath.includes("com.sap.vocabularies.UI.v1.SelectionPresentationVariant" /* UIAnnotationTerms.SelectionPresentationVariant */);
        const isPV = !isSPV && annotationPath.includes("com.sap.vocabularies.UI.v1.PresentationVariant" /* UIAnnotationTerms.PresentationVariant */);
        if (isSPV || isPV) {
            const accessor = annotationPath.replace(UIVOCABULARYDOT, '');
            const uiAnnotation = uIAnnotations[accessor]; // the ui annotation specified by the annotationPath if it exists
            if (uiAnnotation) {
                if (isPV) {
                    presentationVariant = uiAnnotation;
                }
                else {
                    // SPV case
                    presentationVariant = uiAnnotation[types_2.FacetBase.PresentationVariant];
                    if (presentationVariant &&
                        presentationVariant.fullyQualifiedName.includes(types_2.FacetBase.SelectionPresentationVariant)) {
                        presentationVariant = uIAnnotations[types_2.FacetBase.PresentationVariant]; // inline presentation variants are ignored, use standard presentation variant instead
                    }
                }
            }
            else {
                // annotationPath is pointing to a selection presentation variant or a presentation variant but the corresponding annotation does not exist
                (0, extensionLogger_1.log)(logger, {
                    severity: "warning" /* LogSeverity.Warning */,
                    message: i18next_1.default.t('NOANNOTATIONFORPATH', { annotationPath: annotationPath })
                });
                // If the annotationPath has specified a non-existing selection presentation variant fall back to the standard presentation variant
                if (isSPV) {
                    presentationVariant = uIAnnotations[types_2.FacetBase.PresentationVariant];
                }
            }
        }
        else {
            // annotationPath exists but does not point to a selection presentation variant or presentation variant (should point to a selection variant then)
            presentationVariant = uIAnnotations[types_2.FacetBase.PresentationVariant]; // use standard presentation variant in this case
        }
    }
    else {
        presentationVariant = uIAnnotations[types_2.FacetBase.PresentationVariant];
    }
    return presentationVariant;
}
// Determine the LineItemAnnotation to be used for the LR.
// Reproduces logic from Fiori Elements LR implementation (function createWorkingContext in LR specific AnnotationHelper).
function getLineItemAnnotation(uIAnnotations, settings, // an object (actually a piece of the manifest) possessing an optional property annotationPath which would define the path to the PresentationVariant
logger // used in case an error/warning is detected while determining the result
) {
    if ((0, utils_1.hasPropertyTypeError)(settings, 'annotationPath', logger)) {
        return undefined; // return undefined in case there is an error in the settings
    }
    const presentationVariant = getPresentationVariantForLineItem(uIAnnotations, settings, logger); // the presentation variant to be used to determine the LineItem (if there is one)
    // If a PV could be determined LineItem should be defined as a visualization of the PV.
    const visualizations = presentationVariant?.Visualizations || [];
    let lineItemName = ''; // the name that will be used to retrieve the LineItem from uiAnnotations
    visualizations.some(function (visualization) {
        lineItemName = (0, utils_1.retrieveNameWithoutVocabularyFromVisualization)(types_2.FacetBase.LineItem, visualization);
        return lineItemName; // end loop as soon as name of LineItem has been identified
    });
    // If the above logic did not identify a name for the LineItem then still the corresponding annotation (but without qualifier) will be used
    lineItemName = lineItemName || types_2.FacetBase.LineItem;
    const lineItem = uIAnnotations[lineItemName];
    if (!lineItem) {
        (0, extensionLogger_1.log)(logger, {
            severity: "warning" /* LogSeverity.Warning */,
            message: i18next_1.default.t('NOLINEITEMFORPATH', { annotationPath: lineItemName })
        });
    }
    return lineItem;
}
/**
 * Generates an app specific schema for the FE V2 Listreport from the generic schema.
 * Generic types are replaced by information from the app specific annotations.
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {object} genericSchema - generic JSON schema of a list report
 * @returns appSchema - the application specific JSON schema
 */
function generateListReportSchemaV2(generateParameters, genericSchema) {
    const appSchema = JSON.parse(JSON.stringify(genericSchema));
    const lrLineItems = {
        $ref: common_1.DEFINITION_LINK_PREFIX + ux_specification_types_1.DefinitionName.LineItems
    };
    const lrToolBar = common_1.DEFINITION_LINK_PREFIX + ux_specification_types_1.DefinitionName.ToolBarLR;
    types_1.LINEITEMTABLETYPES.forEach((tableType, i) => {
        appSchema.properties.table['anyOf'][i.toString()]['$ref'] = common_1.DEFINITION_LINK_PREFIX + tableType;
        const tableTypeRaw = tableType.replace('<LineItems>', '');
        const localGenericSchema = JSON.parse(JSON.stringify(genericSchema.definitions[tableTypeRaw]));
        localGenericSchema.properties.columns = lrLineItems;
        localGenericSchema.properties.toolBar['$ref'] = lrToolBar;
        appSchema.definitions[tableType] = localGenericSchema;
    });
    const { entityType, uIAnnotations } = (0, utils_1.getUIAnnotationForEntitySet)(generateParameters); // would log an error in case these entities are missing
    if (uIAnnotations) {
        // then entityType is there as well
        // retrieve page definition of root page from manifest
        const pageKeys = [];
        const v2Page = (0, import_1.findListReportPageV2)(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, pageKeys);
        // handle standard header actions
        (0, utils_1.addStandardHeaderActions)(appSchema);
        //handle line items
        const lineItemAnnotation = getLineItemAnnotation(uIAnnotations, v2Page?.component?.settings, generateParameters.logger);
        if (lineItemAnnotation) {
            const annotationPath = (0, common_1.createAnnotationPath)(entityType.fullyQualifiedName, lineItemAnnotation.term, lineItemAnnotation.qualifier);
            types_1.LINEITEMTABLETYPES.forEach((tableType) => {
                appSchema.definitions[tableType][ux_specification_types_1.SchemaTag.annotationPath] = annotationPath;
            });
        }
        (0, utils_1.addLineItemsType)(false, appSchema, lineItemAnnotation, entityType);
        //handle filter fields
        const selectionFieldAnnotation = uIAnnotations.SelectionFields;
        (0, utils_1.addSelectionFields)(appSchema, selectionFieldAnnotation, entityType);
        //add fields for createWithParameterDialog
        (0, common_1.addFieldsType)(appSchema, entityType);
        // add entityProperties to a enum, in this case MultiEdit -> ignoredFields
        appSchema.definitions.MultiEdit.properties.ignoredFields['items']['enum'] = [];
        (0, utils_1.addEntityPropertiesToEnum)(appSchema.definitions.MultiEdit.properties.ignoredFields['items']['enum'], entityType);
        if (!v2Page) {
            (0, extensionLogger_1.log)(generateParameters.logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOLR'),
                location: {
                    path: ux_specification_types_1.MANIFESTPATH,
                    range: [ux_specification_types_1.ManifestSection.generic]
                }
            });
            return appSchema;
        }
        (0, utils_1.addTableColumnExtensions)(appSchema, entityType, v2Page, generateParameters.manifest, generateParameters.fragments);
        addEnumForVariantPaths(entityType, generateParameters.entitySet, appSchema, generateParameters.serviceAVT);
        addEnumForFilterBarAnnotationPath(entityType, appSchema, ux_specification_types_1.DefinitionName.ListReportFilterBar);
        (0, common_1.addEnumFieldGroupAnnotationPath)(entityType, appSchema, ux_specification_types_1.DefinitionName.MultiEditV2);
        //Delete generic definitions
        delete appSchema.definitions.ResponsiveTableWithMultiSelect;
        delete appSchema.definitions.ResponsiveTableWithInlineDelete;
        delete appSchema.definitions.TreeTable;
        delete appSchema.definitions.AnalyticalTable;
        delete appSchema.definitions.GridTable;
        delete appSchema.definitions.GenericColumns;
        delete appSchema.definitions.TableColumnAction;
        delete appSchema.definitions.ToolBar;
        delete appSchema.definitions.Actions;
        delete appSchema.definitions.GenericFooter;
        delete appSchema.definitions.FieldPath;
        delete appSchema.definitions.Share;
    }
    (0, common_1.updatePropertyIndices)(appSchema, ROOT_PROPERTIES_ORDER);
    return appSchema;
}
exports.generateListReportSchemaV2 = generateListReportSchemaV2;
//# sourceMappingURL=listReport.js.map