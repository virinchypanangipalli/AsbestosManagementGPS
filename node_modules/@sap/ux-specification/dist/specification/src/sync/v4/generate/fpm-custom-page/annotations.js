"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.annotationMacrosHandlers = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const listReport_1 = require("../listReport");
const common_1 = require("../../../common");
const utils_1 = require("./utils");
const utils_2 = require("../../utils/utils");
/**
 * Method resolves passed "metaPath" property from XML node.
 * @param {string} metaPath "metaPath" property from XML node.
 * @returns {MetaPathResolution} Meta path resolution.
 */
function resolveMetaPath(metaPath) {
    const metaPathParts = metaPath.split('/');
    const pathParts = [];
    let term;
    for (const metaPathPart of metaPathParts) {
        if (metaPathPart) {
            if (metaPathPart.startsWith('@')) {
                term = metaPathPart;
                break;
            }
            pathParts.push(metaPathPart);
        }
    }
    if (pathParts.length) {
        return {
            path: pathParts.join('/'),
            term
        };
    }
    return { term: metaPath };
}
/**
 * Method returns entity type for passed macros annotation handler params.
 * @param {HandlerParams} params Macros annotation handler params containing serviceAvt and connection context information.
 * @returns {EntityType | undefined} EntityType for passed connection.
 */
function getEntityTypeResolution(params) {
    const { node, serviceAVT, connectionContext } = params;
    const contextPath = (0, utils_1.getAttribute)(node, 'contextPath') || connectionContext.contextPath;
    let metaPath = (0, utils_1.getAttribute)(node, 'metaPath');
    const entitySet = connectionContext.entitySet;
    const isAbsoluteMetaPath = metaPath?.startsWith('/');
    if (!contextPath && !entitySet && !isAbsoluteMetaPath) {
        return undefined;
    }
    let path = contextPath || `/${entitySet}`;
    if (metaPath) {
        const metaPathResolution = resolveMetaPath(metaPath);
        if (metaPathResolution.path) {
            path = isAbsoluteMetaPath ? metaPathResolution.path : `${path}/${metaPathResolution.path}`;
            metaPath = metaPathResolution.term;
        }
    }
    const resolvedContextPath = serviceAVT?.resolvePath(path);
    let entityType;
    switch (resolvedContextPath?.target?.['_type']) {
        case 'EntitySet': {
            entityType = resolvedContextPath.target.entityType;
            break;
        }
        case 'NavigationProperty': {
            entityType = resolvedContextPath.target.targetType;
            break;
        }
        case 'EntityType': {
            entityType = resolvedContextPath.target;
            break;
        }
    }
    // Resolve qualifier
    let qualifier;
    const qualiferParts = metaPath.split('#');
    if (qualiferParts.length) {
        qualifier = qualiferParts[1];
    }
    // Annotation key in "vocabularies" annotations
    let annotationKey = undefined;
    if (metaPath) {
        const keyParts = metaPath.split('.');
        if (keyParts.length) {
            annotationKey = keyParts[keyParts.length - 1];
        }
    }
    return entityType
        ? {
            entityType,
            metaPath,
            qualifier,
            annotationKey
        }
        : undefined;
}
/**
 * Method applies annotation path for passed XML node's schema.
 * @param {HandlerParams} schema Schema to update with "annotationPath".
 * @param {EntityTypeResolution} [entityTypeResolution] Entity type resolution object.
 */
function applyAnnotationPath(schema, entityTypeResolution) {
    if (entityTypeResolution?.metaPath) {
        const { entityType, metaPath } = entityTypeResolution;
        schema.annotationPath = `/${entityType.fullyQualifiedName}/${metaPath}`;
    }
}
/**
 * Method returns data for table annotation line items for passed entity type resolution.
 * @param {EntityTypeResolution} entityTypeResolution Entity type resolution object.
 * @param {ConvertedMetadata} serviceAVT Combined service metadata, as returned by annotation vocabularies tools.
 * @param {ConvertedMetadata} alias Annotation alias.
 * @returns {TableLineItemAnnotationData | undefined} Table annotation line items.
 */
function getTableLineItemAnnotationData(entityTypeResolution, serviceAVT, alias) {
    const { metaPath, entityType } = entityTypeResolution;
    let lineItem;
    let annotationPath;
    if (entityType && metaPath) {
        const annotation = (0, listReport_1.analyzeViewAnnotation)(metaPath, entityType?.annotations?.[alias], serviceAVT);
        if (annotation.visualization) {
            const annotationTerm = annotation.visualization.split('.')[1];
            lineItem = entityType?.annotations?.[alias]?.[annotationTerm];
            if (lineItem?.fullyQualifiedName) {
                annotationPath = (0, common_1.getAnnotationPathUsingFullyQualifiedName)(entityType, lineItem.fullyQualifiedName);
            }
        }
    }
    if (lineItem) {
        return {
            lineItem,
            annotationPath
        };
    }
    return undefined;
}
// Handlers map for macros controls
exports.annotationMacrosHandlers = {
    'sap.fe.macros.Chart': (params) => {
        const entityTypeResolution = getEntityTypeResolution(params);
        applyAnnotationPath(params.schema, entityTypeResolution);
    },
    'sap.fe.macros.FilterBar': (params) => {
        const { schema, serviceAVT, rootSchema } = params;
        const entityTypeResolution = getEntityTypeResolution(params);
        // Handler selection fields
        const filterFieldsDefinition = schema.properties?.filterFields;
        if (typeof filterFieldsDefinition === 'object' && entityTypeResolution?.annotationKey) {
            if (!filterFieldsDefinition.properties) {
                filterFieldsDefinition.properties = {};
            }
            const alias = (0, common_1.findAlias)(ux_specification_types_1.UIVOCABULARY, serviceAVT);
            const selectionFieldAnnotation = alias && entityTypeResolution.entityType?.annotations?.[alias]?.[entityTypeResolution.annotationKey];
            (0, listReport_1.addSelectionFields)(entityTypeResolution.entityType, rootSchema, selectionFieldAnnotation, filterFieldsDefinition, entityTypeResolution.qualifier);
        }
    },
    'sap.fe.macros.Table': (params) => {
        const { schema, serviceAVT, rootSchema } = params;
        const entityTypeResolution = getEntityTypeResolution(params);
        const colDefinition = schema.properties.columns;
        const actionDefinition = schema.properties.actions;
        if (typeof colDefinition === 'object' && typeof actionDefinition === 'object' && entityTypeResolution) {
            if (!colDefinition.properties) {
                colDefinition.properties = {};
            }
            if (!actionDefinition.properties) {
                actionDefinition.properties = {};
            }
            const alias = (0, common_1.findAlias)(ux_specification_types_1.UIVOCABULARY, serviceAVT);
            applyAnnotationPath(schema, entityTypeResolution);
            if (schema.annotationPath) {
                const annotationData = getTableLineItemAnnotationData(entityTypeResolution, serviceAVT, alias);
                if (annotationData?.annotationPath) {
                    schema.annotationPath = annotationData.annotationPath;
                }
                const dataForLineItem = {
                    isObjectPage: false,
                    appSchema: rootSchema,
                    lineItemAnnotation: annotationData.lineItem,
                    entityType: entityTypeResolution.entityType,
                    oDataServiceAVT: serviceAVT,
                    lineItemId: ux_specification_types_1.DefinitionName.LineItems
                };
                (0, utils_2.appendLineItemsToSchema)(dataForLineItem, actionDefinition, schema.annotationPath, colDefinition);
            }
        }
    }
};
//# sourceMappingURL=annotations.js.map