"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSchema = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const ux_specification_types_2 = require("@sap/ux-specification-types");
const types_1 = require("./types");
const corrections_1 = require("./corrections");
const common_1 = require("../../src/sync/common");
/**
 * Method checks if passed type is atomic type like 'boolean', 'string', 'number', etc.
 * @param {string} type Type to check.
 * @returns {boolean} Is atomic type.
 */
function isAtomicType(type) {
    return ['string', 'number', 'integer', 'boolean', 'object', 'array', 'null', 'any'].includes(type);
}
/**
 * Method returns base/skeleton schema.
 * @returns {SchemaDefinition} JSON schema.
 */
function getRootSchema() {
    const hiddenProperty = { type: 'string', hidden: true };
    return {
        type: 'object',
        metadata: {
            namespaces: []
        },
        properties: {
            $filePath: hiddenProperty,
            $schema: hiddenProperty
        },
        additionalProperties: false,
        definitions: {},
        $schema: 'http://json-schema.org/draft-07/schema#'
    };
}
/**
 * Method formats description text before storing it into schema.
 * Currently method removes HTML markup from text.
 * @param {string} [description] Description to format.
 * @returns {string} Formatted description.
 */
function formatDescription(description) {
    if (description) {
        // Replace combination of HTML break and new line with single line
        description = description.replace(/<br\/>\n/g, '\n');
        // Replace remaining separate HTML break with new line
        description = description.replace(/<br\/>/g, '\n');
        // Remove HTML markup
        return description.replace(/<[^>]*>?/g, '');
    }
    return '';
}
/**
 * Method prepares schema definition object.
 * @param {MacrosPropertyType} metadataType Metadata property type.
 * @param {string} [description] Description of definition.
 * @param {string} defaultAggreation Default aggregation.
 * @returns {SchemaDefinition} JSON schema for definition.
 */
function prepareDefinition(metadataType, description, defaultAggreation) {
    if (description) {
        // Remove html markup from description
        description = formatDescription(description);
    }
    const definition = {
        description,
        isViewNode: true,
        type: 'object',
        properties: {},
        additionalProperties: false,
        metadata: {
            path: [],
            type: metadataType
        }
    };
    if (defaultAggreation) {
        definition.metadata.defaultAggregation = defaultAggreation;
    }
    return definition;
}
/**
 * Method prepares schema object for passed type.
 * @param {string} type Type of target property or object.
 * @returns {SchemaDefinition} JSON schema.
 */
function getSchemaForType(type) {
    const schema = {};
    if (isAtomicType(type)) {
        schema.type = type;
    }
    else {
        schema.$ref = `#/definitions/${type}`;
    }
    return schema;
}
/**
 * Method prepares schema object for passed types.
 * @param {string | string[]} [type] Type(s) of target property or object.
 * @param {UI5PropertyType[]} [types] Types of target property or object.
 * @returns {SchemaDefinition} JSON schema.
 */
function getTypes(type, propertyTypes) {
    let result = [];
    if (type) {
        result = Array.isArray(type) ? type : type.split('|').map((subType) => subType.trim());
    }
    else if (propertyTypes) {
        result = propertyTypes.map((propertyType) => propertyType.value);
    }
    return result.map((propertyType) => {
        return getSchemaForType(propertyType);
    });
}
/**
 * Method prepares schema property object for passed generic property.
 * @param {UI5Property} property SAPUI5 property.
 * @param {MacrosPropertyType} metadataType Metadata property type.
 * @param {string} [type] Type of target property or object.
 * @param {UI5PropertyType[]} [types] Types of target property or object.
 * @returns {SchemaDefinition} JSON schema.
 */
function prepareSchemaProperty(property, metadataType, type, types) {
    const schemaTypes = getTypes(type, types);
    // modify bindable number property type by adding another type (string) with binding syntax pattern
    if (type === 'number' && 'bindable' in property && property.bindable) {
        schemaTypes.push({
            type: 'string',
            pattern: "^{[A-Za-z0-9{}&$!@#%? _|,<>'()[\\]\\/:=.]+}$"
        });
    }
    const isViewNode = schemaTypes.some((schemaType) => !!schemaType.$ref);
    // Define result
    const propertySchema = schemaTypes.length === 1
        ? { ...schemaTypes[0] }
        : {
            anyOf: schemaTypes
        };
    propertySchema.description = formatDescription(property.description);
    propertySchema['artifactType'] = ux_specification_types_1.ArtifactType.XMLProperty;
    if (isViewNode) {
        propertySchema.description = property.name;
        propertySchema.isViewNode = true;
    }
    propertySchema.metadata = {
        type: metadataType
    };
    return propertySchema;
}
/**
 * Method returns allowed values for passed ui5 property.
 * @param {UI5Property} property SAPUI5 property.
 * @returns {string[] | undefined} Array of allowed values.
 */
function getAllowedValues(property) {
    if (property.allowedValues) {
        return property.allowedValues;
    }
    return property['ui5-metadata']?.['sap.fe']?.allowedValues;
}
/**
 * Method prepares schema object for passed SAPUI5 property.
 * @param {UI5Property} property SAPUI5 property.
 * @returns {SchemaDefinition} JSON schema.
 */
function prepareProperty(property) {
    const propertySchema = prepareSchemaProperty(property, ux_specification_types_2.MacrosPropertyType.Property, property.type, property.types);
    const allowedValues = getAllowedValues(property);
    if (allowedValues && propertySchema.type === 'string') {
        (0, common_1.addEnumToSchema)(allowedValues, propertySchema);
    }
    return propertySchema;
}
/**
 * Method prepares schema object for passed SAPUI5 event.
 * @param {UI5Property} property SAPUI5 event.
 * @returns {SchemaDefinition} JSON schema.
 */
function prepareEvent(property) {
    return prepareSchemaProperty(property, ux_specification_types_2.MacrosPropertyType.Event, 'string');
}
/**
 * Method prepares schema object for passed SAPUI5 aggregation.
 * @param {UI5Property} property SAPUI5 aggregation.
 * @returns {SchemaDefinition} JSON schema.
 */
function prepareAggregations(aggregation) {
    const schemaTypes = getTypes(aggregation.type);
    return {
        type: 'object',
        additionalProperties: schemaTypes.length ? schemaTypes[0] : { anyOf: schemaTypes },
        isViewNode: true,
        metadata: {
            path: [],
            type: ux_specification_types_2.MacrosPropertyType.Aggregation
        }
    };
}
/**
 * Method applies available macros namespaces for storing inside root schema metadata.
 * @param {MacrosAPI} api SAPUI5 "sap.fe.macros" api.
 * @param {SchemaDefinition} schema JSON schema for "sap.fe.macros" api.
 */
function applyNamespaces(api, schema) {
    for (const symbol of api.symbols) {
        if (symbol.kind === types_1.SYMBOL_KIND_NAMESPACE && symbol.name.startsWith('sap.fe.macros')) {
            schema.metadata.namespaces.push(symbol.name);
        }
    }
}
/**
 * Method generates generic schema for passed "sap.fe.macros" api.
 * @param {MacrosAPI} api SAPUI5 "sap.fe.macros" api.
 * @returns {SchemaDefinition} JSON schema for "sap.fe.macros" api.
 */
function generateSchema(api) {
    // Apply corrections for macros API - there is some missing information in api.json
    (0, corrections_1.applyCorrections)(api);
    const schema = getRootSchema();
    const { definitions } = schema;
    // Handle classes
    const classSymbols = api.symbols.filter((symbol) => symbol.kind === types_1.SYMBOL_KIND_CLASS);
    for (const symbol of classSymbols) {
        const definition = prepareDefinition(ux_specification_types_2.MacrosPropertyType.Control, symbol.description, symbol[types_1.CLASS_SYMBOL_METADATA_PROPERTY]?.defaultAggregation);
        definitions[symbol.name] = definition;
        const events = symbol.events || [];
        const { properties = [], aggregations = [] } = symbol[types_1.CLASS_SYMBOL_METADATA_PROPERTY] || {};
        // Handle properties
        for (const property of properties) {
            definition.properties[property.name] = prepareProperty(property);
        }
        // Handle aggregations
        for (const aggregation of aggregations) {
            definition.properties[aggregation.name] = prepareAggregations(aggregation);
        }
        // Handle events
        for (const event of events) {
            definition.properties[event.name] = prepareEvent(event);
        }
    }
    // Handle namespaces
    applyNamespaces(api, schema);
    // Handle typedefs
    const typedefSymbols = api.symbols.filter((symbol) => symbol.kind === types_1.SYMBOL_KIND_TYPEDEF);
    for (const symbol of typedefSymbols) {
        const definition = prepareDefinition(ux_specification_types_2.MacrosPropertyType.Control, symbol.description, symbol[types_1.CLASS_SYMBOL_METADATA_PROPERTY]?.defaultAggregation);
        definitions[symbol.name] = definition;
        const properties = symbol.properties || [];
        for (const property of properties) {
            definition.properties[property.name] = prepareProperty(property);
        }
    }
    return schema;
}
exports.generateSchema = generateSchema;
//# sourceMappingURL=schema.js.map