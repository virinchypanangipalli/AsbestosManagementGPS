"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeUI = void 0;
const d3_1 = require("d3");
const utils_1 = require("./utils");
const search_1 = require("./search");
const toggle_1 = require("./toggle");
const tooltip_1 = require("./tooltip");
const keyboardNavigation_1 = require("./keyboardNavigation");
class TreeUI {
    constructor() {
        // define the zoom listener which calls the zoom function
        this.zoomListener = (0, d3_1.zoom)().on('zoom', this.zoom.bind(this));
        // offset of canvas(for example external toolbar)
        this.canvasOffset = {
            x: 0,
            y: 0
        };
        this.duration = 450;
        this.innerWidth = window.innerWidth;
        this.innerHeight = window.innerHeight;
        this.searchResultContainer = document.querySelector('#search-result');
        this.buttonContainer = document.querySelector('#button-container');
        window.addEventListener('resize', () => this.updateCanvasSize());
    }
    render(container, data, icon) {
        this.countID = 0;
        this.rawTreeData = data;
        this.treeIcon = icon;
        this.maxLabelLength = 0;
        // select svg container for tree and set attributes
        this.svgTreeContainer = (0, d3_1.select)(container)
            .attr('width', this.innerWidth)
            .attr('height', this.innerHeight)
            .call(this.zoomListener.bind(this))
            .on('wheel.zoom', null)
            .on('dblclick.zoom', null)
            .on('mousewheel.zoom', null);
        // create group element for all tree elements
        this.svgTreeGroup = this.svgTreeContainer
            .append('g')
            .attr('id', 'svg-group')
            .attr('role', 'tree')
            .attr('aria-label', 'Configuration Documentation')
            .attr('aria-orientation', 'horizontal')
            .attr('transform', `translate(0,0)`);
        this.toolTip = (0, d3_1.select)(document.body)
            .append('div')
            .attr('tabindex', '0')
            .style('opacity', 1e-6)
            .attr('class', 'tooltip')
            .attr('role', 'tooltip');
        this.createRootHierarchy(data);
        this.rootNode.children.forEach(toggle_1.collapse);
        this.updateTree(this.rootNode);
        this.centerNode(this.rootNode, 2.5);
        // Store sizes of canvas
        const canvasSize = this.svgTreeContainer.node().getBoundingClientRect();
        if (canvasSize.x !== this.canvasOffset.x || canvasSize.y !== this.canvasOffset.y) {
            this.canvasOffset.x = canvasSize.left || 0;
            this.canvasOffset.y = canvasSize.top || 0;
            this.updateCanvasSize();
        }
    }
    toggleExpandAll(expand) {
        let ratio;
        if (expand) {
            (0, toggle_1.expandAll)(this.rootNode);
            ratio = 5;
        }
        else {
            this.rootNode.children.forEach(toggle_1.collapse);
            (0, keyboardNavigation_1.toggleTabIndex)(this.rootNode);
            ratio = 2.5;
        }
        this.updateTree(this.rootNode);
        this.centerNode(this.rootNode, ratio);
    }
    // function to filter the items in search list
    applyFilter(updatedTreeData, clear) {
        this.countID = 0;
        const originalDuration = this.duration;
        this.duration = 0;
        let ratio;
        if (updatedTreeData) {
            this.createRootHierarchy(updatedTreeData);
            ratio = 5;
        }
        else {
            this.createRootHierarchy(this.rawTreeData);
            if (clear) {
                this.rootNode.children.forEach(toggle_1.collapse);
            }
            else {
                (0, toggle_1.collapse)(this.rootNode);
            }
            ratio = 2.5;
        }
        (0, d3_1.select)('#svg-group').selectAll('g').remove();
        this.updateTree(this.rootNode);
        this.centerNode(this.rootNode, ratio);
        this.duration = originalDuration;
    }
    zoom(event) {
        this.svgTreeGroup.attr('transform', event.transform);
        (0, tooltip_1.removeTooltip)(this.toolTip);
    }
    zoomTree(value, center) {
        if (value === 0) {
            return this.fitToCanvas();
        }
        else {
            this.zoomListener.scaleTo(this.svgTreeContainer, value, [this.innerWidth / 2, this.innerHeight / 2]);
            if (center) {
                this.centerTree();
            }
        }
        return value;
    }
    fitToCanvas() {
        const offset = 100;
        let scaleFactor = 1;
        // Get current scale level and transformation sizing
        const zoom = (0, d3_1.zoomTransform)(this.svgTreeContainer.node()), bounds = this.svgTreeContainer.node().getBBox(), initialScale = zoom.k;
        let widthScale = scaleFactor, heightScale = scaleFactor;
        // adjust scale levle to size
        const originalWidth = bounds.width / initialScale, originalHeight = bounds.height / initialScale;
        if (originalWidth > this.innerWidth) {
            widthScale = this.innerWidth / (originalWidth + offset);
        }
        if (originalHeight > this.innerHeight) {
            heightScale = this.innerHeight / (originalHeight + offset);
        }
        scaleFactor = Math.min(widthScale, heightScale);
        // Calculate new X and Y
        const newWidth = originalWidth * scaleFactor;
        const newHeight = originalHeight * scaleFactor;
        // Update X and Y by trying to center
        const newX = (this.innerWidth - newWidth) / 2;
        const newY = (this.innerHeight - newHeight) / 2;
        // Apply calculation
        this.svgTreeContainer
            .transition()
            .duration(this.duration)
            .call(this.zoomListener.transform, d3_1.zoomIdentity.translate(newX, newY).scale(scaleFactor));
        return scaleFactor;
    }
    // function to center the tree or specific node
    centerNode(source, ratio) {
        const r = ratio || 2, node = (0, d3_1.zoomTransform)(this.svgTreeContainer.node());
        let x = -source.data.y0, y = -source.data.x0;
        x = x * node.k + this.innerWidth / r;
        y = y * node.k + this.innerHeight / 2;
        this.svgTreeContainer
            .transition()
            .duration(this.duration)
            .call(this.zoomListener.transform, d3_1.zoomIdentity.translate(x, y).scale(node.k));
    }
    centerTree() {
        // Get current scale level and transformation sizing
        const zoom = (0, d3_1.zoomTransform)(this.svgTreeContainer.node());
        const bounds = this.svgTreeContainer.node().getBBox();
        // Current size
        const x = (this.innerWidth - bounds.width) / 2;
        const y = (this.innerHeight - bounds.height) / 2;
        this.svgTreeContainer.call(this.zoomListener.transform, d3_1.zoomIdentity.translate(x, y).scale(zoom.k));
    }
    updateCanvasSize() {
        const canvasWidth = window.innerWidth - this.canvasOffset.x;
        const canvasHeight = window.innerHeight - this.canvasOffset.y;
        if (canvasWidth !== this.innerWidth || canvasHeight !== this.innerHeight) {
            this.innerWidth = canvasWidth;
            this.innerHeight = canvasHeight;
            this.svgTreeContainer.attr('width', this.innerWidth);
            this.svgTreeContainer.attr('height', this.innerHeight);
        }
    }
    createRootHierarchy(rootData) {
        const stringifyedData = JSON.parse(JSON.stringify(rootData));
        // assigns and calculates the data required for the nodes and links
        this.root = (0, d3_1.hierarchy)(stringifyedData, (d) => d.children);
        // assign position of root
        this.root.data.x0 = this.innerHeight / 2;
        this.root.data.y0 = 0;
        // establish maxLabelLength for horizontal spacing of nodes
        (0, utils_1.visit)(rootData, (d) => {
            this.maxLabelLength = Math.max(d.name.length + 25, this.maxLabelLength);
        }, (d) => {
            return d.children && d.children.length > 0 ? d.children : null;
        });
        this.treeLayout = (0, d3_1.tree)().size([this.innerHeight, this.innerWidth]);
        this.rootNode = this.treeLayout(this.root);
        this.setupEventListeners();
        (0, search_1.setupInBuiltSearch)(this.rootNode);
        return this.rootNode;
    }
    setupEventListeners() {
        this.searchResultContainer?.addEventListener('click', (event) => {
            const listElement = event.target;
            const noedPath = listElement.getAttribute('data-path');
            if (noedPath) {
                const node = (0, search_1.expandNodePath)(noedPath.split('-'), this.rootNode);
                this.updateTree(this.rootNode);
                this.centerNode(node, 2);
                (0, utils_1.animateNode)(node);
            }
        });
        this.buttonContainer?.addEventListener('click', (event) => {
            const button = event.target;
            let ratio;
            if (button.id === 'resetTree') {
                this.rootNode.children.forEach(toggle_1.collapse);
                ratio = 2.5;
            }
            else if (button.id === 'expandTree') {
                (0, toggle_1.expandAll)(this.rootNode);
                ratio = 5;
            }
            this.updateTree(this.rootNode);
            this.centerNode(this.rootNode, ratio);
        });
        this.toolTip?.on('keydown', (event) => {
            if (event.key === 'Escape') {
                (0, tooltip_1.removeTooltip)(this.toolTip);
            }
        });
    }
    handleEventOnNode(element, cb) {
        return element
            .on('click', (event, d) => {
            cb(event, d);
        })
            .on('keydown', (event, d) => {
            cb(event, d);
        });
    }
    updateTree(source) {
        this.treeLayout.size([this.getContentHeight(), this.innerWidth])(this.rootNode);
        // assign the nodes and links
        this.nodes = this.rootNode.descendants();
        this.links = this.rootNode.links();
        // determine the horizontal spacing of the nodes
        this.nodes.forEach((d) => {
            d.y = d.depth * (this.maxLabelLength * 5);
        });
        // ********************************** NODE SECTION **********************************
        // declare the nodes
        const node = this.svgTreeGroup
            .selectAll('g.node')
            .data(this.nodes, (d) => {
            if (!d.data.id) {
                d.data.id = ++this.countID;
            }
            return d.data.id;
        });
        // enter the nodes
        const nodeEnter = node
            .enter()
            .append('g')
            .attr('class', 'node')
            .attr('id', (d) => {
            return 'n-' + d.data.id;
        })
            .attr('transform', () => {
            return 'translate(' + source.data.y0 + ',' + source.data.x0 + ')';
        });
        // add labels to nodes
        const nodeText = nodeEnter
            .append('text')
            .attr('tabindex', '-1')
            .attr('id', (d) => 'd' + (d.depth + 1) + '-n' + d.data.id)
            .attr('role', 'treeitem')
            .attr('aria-level', (d) => d.depth + 1)
            .attr('aria-setsize', (d) => (d.parent ? d.parent.children.length : 1))
            .attr('class', 'node-text')
            .attr('dy', '.35em')
            .attr('x', 10)
            .attr('text-anchor', 'start')
            .attr('text-decoration', (d) => (d.data.description ? 'underline' : 'none'))
            .attr('cursor', (d) => (d.data.description ? 'pointer' : 'default'))
            .text((d) => (0, utils_1.splitName)(d.data.name))
            .on('focus', (_event, d) => {
            const elementRect = (0, d3_1.select)(`#n-${d.data.id}`).node().getBoundingClientRect();
            const canvasRect = this.svgTreeContainer.node().getBoundingClientRect();
            if (!(0, keyboardNavigation_1.checkIfNodeInViewport)(elementRect, canvasRect)) {
                this.centerNode(d);
            }
        })
            // return the bounding box of node to set elements accordingly
            .call(utils_1.getBB);
        nodeText.filter((d) => d.depth == 0).attr('tabindex', '0');
        // handle click on labels for nodes
        this.handleEventOnNode(nodeText, (event, d) => {
            if ('key' in event && event.type === 'keydown') {
                const { focus, toggle } = (0, keyboardNavigation_1.handleNavigationKeys)(event.key, d);
                if (event.key === 'Enter' && event.target instanceof Element) {
                    const coordinates = (0, tooltip_1.getTooltipCoordinates)(event);
                    (0, tooltip_1.showTooltip)(coordinates, d, this.toolTip);
                }
                if (toggle) {
                    this.toggleExpandOrCollapse(event, toggle);
                }
                if (focus) {
                    (0, keyboardNavigation_1.toggleActiveFocus)(focus);
                }
            }
            else if (!('key' in event)) {
                const coordinates = {
                    x: event.pageX,
                    y: event.pageY
                };
                (0, keyboardNavigation_1.toggleActiveFocus)(d);
                (0, tooltip_1.showTooltip)(coordinates, d, this.toolTip);
            }
        });
        // add icon of floorplan to root
        nodeEnter
            .filter((d) => d.depth == 0)
            .append('g')
            .attr('transform', 'translate(-15, -7)')
            .html(this.treeIcon);
        // filter nodes that contain children
        const nodeWithChildren = nodeEnter.filter((d) => d.children !== undefined);
        const nodeRect = nodeWithChildren.append('g').attr('aria-hidden', 'true').attr('class', 'node-rect-g');
        const nodeCircle = nodeWithChildren.append('g').attr('aria-hidden', 'true').attr('class', 'node-circle-g');
        // add element with amount of children to nodes
        nodeRect
            .append('text')
            .attr('class', 'node-rect-text')
            .attr('x', (d) => d.data.bbox.x + d.data.bbox.width + 20)
            .attr('dy', '.35em')
            .text((d) => d.data.children.length)
            .call(utils_1.getBB);
        nodeRect
            .insert('rect', 'text')
            .attr('class', 'node-child')
            .attr('x', (d) => d.data.bbox.x - 7)
            .attr('y', (d) => d.data.bbox.y - 1)
            .attr('width', (d) => d.data.bbox.width + 14)
            .attr('height', (d) => d.data.bbox.height + 2)
            .attr('ry', '8');
        // add clickable circle element to nodes with children
        nodeCircle
            .append('text')
            .attr('class', 'node-circle-text')
            .attr('x', (d) => d.data.bbox.x + d.data.bbox.width + 14)
            .attr('dy', '.35em')
            .text('+')
            .call(utils_1.getBB);
        nodeCircle
            .insert('circle', 'text')
            .attr('class', 'node-circle')
            .attr('r', (d) => d.data.bbox.height / 2)
            .attr('cx', (d) => d.data.bbox.x + d.data.bbox.width / 2)
            .attr('cy', (d) => d.data.bbox.y + d.data.bbox.height / 2);
        // handle click on clickable circle element
        this.handleEventOnNode(nodeCircle, (event, d) => {
            if (event.type === 'click') {
                if (d.children) {
                    (0, keyboardNavigation_1.toggleActiveFocus)(d);
                    this.toggleExpandOrCollapse(event, d);
                }
                else if (d.data._children) {
                    this.toggleExpandOrCollapse(event, d);
                    (0, keyboardNavigation_1.toggleActiveFocus)(d.children[0]);
                }
            }
        });
        // merge nodes to handle updates
        const nodeUpdate = nodeEnter.merge(node);
        // transition nodes to the correct position
        nodeUpdate
            .transition()
            .duration(this.duration)
            .attr('transform', (d) => {
            return 'translate(' + d.y + ',' + d.x + ')';
        });
        // change style of node elements on update
        nodeUpdate.select('.node-circle-g').attr('class', (d) => {
            return d.data._children ? 'node-circle-g collapsed' : 'node-circle-g expanded';
        });
        nodeUpdate
            .select('rect')
            .style('fill', (d) => {
            return d.data._children ? 'var(--vscode-foreground)' : 'var(--vscode-editor-background)';
        })
            .style('stroke', (d) => {
            return d.data._children ? 'none' : 'var( --vscode-editorWidget-border)';
        })
            .style('stroke-width', (d) => {
            return d.data._children ? 'none' : '1px solid';
        });
        nodeUpdate.select('.node-rect-text').style('fill', (d) => {
            return d.data._children ? 'var( --vscode-editor-background)' : 'var(--vscode-foreground)';
        });
        nodeUpdate.select('.node-circle-text').text((d) => {
            return d.data._children ? '+' : '−';
        });
        nodeUpdate
            .select('text')
            .filter((d) => d.children !== undefined)
            .attr('aria-expanded', (d) => {
            return d.data._children ? 'false' : 'true';
        });
        nodeUpdate.selectAll('text').style('fill-opacity', 1);
        // remove nodes on exit
        const nodeExit = node
            .exit()
            .transition()
            .duration(this.duration)
            .attr('transform', () => {
            return 'translate(' + source.y + ',' + source.x + ')';
        })
            .remove();
        // reduce size and opacity of nodes on exit
        nodeExit.select('circle').attr('r', 1e-6).style('fill-opacity', 1e-6);
        nodeExit.selectAll('rect').attr('x', 1e-6).style('fill-opacity', 1e-6);
        nodeExit.selectAll('text').style('fill-opacity', 1e-6);
        // ********************************** LINK SECTION ********************************
        // declare the links based on unique target id’s
        const link = this.svgTreeGroup
            .selectAll('path.link')
            .data(this.links, (d) => {
            return d.target.data.id;
        });
        // enter the links and set path
        const linkEnter = link
            .enter()
            .insert('path', 'g')
            .attr('class', 'link')
            .attr('d', (d) => {
            const y = 'y0' in source.data ? source.data.y0 : source.y;
            const x = 'x0' in source.data ? source.data.x0 : source.x;
            const sourceTest = d.source.copy();
            sourceTest.x = x;
            sourceTest.y = y;
            const result = (0, utils_1.diagonal)({
                source: sourceTest,
                target: sourceTest
            });
            return result;
        });
        // merge links to handle update
        const linkUpdate = linkEnter.merge(link);
        // transition links to the correct position
        linkUpdate.transition().duration(this.duration).attr('d', utils_1.diagonal);
        // remove links on exit
        link.exit()
            .transition()
            .duration(this.duration)
            .attr('d', () => {
            const result = (0, utils_1.diagonal)({
                source,
                target: source
            });
            return result; //Fix
        })
            .remove();
        // store position of elements for transition
        this.nodes.forEach((d) => {
            d.data.x0 = d.x;
            d.data.y0 = d.y;
        });
    }
    getContentHeight() {
        this.levelWidth = [1];
        (0, utils_1.childCount)(this.levelWidth, 0, this.rootNode);
        return (0, d3_1.max)(this.levelWidth) >= 10 ? (0, d3_1.max)(this.levelWidth) * 60 : (0, d3_1.max)(this.levelWidth) * 45; // pixels per line
    }
    // toggle children on toggleExpandOrCollapse
    toggleExpandOrCollapse(event, d) {
        // toggleExpandOrCollapse suppressed
        if (event.defaultPrevented)
            return;
        d = (0, toggle_1.toggleChildren)(d);
        this.updateTree(d);
        this.centerNode(d, 2);
        (0, tooltip_1.removeTooltip)(this.toolTip);
    }
}
exports.TreeUI = TreeUI;
//# sourceMappingURL=TreeUI.js.map